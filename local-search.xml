<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/20/%E5%89%91%E6%8C%87offer/"/>
    <url>/2023/02/20/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer题目指南"><a href="#剑指offer题目指南" class="headerlink" title="剑指offer题目指南"></a>剑指offer题目指南</h1><h3 id="3、数组中重复的元素"><a href="#3、数组中重复的元素" class="headerlink" title="3、数组中重复的元素"></a>3、数组中重复的元素</h3><p>下标法：交换到数字本身对应的下标位置（使用数组本身作为一个hashmap）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[nums[i]] == nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[temp];<br>            nums[temp] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4、二维数组查找"><a href="#4、二维数组查找" class="headerlink" title="4、二维数组查找"></a>4、二维数组查找</h3><p>左下角出发进行比较</p><ul><li>若给定数据更大，则右移一位</li><li>若给定数据更小，则上移一位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路本身简单，但有以下细节需要注意</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//注意为0的特殊情况</span><br>        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//注意如果matrix是空数组，则matrix.length为0，可用来赋值，但是matrix[0].length是未知量，不能用来赋值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> y - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; x &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> matrix[j][i];<br>            <span class="hljs-keyword">if</span> (num &gt; target) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; target) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) i--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) j++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5、替换空格"><a href="#5、替换空格" class="headerlink" title="5、替换空格"></a>5、替换空格</h3><p>如果只是使用stringbuilder，由于java不支持字符串原地扩容，所以一定要使用N的空间复杂度</p><p>如果使用C++，则可以原地扩容然后从右往左倒序遍历数组（空间复杂度为O(1)）</p><h3 id="6、从尾到头倒序打印链表"><a href="#6、从尾到头倒序打印链表" class="headerlink" title="6、从尾到头倒序打印链表"></a>6、从尾到头倒序打印链表</h3><ul><li>使用栈来实现逆序打印（栈的特性）</li><li>实际上先遍历一遍链表然后反着装一遍效率更高</li></ul><h3 id="7、重建二叉树"><a href="#7、重建二叉树" class="headerlink" title="7、重建二叉树"></a>7、重建二叉树</h3><p>根据前序遍历和中序遍历的结果返回二叉树根结点</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208224618157.png" alt="image-20230208224618157"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存在迭代方法进行求解，但是递归方法更为简洁，每一个部分都看做左子树和右子树进行求解</span><br><span class="hljs-comment">//这里实际上就是看清楚传递的参数和对应参数的关系</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorder_root</span> <span class="hljs-operator">=</span> preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_root]);<br>        <br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left_subtree</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i); <span class="hljs-comment">//快速求得对应结点的下标</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//纯享无注释版本</span><br><span class="hljs-comment">//为了快速获取到根结点对应的值</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_left]);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_left]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        root.left = myBuildTree(preorder, inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+sub,inorder_left,inorder_root-<span class="hljs-number">1</span> );<br>        root.right = myBuildTree(preorder, inorder, preorder_left + sub + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i); <span class="hljs-comment">//快速求得对应结点的下标</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="9、用两个栈实现队列"><a href="#9、用两个栈实现队列" class="headerlink" title="9、用两个栈实现队列"></a>9、用两个栈实现队列</h3><p>使用两个栈，A和B，每次出“队列”都是从栈B出，然后一旦B空了就从A中倒出来给B，再从B中出</p><p>实际上就是使用A倒给B的过程来实现队列的顺序操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">//输入可以直接添加即可，类似分段看做不同的栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        inStack.push(value);<br>    &#125;<br><br>    <span class="hljs-comment">//设定输出只能从输出栈中输出，类似将未合并的段进行合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>                outStack.push(inStack.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="10-1、斐波那契数列"><a href="#10-1、斐波那契数列" class="headerlink" title="10.1、斐波那契数列"></a>10.1、斐波那契数列</h3><p>迭代算法：相当于只使用三个格子不断的计算到对应的i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        n = n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            a = b;  <span class="hljs-comment">//注意这里先对ab进行修改再计算</span><br>            b = c;<br>            c = (a + b) % MOD; <span class="hljs-comment">//注意这个结果的时候就需要取余了</span><br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c % MOD;<br>    &#125;<br></code></pre></td></tr></table></figure><p>快速幂算法（字节）：时间复杂度为O(n)</p><ul><li>实际上是正数快速幂的修改版</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230210185547087.png" alt="image-20230210185547087"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] q = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = pow(q, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] pow(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">//和正常的快速幂算法类似</span><br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                ret = multiply(ret, a);<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>            a = multiply(a, a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">//这里定义矩阵的乘法运算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiply(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b) &#123;<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                c[i][j] = (<span class="hljs-type">int</span>) (((<span class="hljs-type">long</span>) a[i][<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>][j] + (<span class="hljs-type">long</span>) a[i][<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>][j]) % MOD);<br>            &#125;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="10-2、青蛙跳台问题"><a href="#10-2、青蛙跳台问题" class="headerlink" title="10.2、青蛙跳台问题"></a>10.2、青蛙跳台问题</h3><p>和斐波那契相同使用迭代法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <br>            sum = (a + b) % <span class="hljs-number">1000000007</span>;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;  <span class="hljs-comment">//提前两个输出，所以需要输出的是a</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//下面是仿照斐波那契数列编写的，显然上面那一种更为简洁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>        n = n - <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            a = b;  <span class="hljs-comment">//注意这里先对ab进行修改再计算</span><br>            b = sum;<br>            sum = (a + b) % MOD;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum % MOD;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="11、旋转数组的最小值"><a href="#11、旋转数组的最小值" class="headerlink" title="11、旋转数组的最小值"></a>11、旋转数组的最小值</h3><p>原本是1.2.3.4.5，旋转以后变成3.4.5.1.2，需要输出结果1</p><p>实际上就是两个递增的直线，求二分即可</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208123716838.png" alt="image-20230208123716838"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-comment">//关键在于考虑下面的左右判断情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123; <span class="hljs-comment">//右半部分</span><br>                high = pivot; <span class="hljs-comment">//要找的点肯定在该点的左边</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;  <span class="hljs-comment">//左半部分</span><br>                <span class="hljs-comment">//这里相对于上面为什么要+1的原因在于</span><br>                <span class="hljs-comment">//二分查找最后能扫描到左节点，而不能扫描到右节点</span><br>                low = pivot + <span class="hljs-number">1</span>; <span class="hljs-comment">//要找的点肯定在该点的右边</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high -= <span class="hljs-number">1</span>;<span class="hljs-comment">//减一的原因见上</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="12、矩阵中的路径（TODO手动实现）"><a href="#12、矩阵中的路径（TODO手动实现）" class="headerlink" title="12、矩阵中的路径（TODO手动实现）"></a>12、矩阵中的路径（TODO手动实现）</h3><p>在给定字母矩阵中查找有无特定单词</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230123412549.png" alt="image-20221230123412549"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> board.length, w = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[h][w];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; h; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; w; j++) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, i, j, word, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] != s.charAt(k)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == s.length() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//对于给定的起点，走一步check一圈</span><br>        <span class="hljs-type">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newj = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newi &gt;= <span class="hljs-number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="hljs-number">0</span> &amp;&amp; newj &lt; board[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[newi][newj]) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, newi, newj, s, k + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        result = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13、机器人移动路径（TODO）"><a href="#13、机器人移动路径（TODO）" class="headerlink" title="13、机器人移动路径（TODO）"></a>13、机器人移动路径（TODO）</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103211256983.png" alt="image-20230103211256983"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接进行DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n, k;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m; <span class="hljs-built_in">this</span>.n = n; <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-built_in">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> si, <span class="hljs-type">int</span> sj)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj) + dfs(i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="14-1、剪绳子"><a href="#14-1、剪绳子" class="headerlink" title="14.1、剪绳子"></a>14.1、剪绳子</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208140108564.png" alt="image-20230208140108564"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据推导得知在一定条件下，尽可能将给定数据按照3分组是最好的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient) * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//比上一题只是多了一个求余操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) rem = (rem * x) % p;<br>            x = (x * x) % p;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">6</span> % p);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15、二进制中1的个数"><a href="#15、二进制中1的个数" class="headerlink" title="15、二进制中1的个数"></a>15、二进制中1的个数</h3><p>根据<strong>数学性质</strong>进行求解</p><ul><li>这个数学性质也好推导，当数字为n时，n-1恰好相当于将原来的二进制数的最后一个1转换成0，然后再把这个1后面的所有0都变成1，最后做与运算，这个1及它后面的数字当然就全部变成0了</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230151004500.png" alt="image-20221230151004500"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16、快速幂求法"><a href="#16、快速幂求法" class="headerlink" title="16、快速幂求法"></a>16、快速幂求法</h3><p>迭代法思路：实际上就是将指数转换为二进制形式，根据二进制进行求解，并且不断将这个数向右移动</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230175430401.png" alt="image-20221230175430401"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归求法，每一次求幂都转换为求原来的一半</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> quickMul(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//迭代求法，相比于递归算法使用更少的空间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-comment">//对于负指数的操作</span><br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-comment">// 贡献的初始值为 x</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">x_contribute</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-comment">// 在对 N 进行二进制拆分的同时计算答案</span><br>        <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span><br>                ans *= x_contribute;<br>            &#125;<br>            <span class="hljs-comment">// 将贡献不断地平方</span><br>            x_contribute *= x_contribute;<br>            <span class="hljs-comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span><br>            N /= <span class="hljs-number">2</span>;<span class="hljs-comment">//相当于让数字向右移动一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、打印从-1-到最大的-n-位数"><a href="#17、打印从-1-到最大的-n-位数" class="headerlink" title="17、打印从 1 到最大的 n 位数"></a>17、打印从 1 到最大的 n 位数</h3><p>给定数字的位数，打印所有的数，本题唯一需要考虑的在于需要注意int类型的范围的情况（但是本题不需要考虑）</p><h3 id="18、删除链表的结点"><a href="#18、删除链表的结点" class="headerlink" title="18、删除链表的结点"></a>18、删除链表的结点</h3><p>简单删除即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//先处理链表头的情况</span><br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19、正则表达式匹配（TODO）"><a href="#19、正则表达式匹配（TODO）" class="headerlink" title="19、正则表达式匹配（TODO）"></a>19、正则表达式匹配（TODO）</h3><h3 id="20、表示数值的字符串（TODO）"><a href="#20、表示数值的字符串（TODO）" class="headerlink" title="20、表示数值的字符串（TODO）"></a>20、表示数值的字符串（TODO）</h3><p>有限自动状态机的应用</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230191442358.png" alt="image-20221230191442358"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();<br>        Map&lt;CharType, State&gt; initialMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_INITIAL);<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INITIAL, initialMap);<br>        Map&lt;CharType, State&gt; intSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INT_SIGN, intSignMap);<br>        Map&lt;CharType, State&gt; integerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_POINT, State.STATE_POINT);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INTEGER, integerMap);<br>        Map&lt;CharType, State&gt; pointMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT, pointMap);<br>        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);<br>        Map&lt;CharType, State&gt; fractionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_FRACTION, fractionMap);<br>        Map&lt;CharType, State&gt; expMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP, expMap);<br>        Map&lt;CharType, State&gt; expSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_SIGN, expSignMap);<br>        Map&lt;CharType, State&gt; expNumberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);<br>        Map&lt;CharType, State&gt; endMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_END, endMap);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> State.STATE_INITIAL;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">CharType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> toCharType(s.charAt(i));<br>            <span class="hljs-keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                state = transfer.get(state).get(type);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> CharType <span class="hljs-title function_">toCharType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_NUMBER;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_EXP;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_POINT;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SIGN;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SPACE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_ILLEGAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        STATE_INITIAL,<br>        STATE_INT_SIGN,<br>        STATE_INTEGER,<br>        STATE_POINT,<br>        STATE_POINT_WITHOUT_INT,<br>        STATE_FRACTION,<br>        STATE_EXP,<br>        STATE_EXP_SIGN,<br>        STATE_EXP_NUMBER,<br>        STATE_END<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>        CHAR_NUMBER,<br>        CHAR_EXP,<br>        CHAR_POINT,<br>        CHAR_SIGN,<br>        CHAR_SPACE,<br>        CHAR_ILLEGAL<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21-、调整数组顺序使奇数位于偶数前面"><a href="#21-、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.、调整数组顺序使奇数位于偶数前面"></a>21.、调整数组顺序使奇数位于偶数前面</h3><ul><li>双指针方法：左右分别标记一个奇数指针和一个偶数指针，遇到对应数据的时候直接移动</li><li>原地移动方法：从左往右找到第一个奇数，然后从右往左找到第一个偶数，交换，重复<ul><li>实际上二者时间空间复杂度相同</li></ul></li><li>自己编写的单指针算法更快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里考虑实际上只使用一个指针应该也可以的吧</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是偶数</span><br>                nums[i] = nums[count];<br>                nums[count] = num;<br>                count--;<br>                i--;<span class="hljs-comment">//换过来的这个数也需要比较</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="22、链表中倒数第N个开始截取"><a href="#22、链表中倒数第N个开始截取" class="headerlink" title="22、链表中倒数第N个开始截取"></a>22、链表中倒数第N个开始截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针即可，这样不必遍历两次，前一个指针先快走N步</span><br> <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">faster</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slower</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            faster = faster.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (faster != <span class="hljs-literal">null</span>) &#123;<br>            faster = faster.next;<br>            slower = slower.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slower;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代方法：走一步编织一次</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next; <span class="hljs-comment">// 暂存后继节点 cur.next</span><br>            cur.next = pre;          <span class="hljs-comment">// 修改 next 引用指向</span><br>            pre = cur;               <span class="hljs-comment">// pre 暂存 cur</span><br>            cur = tmp;               <span class="hljs-comment">// cur 访问下一节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//递归方法（实际上由于递归的原因会导致消耗更多的空间复杂度）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(head, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// 调用递归并返回</span><br>    &#125;<br>    <span class="hljs-comment">//当前传入的这个cur实际上是递归返回后的尾节点（实际上是借助递归使用栈的特性）</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode cur, ListNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> recur(cur.next, cur);  <span class="hljs-comment">// 递归后继节点</span><br>        cur.next = pre;              <span class="hljs-comment">// 修改节点引用指向</span><br>        <span class="hljs-keyword">return</span> res;                  <span class="hljs-comment">// 返回反转链表的头节点</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="25、合并两个排序链表"><a href="#25、合并两个排序链表" class="headerlink" title="25、合并两个排序链表"></a>25、合并两个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单归并思路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prehead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> prehead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                prev.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            prev = prev.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br><br>        <span class="hljs-keyword">return</span> prehead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h3><p>判断一个小树是否为一个大树的子结构(简单递归分析)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">return</span> (A != <span class="hljs-literal">null</span> &amp;&amp; B != <span class="hljs-literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));<br>    &#125;<br>    <span class="hljs-comment">//判断子结构只能从具体两个结点开始</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-comment">//B是A的子结构的前提：B为空或者当前节点对应的结点至少要相同</span><br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h3><ul><li>这里的反转使用的还是原来的结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//将一棵二叉树转为其镜像后输出其根结点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//递归的终点</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//注意一下这两个操作的顺序（肯定要先让底下的结点反转后再自己反转）</span><br>        <span class="hljs-comment">//递归进行该操作</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> mirrorTree(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mirrorTree(root.right);<br>        <br>        <span class="hljs-comment">//实际翻转的操作</span><br>        root.left = right;<br>        root.right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h3><ul><li><strong>递归的本质是提前使用未来的数据</strong>，我不需要在意未来的数据是如何得到的，反正我就是知道，<strong>只需要考虑最最末的问题</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//需要两个参数所以需要重新写一个新的函数</span><br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//只要有一个为null就说明部队称</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前节点对称的前提是该节点是相等的，并且对应的子节点也是对称的</span><br>        <span class="hljs-keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h3><ul><li>模拟法：每当到需要拐弯的边界的时候顺时针转变方向，并且修改其对应的边界（实际上不需要使用完整大小的矩阵保留访问情况，只需要记录边界即可，即下面这种方法的优化方式）</li><li>按层遍历：根据四个坐标，一层层向里面遍历</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221231134617606.png" alt="image-20221231134617606"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> matrix.length, columns = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows * columns];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = columns - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-comment">//正常打印一行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> left; column &lt;= right; column++) &#123;<br>                order[index++] = matrix[top][column];<br>            &#125;<br>            <span class="hljs-comment">//正常打印一列</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> top + <span class="hljs-number">1</span>; row &lt;= bottom; row++) &#123;<br>                order[index++] = matrix[row][right];<br>            &#125;<br>            <span class="hljs-comment">//只要至少有两行并且至少有两列，就得继续打印</span><br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> right - <span class="hljs-number">1</span>; column &gt; left; column--) &#123;<br>                    order[index++] = matrix[bottom][column];<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> bottom; row &gt; top; row--) &#123;<br>                    order[index++] = matrix[row][left];<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a>30、包含min函数的栈</h3><ul><li>如果只是使用一个min值进行标注的话则无法应对多个相同最小值的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里的相当于存放两层栈，每次添加一个元素都比较当前的最小值放到minStack中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; xStack;<br>    Deque&lt;Integer&gt; minStack;<span class="hljs-comment">//维护的是当前栈中的最小值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack.push(Integer.MAX_VALUE);<span class="hljs-comment">//这里注意需要先加入一个最大值进行维护</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        xStack.push(x);<br>        minStack.push(Math.min(minStack.peek(), x));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        xStack.pop();<br>        minStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> xStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31、栈的弹入和弹出序列判断"><a href="#31、栈的弹入和弹出序列判断" class="headerlink" title="31、栈的弹入和弹出序列判断"></a>31、栈的弹入和弹出序列判断</h3><ul><li>实际上只是对于输入序列的一种模拟，存在一个监视器一直判断是否能够直接弹出栈顶元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pushed.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            stack.push(pushed[i]);<br>            <span class="hljs-comment">//若现在模拟栈中的元素正好是需要的元素，就把这个元素弹出并且检索下一个元素</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;<br>                stack.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-1、从上到下打印二叉树"><a href="#32-1、从上到下打印二叉树" class="headerlink" title="32.1、从上到下打印二叉树"></a>32.1、从上到下打印二叉树</h3><ul><li>实际上就是层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//使用队列进行排序，然后从左到右进行输出</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            ans.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++)<br>            res[i] = ans.get(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-2、从上到下打印二叉树"><a href="#32-2、从上到下打印二叉树" class="headerlink" title="32.2、从上到下打印二叉树"></a>32.2、从上到下打印二叉树</h3><ul><li>层序遍历的变种：需要按数组层数的不同一行行的输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">//通过下面这个循环每次循环开始时获取一次i的值来得到对应queue中的数据，实现按顺序输出</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-3、从上到下打印二叉树"><a href="#32-3、从上到下打印二叉树" class="headerlink" title="32.3、从上到下打印二叉树"></a>32.3、从上到下打印二叉树</h3><ul><li>层序遍历的变种：分层输出并且每层切换输出方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <br>                <span class="hljs-comment">//其实和原本题目只需要改变这一点逻辑，因为只需要在最最后面输出答案的时候倒着放就可以了</span><br>                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 -&gt; 队列头部</span><br>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 -&gt; 队列尾部</span><br>                <br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33、判断二叉搜索树的后序遍历序列（TODO）"><a href="#33、判断二叉搜索树的后序遍历序列（TODO）" class="headerlink" title="33、判断二叉搜索树的后序遍历序列（TODO）"></a>33、判断二叉搜索树的后序遍历序列（TODO）</h3><ul><li>注意这里只是给定了后序遍历序列而并未给定特定的二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归法求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(postorder[p] &lt; postorder[j]) p++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p;<br>        <span class="hljs-keyword">while</span>(postorder[p] &gt; postorder[j]) p++;<br>        <span class="hljs-keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="hljs-number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//迭代法求解待补充</span><br></code></pre></td></tr></table></figure><h3 id="34、二叉树中和为某一值的路径（TODO）"><a href="#34、二叉树中和为某一值的路径（TODO）" class="headerlink" title="34、二叉树中和为某一值的路径（TODO）"></a>34、二叉树中和为某一值的路径（TODO）</h3><ul><li>深度优先遍历简单应用（路径是指必须要达到叶子结点才行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-comment">//其实不用担心这个path的并发情况，因为这实际上是在一个线程中运行，没有并发问题</span><br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        dfs(root, target);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.offerLast(root.val);<br>        target -= root.val;<br>        <span class="hljs-comment">//只有当为叶子结点并且当前目标值为0时</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; target == <span class="hljs-number">0</span>) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(path));<br>        &#125;<br>        <span class="hljs-comment">//即使是多个递归实际上同一时间也只会找一条线路</span><br>        dfs(root.left, target);<br>        dfs(root.right, target);<br>        <span class="hljs-comment">//并且在深度优先遍历回溯的过程中会自然把path的末尾结点给删掉</span><br>        path.pollLast();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//广度优先遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();<br>    Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;TreeNode, TreeNode&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; queueNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Queue&lt;Integer&gt; queueSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        queueNode.offer(root);<br>        queueSum.offer(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (!queueNode.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queueNode.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> queueSum.poll() + node.val;<br><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (rec == target) &#123;<br>                    getPath(node);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    map.put(node.left, node);<br>                    queueNode.offer(node.left);<br>                    queueSum.offer(rec);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    map.put(node.right, node);<br>                    queueNode.offer(node.right);<br>                    queueSum.offer(rec);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            temp.add(node.val);<br>            node = map.get(node);<br>        &#125;<br>        Collections.reverse(temp);<br>        ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(temp));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h3><ul><li>链表结点不仅有next指针，还有一个random指针指向随机一个结点，要求进行深拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//回溯+hashmap</span><br><span class="hljs-comment">//之所以要使用一个hashmap进行缓存，是因为要保证当一个结点被当做next时，或者被当做random时保证这个结点要是唯一的</span><br><span class="hljs-comment">//由于需要额外的HashMap，所以空间复杂度为O(N)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Node, Node&gt; cachedNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Node, Node&gt;();<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果当前的hashmap没有缓存对应的结点</span><br>        <span class="hljs-keyword">if</span> (!cachedNode.containsKey(head)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">headNew</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(head.val);<br>            cachedNode.put(head, headNew);<br>            headNew.next = copyRandomList(head.next);<br>            headNew.random = copyRandomList(head.random);<br>        &#125;<br>        <span class="hljs-comment">//无论怎样最后都会返回这个节点对应的值相同的深拷贝结点</span><br>        <span class="hljs-keyword">return</span> cachedNode.get(head);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//迭代+结点划分</span><br><span class="hljs-comment">//由于不需要额外的hashmap，所以空间复杂度为O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//在每个原结点中间创建一个前位结点的深拷贝结点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next.next) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(node.val);<br>            nodeNew.next = node.next;<br>            node.next = nodeNew;<br>        &#125;<br>        <span class="hljs-comment">//再把深拷贝得到的结点的random都赋值为前位结点的random</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next.next) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> node.next;<br>            nodeNew.random = (node.random != <span class="hljs-literal">null</span>) ? node.random.next : <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//此时的headNew是第一个深拷贝结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">headNew</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next) &#123;<br>            <span class="hljs-comment">//将原来的链表复位</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> node.next;<br>            node.next = node.next.next;<br>            <span class="hljs-comment">//注意nodeNew.next为null的情况</span><br>            nodeNew.next = (nodeNew.next != <span class="hljs-literal">null</span>) ? nodeNew.next.next : <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> headNew;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="36、二叉搜索数转换成双向链表（TODO）"><a href="#36、二叉搜索数转换成双向链表（TODO）" class="headerlink" title="36、二叉搜索数转换成双向链表（TODO）"></a>36、二叉搜索数转换成双向链表（TODO）</h3><p>由于性质，二叉搜索树的中序遍历为 <strong>递增序列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Node head, pre;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dfs(root);<br><br>        pre.right = head;<br>        head.left =pre;<span class="hljs-comment">//进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的</span><br><br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br><br>        <span class="hljs-comment">//pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur,当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点</span><br>        <span class="hljs-keyword">if</span>(pre==<span class="hljs-literal">null</span>) head = cur;<br>        <span class="hljs-comment">//反之，pre!=null时，cur左侧存在节点pre，需要进行pre.right=cur的操作。</span><br>        <span class="hljs-keyword">else</span> pre.right = cur;<br>       <br>        cur.left = pre;<span class="hljs-comment">//pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的。</span><br><br>        pre = cur;<span class="hljs-comment">//pre指向当前的cur</span><br>        dfs(cur.right);<span class="hljs-comment">//全部迭代完成后，pre指向双向链表中的尾节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h3><ul><li>深度优先遍历：注意只根据先序遍历或者只根据后序遍历如果有null值的话是可以唯一确定一个二叉树的<ul><li>实际上本题就是通过带null结点的前序遍历，中序遍历，后序遍历（三者之一）得到唯一二叉树</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> rserialize(root, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        String[] dataArray = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        List&lt;String&gt; dataList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;(Arrays.asList(dataArray));<br>        <span class="hljs-keyword">return</span> rdeserialize(dataList);<br>    &#125;<br><br>    <span class="hljs-comment">//实际的编码函数</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">rserialize</span><span class="hljs-params">(TreeNode root, String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            str += <span class="hljs-string">&quot;None,&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//将str分解成前序遍历的结果</span><br>            str += str.valueOf(root.val) + <span class="hljs-string">&quot;,&quot;</span>;<br>            str = rserialize(root.left, str);<br>            str = rserialize(root.right, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>  <br>    <span class="hljs-comment">//实际的解码函数</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">rdeserialize</span><span class="hljs-params">(List&lt;String&gt; dataList)</span> &#123;<br>        <span class="hljs-comment">//如果当前首位结点为null</span><br>        <span class="hljs-keyword">if</span> (dataList.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;None&quot;</span>)) &#123;<br>            dataList.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>  <br>        <span class="hljs-comment">//当首位结点不为none时，由于是先序遍历，所以需要先把自己保存下来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.valueOf(dataList.get(<span class="hljs-number">0</span>)));<br>        dataList.remove(<span class="hljs-number">0</span>);<br>        root.left = rdeserialize(dataList);<br>        root.right = rdeserialize(dataList);<br>    <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="38、字符串排序（）TODO"><a href="#38、字符串排序（）TODO" class="headerlink" title="38、字符串排序（）TODO"></a>38、字符串排序（）TODO</h3><ul><li>给定字符串中涵盖的字母，输出所有可能的字符串(给定元素中可能有重复字母，但输出的时候不能有重复元素)</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230101105032350.png" alt="image-20230101105032350"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历+剪枝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[] c;<br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        <span class="hljs-comment">//c数组被赋值为给定字符串初始值</span><br>        c = s.toCharArray();<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[res.size()]);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x == c.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//字符数组是每一次的结果承载者</span><br>            res.add(String.valueOf(c));      <span class="hljs-comment">// 添加排列方案</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt; c.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(c[i])) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 重复，因此剪枝</span><br>            set.add(c[i]);<br>            swap(i, x);                      <span class="hljs-comment">// 交换，将 c[i] 固定在第 x 位</span><br>            dfs(x + <span class="hljs-number">1</span>);                      <span class="hljs-comment">// 开启固定第 x + 1 位字符</span><br>            swap(i, x);                      <span class="hljs-comment">// 恢复交换</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> c[a];<br>        c[a] = c[b];<br>        c[b] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="39、数组中超过数组长度一半的数字"><a href="#39、数组中超过数组长度一半的数字" class="headerlink" title="39、数组中超过数组长度一半的数字"></a>39、数组中超过数组长度一半的数字</h3><ul><li>具体多种解决方法<ul><li>使用hashmap存储对应的结点出现次数</li><li>对数组进行排序，排序后数组中的最中间的位置一定是数组的众数，即所求</li><li>空间复杂度为O(1)的算法,并且只需要遍历一次:Boyer-Moore 投票算法</li></ul></li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\微信图片_20230102144243.jpg" alt="微信图片_20230102144243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Boyer-Moore 投票算法（具体算法不用证明）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//初始情况</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            <span class="hljs-comment">//如果是当前候选数则count++，否则count--</span><br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="40、最小的k个数"><a href="#40、最小的k个数" class="headerlink" title="40、最小的k个数"></a>40、最小的k个数</h3><ul><li>思路总结<ul><li>简单方法：排序然后输出k个数</li><li>正常方法：使用最小堆，只维护k最小堆，保证空间复杂度为常数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 排除 0 的情况</span><br>            <span class="hljs-keyword">return</span> vec;<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer num1, Integer num2)</span> &#123;<br>                <span class="hljs-keyword">return</span> num2 - num1;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            queue.offer(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; arr.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (queue.peek() &gt; arr[i]) &#123;<br>                queue.poll();<br>                queue.offer(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            vec[i] = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h3><ul><li>使用两个堆，一个大顶堆一个小顶堆，分别进行存储，大顶堆存储小的，小顶堆存储大的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    Queue&lt;Integer&gt; A, B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 小顶堆，保存较大的一半</span><br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x)); <span class="hljs-comment">// 大顶堆，保存较小的一半</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//说明现在是奇数</span><br>        <span class="hljs-comment">//实际上这样操作就把中间那个元素一直推过来推过去</span><br>        <span class="hljs-keyword">if</span>(A.size() != B.size()) &#123;<br>            <span class="hljs-comment">//往A中添加了一个，然后又从A中弹一个给B，相当于只有B增加了</span><br>            A.add(num);<br>            B.add(A.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//说明现在是偶数</span><br>            <span class="hljs-comment">//往B中添加了一个，然后又从B中弹一个给A，相当于只有A增加了</span><br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//判断奇数偶数中位数计算</span><br>        <span class="hljs-keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102145540249.png" alt="image-20230102145540249"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划算法（手写数字流程加以理解）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//前一步只要不是负数我都加上</span><br>            nums[i] += Math.max(nums[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//res是上一步的最大值，num[i]是包含这一步的最大值</span><br>            res = Math.max(res, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43、求1～n这n个整数的十进制表示中1出现的次数"><a href="#43、求1～n这n个整数的十进制表示中1出现的次数" class="headerlink" title="43、求1～n这n个整数的十进制表示中1出现的次数"></a>43、求1～n这n个整数的十进制表示中1出现的次数</h3><ul><li>例如：输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次</li><li>数学推导：详见<a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/">面试题43. 1～n 整数中 1 出现的次数（清晰图解） - 1～n 整数中 1 出现的次数 - 力扣（LeetCode）</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>) res += high * digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>) res += high * digit + low + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> res += (high + <span class="hljs-number">1</span>) * digit;<br>            low += cur * digit;<br>            cur = high % <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="44、数学序列中某一位的数字"><a href="#44、数学序列中某一位的数字" class="headerlink" title="44、数学序列中某一位的数字"></a>44、数学序列中某一位的数字</h3><ul><li>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</li><li>经数学推导可以得到，个位数的长度为10，二位数的长度为90×2，三位数的长度为900×3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//注意这里的n是从0开始计数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; count) &#123; <span class="hljs-comment">// 1.</span><br>           <span class="hljs-comment">//这里并没有对其做累加操作，是将给定值和现有值做差</span><br>            n -= count;<br>            digit += <span class="hljs-number">1</span>;<br>            start *= <span class="hljs-number">10</span>;<br>            count = digit * start * <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> start + (n - <span class="hljs-number">1</span>) / digit; <span class="hljs-comment">// 2.</span><br>        <span class="hljs-keyword">return</span> Long.toString(num).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 3.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="45、把数组排成最小的数"><a href="#45、把数组排成最小的数" class="headerlink" title="45、把数组排成最小的数"></a>45、把数组排成最小的数</h3><ul><li>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</li><li>实际上就是一个对给定排序规则然后对数据进行排序的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//题目限定是非负整数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            strings[i] = String.valueOf(nums[i]);<br>        &#125;<br>    <span class="hljs-comment">//注意这里一定要重新更改排序法则，直接使用字典序排序是不合理的</span><br>        Arrays.sort(strings, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> (o1 + o2).compareTo(o2 + o1);<span class="hljs-comment">//简单比较两个字符串前后的大小</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            stringBuilder.append(strings[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="46、数字翻译为字符串"><a href="#46、数字翻译为字符串" class="headerlink" title="46、数字翻译为字符串"></a>46、数字翻译为字符串</h3><ul><li>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法</li><li>复杂版青蛙跳而已</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103181538332.png" alt="image-20230103181538332"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//y是移除最后一位，而x没有进行赋初值操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, x, y = num % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//注意这里num先除了个，所以这里的x是倒数第二位数</span><br>            num /= <span class="hljs-number">10</span>;<br>            x = num % <span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * x + y;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (tmp &gt;= <span class="hljs-number">10</span> &amp;&amp; tmp &lt;= <span class="hljs-number">25</span>) ? a + b : a;<br>            <span class="hljs-comment">//b是不带新数的情况</span><br>            b = a;<br>            <span class="hljs-comment">//a是带新数的情况</span><br>            a = c;<br>            y = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="47、礼物的最大价值"><a href="#47、礼物的最大价值" class="headerlink" title="47、礼物的最大价值"></a>47、礼物的最大价值</h3><ul><li>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102152018242.png" alt="image-20230102152018242"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划转移方程的基本使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) grid[i][j] += grid[i][j - <span class="hljs-number">1</span>] ;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) grid[i][j] += grid[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="hljs-number">1</span>], grid[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="48、最长不含重复字符的子字符串"><a href="#48、最长不含重复字符的子字符串" class="headerlink" title="48、最长不含重复字符的子字符串"></a>48、最长不含重复字符的子字符串</h3><ul><li>自己很简单想到的思路：使用hashmap判断有无重叠，使用hashmap维护对应字符最后出现的下标，并且更新当前滑动数组的左边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span>(dic.containsKey(s.charAt(j)))<br>                i = Math.max(i, dic.get(s.charAt(j))); <span class="hljs-comment">// 更新左指针 i</span><br>            dic.put(s.charAt(j), j); <span class="hljs-comment">// 哈希表记录</span><br>            res = Math.max(res, j - i); <span class="hljs-comment">// 更新结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="49、丑数"><a href="#49、丑数" class="headerlink" title="49、丑数"></a>49、丑数</h3><ul><li>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103115942773.png" alt="image-20230103115942773"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据丑数的性质进行判断</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<br>            <span class="hljs-comment">//三个数之间求最小值</span><br>            dp[i] = Math.min(Math.min(n2, n3), n5);<br>            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;<br>            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;<br>            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="50、第一个只出现一次的字符"><a href="#50、第一个只出现一次的字符" class="headerlink" title="50、第一个只出现一次的字符"></a>50、第一个只出现一次的字符</h3><ul><li>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单hashmap应用，使用LinkedHashMap的原因是有序哈希表中的键值对是 按照插入顺序排序 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 11 的字符”。哈希表是 去重 的，即哈希表中键值对数量 \leq≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] sc = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : sc)<br>            dic.put(c, !dic.containsKey(c));<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;<br>           <span class="hljs-keyword">if</span>(d.getValue()) <span class="hljs-keyword">return</span> d.getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="51、数组中的逆序对"><a href="#51、数组中的逆序对" class="headerlink" title="51、数组中的逆序对"></a>51、数组中的逆序对</h3><ul><li>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103210011592.png" alt="image-20230103210011592"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>        merge(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            merge(nums, left, mid);<br>            merge(nums, mid + <span class="hljs-number">1</span>, right);<br>            mergeSort(nums, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] temparr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> left, temp2 = mid + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid &amp;&amp; temp2 &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[temp1] &lt;= nums[temp2]) &#123;<br>                temparr[index++] = nums[temp1++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//用来统计逆序对的个数</span><br>                count += (mid - temp1 + <span class="hljs-number">1</span>);<br>                temparr[index++] = nums[temp2++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把左边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid) &#123;<br>            temparr[index++] = nums[temp1++];<br>        &#125;<br>        <span class="hljs-comment">//把右边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp2 &lt;= right) &#123;<br>            temparr[index++] = nums[temp2++];<br>        &#125;<br>        <span class="hljs-comment">//把新数组中的数覆盖nums数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; temparr.length; k++) &#123;<br>            nums[k + left] = temparr[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="52、两个链表的第一个公共结点"><a href="#52、两个链表的第一个公共结点" class="headerlink" title="52、两个链表的第一个公共结点"></a>52、两个链表的第一个公共结点</h3><ul><li>双指针法：实际上移动的过程就相当于补全两者的距离，时间复杂度为O（M+N）</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102165500571.png" alt="image-20230102165500571"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53、统计在排序数组中特定数字出现的次数"><a href="#53、统计在排序数组中特定数字出现的次数" class="headerlink" title="53、统计在排序数组中特定数字出现的次数"></a>53、统计在排序数组中特定数字出现的次数</h3><ul><li>简单二分法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> rightIdx - leftIdx + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> lower)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>, ans = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-2、缺失的数字"><a href="#53-2、缺失的数字" class="headerlink" title="53.2、缺失的数字"></a>53.2、缺失的数字</h3><ul><li>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单二分遍历（数字和下标应该正好对应，如果不对应则说明在左边）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="54、二叉树的第K大结点"><a href="#54、二叉树的第K大结点" class="headerlink" title="54、二叉树的第K大结点"></a>54、二叉树的第K大结点</h3><ul><li>中序遍历然后的第K即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//中序遍历,正序赋值数组</span><br>        inOrder(root);<br>        <span class="hljs-comment">//寻找第k大的数，输出</span><br>        <span class="hljs-keyword">return</span> arr.get(arr.size()-k);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrder(root.left);<br>        arr.add(root.val);<br>        inOrder(root.right);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="55、二叉树的深度"><a href="#55、二叉树的深度" class="headerlink" title="55、二叉树的深度"></a>55、二叉树的深度</h3><ul><li>深度优先算法和广度优先算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//BFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) tmp.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) tmp.add(node.right);<br>            &#125;<br>            queue = tmp;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="55-2、判断平衡二叉树"><a href="#55-2、判断平衡二叉树" class="headerlink" title="55.2、判断平衡二叉树"></a>55.2、判断平衡二叉树</h3><ul><li>注意只是平衡二叉树而不是二叉搜索树，左右不一定有序</li><li>平衡二叉树定义：如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树</li><li>判断依据： <strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1</li><li>注意通过绘图来理解算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> recur(root.left);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> recur(root.right);<br>        <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//只要有一个子结构返回  -1 整体就能判断二叉树不平衡</span><br>        <span class="hljs-comment">//如果左右只要相差不违规就正常返回</span><br>        <span class="hljs-keyword">return</span> Math.abs(left - right) &lt; <span class="hljs-number">2</span> ? Math.max(left, right) + <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-1、数组中数字出现的次数"><a href="#56-1、数组中数字出现的次数" class="headerlink" title="56.1、数组中数字出现的次数"></a>56.1、数组中数字出现的次数</h3><ul><li>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序<strong>找出这两个只出现一次的数字</strong>。要求时间复杂度是O(n)，空间复杂度是O(1)。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102172743293.png" alt="image-20230102172743293"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//利用异或性质（相同的数异或为0）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)               <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) == <span class="hljs-number">0</span>)               <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums) &#123;              <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>((num &amp; m) != <span class="hljs-number">0</span>) x ^= num;  <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;                <span class="hljs-comment">// 4. 当 num &amp; m == 0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;x, y&#125;;          <span class="hljs-comment">// 5. 返回出现一次的数字</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-2、数组中数字出现的次数"><a href="#56-2、数组中数字出现的次数" class="headerlink" title="56.2、数组中数字出现的次数"></a>56.2、数组中数字出现的次数</h3><ul><li>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</li><li>只需要统计所有位的出现次数然后求余即可</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103164448982.png" alt="image-20230103164448982"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//java中的int占据4个字节</span><br>        <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//注意常数次的位运算操作的时间复杂度为O(1)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>                counts[j] += num &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//  &gt;&gt; 表示右移，如果该数为正，则高位补0，若为负数，则高位补1</span><br>                <span class="hljs-comment">//  &gt;&gt;&gt;  运算符所作的是无符号的位移处理，它不会将所处理的值的最高位视为正负符号，</span><br>                <span class="hljs-comment">//所以作位移处理时，会直接在空出的高位填入0</span><br>                num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            res &lt;&lt;= <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//左移后补0，所以只要count中的该位置为1，即为1</span><br>            res |= counts[<span class="hljs-number">31</span> - i] % m;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="57-1、和为s的两个数"><a href="#57-1、和为s的两个数" class="headerlink" title="57.1、和为s的两个数"></a>57.1、和为s的两个数</h3><ul><li>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针法（简单推导可知，该种情况不会漏过解）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span>(s &lt; target) i++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; target) j--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums[i], nums[j] &#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="57-2、和为s的连续正数序列"><a href="#57-2、和为s的连续正数序列" class="headerlink" title="57.2、和为s的连续正数序列"></a>57.2、和为s的连续正数序列</h3><ul><li>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102190117234.png" alt="image-20230102190117234"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//滑动窗口（实际上应该是通过列式子计算效率更高，但是滑动窗口更合适作为通解）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>, s = <span class="hljs-number">3</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span>(s == target) &#123;<br>                <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[j - i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++)<br>                    ans[k - i] = k;<br>                res.add(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= target) &#123;<br>                s -= i;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>                s += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="58、翻转单词顺序"><a href="#58、翻转单词顺序" class="headerlink" title="58、翻转单词顺序"></a>58、翻转单词顺序</h3><ul><li>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”</li><li>切割+倒序输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针法：适用于不能使用spilt的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, i = j;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//倒序剪切</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 搜索首个空格</span><br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 添加单词</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span><br>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//适用于不能使用split的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        String[] strs = s.trim().split(<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 删除首尾空格，分割字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒序遍历单词列表</span><br>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 遇到空单词则跳过</span><br>            res.append(strs[i] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 将单词拼接至 StringBuilder</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串，删除尾部空格，并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="58-2、左旋转字符串"><a href="#58-2、左旋转字符串" class="headerlink" title="58.2、左旋转字符串"></a>58.2、左旋转字符串</h3><ul><li>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适用于能使用字符串函数的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//简单拼接</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//注意这里如果要求不允许使用StringBuilder，使用string会导致每次字符串拼接都需要创建一个新的字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; n + s.length(); i++)<br>            res.append(s.charAt(i % s.length()));<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）"><a href="#59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）" class="headerlink" title="59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）"></a>59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）</h3><ul><li><strong>本题难点：</strong> 滑动窗口的长度是固定值，如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k） 降低至 O(1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当然可以直接使用优先队列，但是优先队列会导致一定开销</span><br><span class="hljs-comment">//这里使用单调队列进行实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//注意这里使用LinkedList实现</span><br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//需要输出的结果值</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//注意i的初始值为负数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span> - k; j &lt; nums.length; i++, j++) &#123;<br>            <span class="hljs-comment">// 删除 deque 中对应的 nums[i-1]（只有i&gt;0的情况下才能说明滑动窗口已经撑满了）</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>])<br>                deque.removeFirst();<br>            <br>            <span class="hljs-comment">// 保持 deque 递减</span><br>            <span class="hljs-comment">//注意是倒着去除最小值</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])<br>                deque.removeLast();<br>            deque.addLast(nums[j]);<br>            <br>            <span class="hljs-comment">// 记录窗口最大值（只有i&gt;0的情况下才能说明滑动窗口已经撑满了）</span><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)<br>                res[i] = deque.peekFirst();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59-2、队列当中的最大值"><a href="#59-2、队列当中的最大值" class="headerlink" title="59.2、队列当中的最大值"></a>59.2、队列当中的最大值</h3><ul><li>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//和上一题一样，关键在于如何保证获取队列中的最大值的函数是常数级别的</span><br><span class="hljs-comment">//使用单调双端队列来完成</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    Queue&lt;Integer&gt; queue;<br>    Deque&lt;Integer&gt; deque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//存储单调队列</span><br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> : deque.peekFirst();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        queue.offer(value);<br>        <span class="hljs-comment">//保持单调队列中的递减，将单调队列中所有小于当前值的都弹出</span><br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)<br>            deque.pollLast();<br>        deque.offerLast(value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(queue.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里很巧妙的一点是没有进行循环判断，而是只对队列中第一个元素判断</span><br>        <span class="hljs-comment">//因为两个队列实际上是相对有序的，弹出的这个元素只有可能是最大值或者是已经在单调队列中抛弃的值</span><br>        <span class="hljs-comment">//不可能是次大值，因为单调队列中是相对有序的，次大值一定要在最大值出现后才能出现</span><br>        <span class="hljs-keyword">if</span>(queue.peek().equals(deque.peekFirst()))<br>            deque.pollFirst();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="60、n个骰子对应点数和的概率"><a href="#60、n个骰子对应点数和的概率" class="headerlink" title="60、n个骰子对应点数和的概率"></a>60、n个骰子对应点数和的概率</h3><ul><li>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</li><li>首先如果考虑暴力求解由于每个骰子都有6种情况，所以结果是指数级的，时间复杂度过高</li><li>所以应该寻找规律通过递推法实现</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102195623876.png" alt="image-20230102195623876"></p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102195600889.png" alt="image-20230102195600889"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] dicesProbability(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-comment">//初始值都是六分之一</span><br>        Arrays.fill(dp, <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">//这里的个数是由于i个骰子，最低即为i    （6 * i - i + 1 = 5 * i + 1）</span><br>            <span class="hljs-type">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; dp.length; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++) &#123;<br>                    tmp[j + k] += dp[j] / <span class="hljs-number">6.0</span>;<br>                &#125;<br>            &#125;<br>            dp = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="61、扑克牌中的顺子"><a href="#61、扑克牌中的顺子" class="headerlink" title="61、扑克牌中的顺子"></a>61、扑克牌中的顺子</h3><ul><li>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0(输入的就是0) ，可以看成任意数字。注意A是1而不是14（输入的就是1）</li><li>实际上就是输出0-13中的任意五个数，其中0可以被替代成任何数，判断这五个数是否连续</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">joker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当这个数组最好是有序，而给定数组不是有序的时候可以先进行数组排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++; <span class="hljs-comment">// 统计大小王数量</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若有重复，提前返回 false</span><br>        &#125;<br>        <span class="hljs-comment">//因为排序过了，所以判断顺子很简单，只需要看差值就可以</span><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="62、圆圈中最后剩下的数字"><a href="#62、圆圈中最后剩下的数字" class="headerlink" title="62、圆圈中最后剩下的数字"></a>62、圆圈中最后剩下的数字</h3><ul><li>经典约瑟夫环问题</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102202109635.png" alt="image-20230102202109635"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            x = (x + m) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="63、股票的最大利润"><a href="#63、股票的最大利润" class="headerlink" title="63、股票的最大利润"></a>63、股票的最大利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-comment">//cost是遍历到price时能够使用的最小金额</span><br>            cost = Math.min(cost, price);<br>            <span class="hljs-comment">//profit是遍历到price之前的最大利润</span><br>            profit = Math.max(profit, price - cost);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="64、计算1到n的和"><a href="#64、计算1到n的和" class="headerlink" title="64、计算1到n的和"></a>64、计算1到n的和</h3><ul><li>傻篮子题目，不让用乘除还不让用判断，结果最优解使用位运算模拟乘除</li></ul><h3 id="65、位运算实现加法"><a href="#65、位运算实现加法" class="headerlink" title="65、位运算实现加法"></a>65、位运算实现加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>            a = a ^ b;<br>            b = carry;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="66、构建乘积数组"><a href="#66、构建乘积数组" class="headerlink" title="66、构建乘积数组"></a>66、构建乘积数组</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102204013728.png" alt="image-20230102204013728"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算对应i位不算入乘法的乘积结果</span><br><span class="hljs-comment">//实际上本题是一个动态规划问题，在于如何最大化利用中间结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//先算左边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//后算右边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= a[i + <span class="hljs-number">1</span>];<br>            b[i] *= tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="67、把字符串转化成整数"><a href="#67、把字符串转化成整数" class="headerlink" title="67、把字符串转化成整数"></a>67、把字符串转化成整数</h3><ul><li>思路：去掉字符串开头的空格，判断负数正数，然后使用temp作为中介，循环读取并扩大10倍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strToInt</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">char</span>[] c = str.trim().toCharArray();<br>        <span class="hljs-keyword">if</span>(c.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) sign = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>) i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; c.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(c[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>) <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>            res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign * res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="68-1、二叉搜索树的最近公共祖先"><a href="#68-1、二叉搜索树的最近公共祖先" class="headerlink" title="68.1、二叉搜索树的最近公共祖先"></a>68.1、二叉搜索树的最近公共祖先</h3><ul><li>根据二叉树的性质实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//如果两个结点一左一右，那么当前节点就一定是其最近公共祖先（注意如果其中一个结点已经是当前root了，那么也直接返回）</span><br>            <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="hljs-comment">// p,q 都在 root 的右子树中</span><br>                root = root.right; <span class="hljs-comment">// 遍历至右子节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="hljs-comment">// p,q 都在 root 的左子树中</span><br>                root = root.left; <span class="hljs-comment">// 遍历至左子节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="68-2、普通二叉树的最近公共祖先"><a href="#68-2、普通二叉树的最近公共祖先" class="headerlink" title="68.2、普通二叉树的最近公共祖先"></a>68.2、普通二叉树的最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">//如果其中一个结点已经是当前root了，那么直接返回</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-comment">//如果能走到注释这一步，就说明左右都有数据返回，说明当前节点就是最近公共祖先</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题相关总结"><a href="#面试题相关总结" class="headerlink" title="面试题相关总结"></a>面试题相关总结</h1><h2 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h2><h3 id="java基础知识相关"><a href="#java基础知识相关" class="headerlink" title="java基础知识相关"></a>java基础知识相关</h3><ul><li><p>java和c++对比</p></li><li><p><strong>java和go对比</strong></p><ul><li><a href="https://blog.csdn.net/weixin_70730532/article/details/126405302">(51条消息) Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)_go java_Java烟雨的博客-CSDN博客</a></li><li>性能：这个是java和go之间对比必须聊到的一个话题，性能一直是java开发经常吐槽的地方。在串行的业务下，java的性能就比Go差，并发业务下，java更比go差远了。这个可能Go比较偏向于C，C++的缘故吧，go的性能可以媲美c，c++。</li><li>多线程：Go就是为多线程而生的，语法直接支持多线程，使用go语法即可使用多线程。在多线程逻辑实现方面Go也比java更清晰，更简单，这个就是后发语言的优势了，不知道kotlin能不够弥补这个缺点。在性能方面，Go多线程也是碾压java，Go协程相对于传统操作系统中的线程 (thread) 是非常轻量级的，所以Go在多线程方面是比java又快内存占用又小。</li><li>生态：这个是java的最大优势，现在go还处于发展阶段，每个新版本出来大家都要抢着升级，因为新功能太重要了，不用不行。就比如包管理功能，从go vendor到go module，都没有java maven强大，但是都不得不用。java新版本出来了，可能不见得会去升级，好多公司现在还在用jdk1.6，因为该有的功能java都已经有了，没必要再去赶潮流。还有java的spring全家桶，虽然go没有spring，不过好在go的web模块功能也还比较强大，虽然没有spring系列方便，但是也足够使用了。</li><li>编译，部署：这个对于java来说可能是最轻松的事了吧，在之前的互联网公司的时候，从来没有碰到过部署方面难题，更不用说编译了，本地编译ok，服务器一定更加ok，然后部署放到类似于阿里云这类的云容器上面，一键上线轻轻松松。但是go就不一样了，编译go如同编译C++一样，不同操作系统需要交叉编译，由于依赖服务器的一些环境，所以本地还运行不了Go程序，没办法本地debug，部署更是如同打仗一般，需要写很多python脚本来将编译构建之后部署至docker,k8s上</li></ul></li><li><p>Java的跨平台的机制是什么？</p><ul><li>java代码得到的class文件相同，不同平台使用各自对应的jvm进行解读class文件</li></ul></li><li><p>String类型不可修改，为什么呢？</p><ul><li>底层实现逻辑：在jdk8时底层为char[]，在jdk9的时候底层为byte[]</li><li>数组长度一旦声明则不可改变，字符串一旦声明则不可改变，改变的只是引用内存指向</li><li>不可修改的意义：<ul><li>方便实现字符串对象池，如果String可变，那么对象池就需要考虑何时深浅拷贝字符串的问题了</li><li>更方便缓存hashCode ，作为key时可以更高效的保存到hashmap中</li><li>线程安全，就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141317504.png" alt="856b9a63a67a4475ae85f87499dd1aa9"></li></ul></li><li><p>字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？  非要改String类型，能改的到吗？  new一个String对象，是放在哪里的？ TODO</p></li><li><p>StringBuilder和StringBuffer有什么区别</p><ul><li><p>最简单的解释：Buffer是线程安全的，Builder是线程不安全的</p></li><li><p>二者的相同点</p><ul><li>都继承AbstractStringBuilder这个抽象类，实现了CharSequence接口</li><li>其append方法都是调用了父类AbstractStringBuilder的append(String str)方法</li><li>初始容量都是16并且扩容机制也是相同的（”旧容量*2+2”）</li><li>底层都是用char[]字符数组实现，且字符数组都是可变的</li></ul></li><li><p>二者的不同点</p><ul><li><p>Buffer是线程安全的，Builder是线程不安全的</p></li><li><p>StringBuffer从JDK1.0就有了，StringBuilder是JDK5.0才出现</p></li><li><p>StringBuffer比StringBuilder多了一个toStringCache字段，用来在toString方法中进行缓存，每次append操作之前都先把toStringCache设置为null，若多次连续调用toString方法，可避免每次Arrays.copyOfRange(value, 0, count)操作，节省性能</p></li><li><p>由于StringBuilder没有考虑同步，在单线程情况下，StringBuilder的性能要优于StringBuffer</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>       toStringCache = <span class="hljs-literal">null</span>;<br>       <span class="hljs-built_in">super</span>.append(str);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>           toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p>反射机制有了解吗？反射创建对象和new创建对象有什么区别？  反射和new的性能哪个更高一点？</p></li><li><p>设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）</p></li><li><p>hashmap的底层结构</p></li><li><p>字符串相关</p><ul><li><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</li><li>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化</li><li>字符串常量池的实现是基于一个hashMap实现的，其长度有个常量值（可以通过参数修改<code>-XX:StringTableSize=99991</code>）如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降（因为要一个一个找）<ul><li>StringTableSize含义：Number of buckets in the interned String table<br>String.intern()被调用时会往Hashtable插入一个String（若该String不存在），这里的Table就是StringTable，此参数就是这个StringTable的大小<br>若此参数设置过小，明显的问题就是过多的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>碰撞，造成在查找字符串时比较消耗CPU资源<br>JDK1.6起，当冲突次数超过100次会自动rehash，即便如此，若此参数设置过小会导致不断的rehash，依然会过度消耗CPU资源，建议将此参数设置的值稍大一些，以减少hash冲突</li></ul></li></ul></li><li><p>HashMap</p><ul><li>HashMap的put操作的流程</li></ul></li><li><p>HashMap扩容流程</p><ul><li><a href="https://zhuanlan.zhihu.com/p/258347168">从基础到实践，一文带你看懂HashMap - 知乎 (zhihu.com)</a></li></ul></li><li><p>TreeMap和HashMap的区别</p><ul><li><a href="https://blog.csdn.net/dghehe/article/details/125474352">(51条消息) TreeMap和HashMap的区别_东莞呵呵的博客-CSDN博客_treemap和hashmap区别</a></li></ul></li><li><p>java集合（存储结构、使用场景、和List的区别，线程安全的Map）</p></li><li><p>讲讲创建线程的方式</p><ul><li><a href="https://blog.csdn.net/clear_0217/article/details/122736610">线程的创建方式_clear0217的博客-CSDN博客_线程的创建方式</a></li></ul></li><li><p>runnable接口和callable接口除了区别</p><ul><li>Callable规定的方法是call(),Runnable规定的方法是run().</li><li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值得</li><li>call方法可以抛出异常，run方法不可以</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li></ul></li><li><p>FutureTask的方法（只知道get）</p></li><li><p>浅拷贝和深拷贝</p><ul><li>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li><li>浅拷贝：变量保存的不是对象本身,是指向对象的地址，此时改变对象本身的内容,其他变量显示内容也会改变；如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li><li>浅拷贝两者指向同一元素，深拷贝两者互不影响</li></ul></li><li><p>异常类</p></li><li><p>try catch finally执行顺序</p></li><li><p>synchronized关键字、锁升级</p></li><li><p>面向对象SOLID原则：单一功能，开闭，里氏替换、接口隔离、依赖反转</p><ul><li><a href="https://blog.csdn.net/LiJiVV/article/details/112004467">(51条消息) 面向对象设计原则（SOLID）_蝎子莱布莱的博客-CSDN博客_面向对象设计的solid原则</a></li></ul></li><li><p>对于hash冲突，有什么解决办法吗？</p></li><li><p>怎么设计一个hash函数？（直接按照HashMap的hash思想说了一遍）</p></li><li><p>TreeMap和HashMap的查询效率分别是什么情况？</p><ul><li>[<a href="https://www.bbsmax.com/A/QW5YwyANzm/">Java] 多个Map的性能比较（TreeMap、HashMap、ConcurrentSkipListMap） (bbsmax.com)</a></li></ul></li><li><p>jdk19相关</p></li><li><p>常用在java集合类中的fastfail机制</p><ul><li><a href="https://blog.csdn.net/xiaoyuan_27/article/details/122077946">(49条消息) fail-fast 快速失败机制_Z_sh的博客-CSDN博客_快速失败机制</a></li></ul></li><li><p>java初始化原则：</p><ul><li><p>①静态对象（变量）优先于非静态对象（变量）初始化；</p><p>②父类优先于子类进行初始化；</p><p>③按照成员变量的定义顺序进行初始化；</p></li></ul></li></ul><h3 id="jvm相关"><a href="#jvm相关" class="headerlink" title="jvm相关"></a>jvm相关</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184312672.png" alt="image-20221120141317504"></p><ul><li><p>JVM内存是怎么管理的？</p></li><li><p>jvm调优常用参数</p></li><li><p>GC一般在什么时候触发？</p><ul><li><p>MinorGC触发</p><ul><li><p><strong>Allocation Failure：</strong> 分配对象失败，空间不足.</p></li><li><p><strong>Survivor 区满了</strong>，需要拷贝</p></li></ul></li><li><p>FullGC触发</p><ul><li><p><strong><code>System.gc()</code>被调用</strong>并且没有指定关闭显示GC，就是没有指定-XX:+DisableExplicitGC这个JVM flag</p></li><li><p><strong>老年代也满了</strong></p></li><li><p><strong>堆外内存满了</strong>，例如metaspace，代码即时编译缓存，直接内存，mmap内存</p></li><li><p><strong>gc 担保失败</strong>，请参考：-XX:-HandlePromotionFailure</p></li></ul></li></ul></li><li><p>调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？如果不是，是什么机制来保障的（finalize）（是想要回答二次标记问题）</p><ul><li>其实基本没什么机会用得到这个命令System.gc(), 因为这个命令只是建议JVM安排GC运行, 还有可能完全被拒绝。 GC本身是会周期性的自动运行的,由JVM决定运行的时机,而且现在的版本有多种更智能的模式可以选择,还会根据运行的机器自动去做选择,就算真的有性能上的需求,也应该去对GC的运行机制进行微调,而不是通过使用这个命令来实现性能的优化</li><li>频繁GC会导致服务器的资源被消耗殆尽程序卡顿，根据不同的垃圾收集器会造成不同的STW时间</li><li>Java语言规范并不保证finalize方法会被及时地执行，因为JVM通常在单独的低优先级线程中完成finalize的执行，而且根本不会保证它们会被执行</li><li>继承自object的finalize()它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以建议完全可以忘掉Java语言里面的这个方法</li></ul></li><li><p>高并发下的内存管理（海量并发线程创建了许多对象导致无法处理）</p><ul><li>优化代码中的处理请求的业务逻辑，尽 量少创建一次性对象，特别是内存占用大的对象。比如让 Request 对象在业务流程中一直传递下去，而不是每执行一个步骤，就创建一个内存和 Request 相似的新对象。</li><li>对于需要频繁的使用，或者占用内存较大的对象，可以考虑自行回收并重用这些对象。可以为这些对象加了一个对象池，收到请求后，在对象池内申请一个对象，使用完放回对象池。反复使用，避免频繁触发垃圾回收。</li></ul></li><li><p>Java有了GC之后还会有内存泄漏问题吗？</p><ul><li>静态集合类泄漏</li><li>单例对象由于持有对外部的引用而造成泄漏</li><li>连接：数据库网络IO等连接没有显示调用close关闭</li><li>监听器：在释放对象的时候没有删除对应监听器（实际上应该是所有的发布订阅模型都会存在这个问题）<ul><li>可以使用弱引用（其他引用使用同理）来不太好的解决这种问题 WeakReference<String> weakReference &#x3D; new WeakReference&lt;&gt;(str1); </li><li>同样对于比较重要或者比较限制的资源需要及时的释放资源来保证运行</li></ul></li></ul></li><li><p>0哪些可以作为GC Roots？</p><ul><li><p>总结：GC Roots即运行过程中必不可少的部分</p><ul><li><strong>本地变量表，静态变量，常量，本地方法（引用的对象），jvm内部对象，同步锁的对象，反应jvm内部的对象</strong></li></ul></li><li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p></li><li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</p></li><li><p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</p></li><li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</p></li><li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li></ul></li><li><p>jvm内存模型</p><ul><li>详见jvm笔记</li></ul></li><li><p>方法区，元空间，永久代辨析</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184550382.png" alt="image-20221126184312672"></li><li>方法区是抽象概念，而元空间和永久代是在不同版本时对于方法区的实现</li></ul></li><li><p>元空间</p><ul><li><p>使用本地内存存储元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题 </p></li><li><p>回收元空间的时机分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。</p></li></ul></li><li><p>哪些地方会发生内存溢出（除了PC其他都会溢出）</p><ul><li><p>1、方法区溢出</p><p>第一种原因：上线的时候MetaSpace区域直接用默认的参数，即根本不设置其大小，这会导Meta</p><p>Space区域可能才几十M而已或者设置的比较小，此时对于一个稍微大型系统，因为他有很多自己的类，还依赖了很多外部jar包的类，MetaSpace空间很容易不够的。</p><p>第二种原因：就是很多人开发系统代码都会用一些cglib之类的技术动态生成一些类，一旦代码没有控制好，导致生成的类过多的时候，就很容易MetaSpace给塞满，进而引起内存溢出。</p><p>2、虚拟机栈&#x2F;本地方法栈溢出<br>（1）StackOverflowError：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常。最常见的场景就是方法无限递归调用。<br>（2）OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError。<br>虚拟机中可以供栈占用的空间≈可用物理内存 - 最大堆内存 - 最大方法区内存，比如一台机器内存为 4G，系统和其他应用占用 2G，虚拟机可用的物理内存为 2G，最大堆内存为 1G，最大方法区内存为 512M，那可供栈占有的内存大约就是 512M，假如我们设置每个线程栈的大小为 1M，那虚拟机中最多可以创建 512个线程，超过 512个线程再创建就没有空间可以给栈了，就报 OutOfMemoryError 异常了。</p><p>3、堆内存溢出<br>（1）内存中加载的数据过多如一次从<strong>数据库</strong>中取出过多数据；集合对对象引用过多且使用完后没有清空；代码中存在死循环或循环产生过多重复对象；堆内存分配不合理；网络连接问题、数据库问题等。<br>（2）系统承载高并发请求，因为请求量过大，导致大量的对象都是存活的，所以要放入新的对象放不下了，此时就会引起内存溢出系统崩溃；<br>（3）系统有泄漏的问题，就是莫名其妙产生了很多对象，结果对象都是存活的，没有及时取消他们的引用，导致触发GC还是无法回收，此时只能引发内存溢出，因为实在是放不下更多的对象了。</p><p>4、本机直接内存溢出<br>本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但 Java 中用到 NIO 相关操作时（比如 ByteBuffer 的 allocteDirect 方法申请的是本机直接内存），也可能会出现内存溢出的异常</p></li></ul></li><li><p>string常量池在哪</p><ul><li>位于方法区中，根据java版本的不同，在java7之前存放在永久代中，在java7后将其移动到java堆中</li></ul></li><li><p>字面量和符号引用的区别</p><ul><li>符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够在使用的时候无歧义的定位到对应目标即可，例如在class文件中常以CONSTANT_Class_info等变量的形式出现</li><li>字面量就是对应赋值操作中的常量值，如”abc”,1等</li></ul></li><li><p>JVM广义上的常量池分类</p><ul><li><p>1.类文件常量池</p><pre><code class="hljs">     我们写的每一个Java类被编译后，就会形成一份class文件（每个class文件都有一个class常量池）。 class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)   字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;   符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。</code></pre><ol start="2"><li>运行时常量池</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">运行时常量池（Runtime <span class="hljs-keyword">Constant</span> Pool）是方法区的一部分。jdk1<span class="hljs-number">.8</span>以前存在于永久代，jdk1<span class="hljs-number">.8</span>之后存在于元空间。静态常量池中的内容，在类加载后会被存放到方法区的运行时常量池中。运行时常量池相对于<span class="hljs-keyword">Class</span>文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入<span class="hljs-keyword">Class</span>文件中静态常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。<br></code></pre></td></tr></table></figure><p>3.字符串常量池</p><pre><code class="hljs">    字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。字符串常量池的存在使JVM提高了性能和减少了内存开销。    字符串常量池可以理解为是分担了部分运行时常量池的工作。和其他的对象分配一样，字符串耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能，为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化，为字符串开辟一个字符串常量池，类似于缓存区。实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用。    加载时，对于class文件的静态常量池，字符串字面量会进入到当前类的运行时常量池，但不会立即进入全局的字符串常量池（即在字符串常量池中并没有相应的引用，在堆中也没有对应的对象产生），字符串常量池是lazy resolve的，在第一次引用该项的ldc指令被第一次执行到的时候才会resolve，但这个过程我们可以不关注。可以认为当类加载完成后，运行代码String str1=&quot;abc&quot;或String str2=new String(“abc”)时，字面量“abc”已经存在于字符串常量池。jdk7字符串常量池以后存在于堆中</code></pre></li></ul></li><li><p>JMM</p><ul><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/119212455">Java 内存模型(Java Memory Model)_hfnjfudnnr的博客-CSDN博客</a></li><li>定义：JMM 是Java内存模型（ Java Memory Model）。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范，是和多线程相关的一组规范。<strong>通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式</strong>方需要每个JVM 的实现都要遵守这样的规范，有了JMM规范的保障，并发程序运行在不同的虚拟机上时，得到的程序结果才是安全可靠可信赖的</li><li>详细定义见JVM书599</li></ul></li><li><p>GC日志（尝试阅读）（TODO 深入理解虚拟机4，5章）</p><ul><li><a href="https://zhuanlan.zhihu.com/p/267388951">JVM实战：GC日志解析 - 知乎 (zhihu.com)</a></li></ul></li><li><p>类加载相关：</p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183754754.png" alt="image-20221126185026711"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/856b9a63a67a4475ae85f87499dd1aa9.png" alt="image-20221126183754754"></p><ul><li><p>加载（loading）</p><ul><li>加载是读取class文件（网络，动态生成等），并将其转换为某种静态数据结构存储在<strong>方法区</strong>中，并在<strong>堆</strong>中生成一个便于用户调用的java.lang.Class类型对象的过程</li></ul></li><li><p>验证：</p><ul><li>进行文件格式验证，元数据，字节码验证，符号引用验证等（这些行为是在整个运行期间都存在的），保证安全性</li></ul></li><li><p>准备：</p><ul><li>进行相关赋值操作</li></ul></li><li><p>解析：</p><ul><li>将符号引用替换成直接引用</li><li>动态解析：如果引用的B类是一个接口，而其实现是C或者D，那么就将其暂且搁置，直到真正调用其实现类的时候，才将A的符号引用转变为对C和D的直接引用</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183648553.png" alt="image-20221126184550382"></p></li><li><p>初始化：</p><ul><li>判断代码中是否存在主动的类的资源初始化操作（不同于对象的初始化操作，对象的初始化只有在显式调用new时才会进行），如果有则进行执行</li></ul></li><li><p>使用</p></li><li><p>类卸载</p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221129145421079.png" alt="image-20221126185238672"></p></li><li><p>java代码执行流程</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185026711.png" alt="image-20221126183648553"></li></ul></li><li><p><strong>栈上替换，方法内联，代码缓存</strong></p><ul><li><a href="https://blog.csdn.net/justinzengTM/article/details/114255737">(49条消息) 栈上替换、方法内联和代码缓存_大力海棠的博客-CSDN博客_栈上替换</a></li></ul></li><li><p>对象头相关</p><ul><li><a href="https://juejin.cn/post/6844903832833490957">Java对象在内存的结构 - 掘金 (juejin.cn)</a></li></ul></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li><p>Redis和大型数据库有什么区别？</p><ul><li><a href="https://blog.csdn.net/agonie201218/article/details/123656539"> Redis的优势和特点</a></li></ul></li><li><p>Redis高效的原因</p><ul><li><a href="https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw">为什么单线程的 Redis 如何做到每秒数万 QPS ？ (qq.com)</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></li></ul></li><li><p>redis雪崩、穿透、击穿的原因和解决方案</p><ul><li>小林code</li></ul></li><li><p>redis的常见数据类型及应用场景</p><ul><li>小林code</li></ul></li><li><p>LPOP 和 BLPOP 的区别</p><ul><li>LPOP命令如果遇到列表中的数据为空时，则直接返回空值</li><li>BLPOP 命令可以弹出指定列表中的头部的元素，若所有的列表均不存在或者为空，则阻塞等待</li></ul></li><li><p>Redis 消息队列和 MQ 的区别</p><ul><li><p><strong>可靠消费</strong></p><ul><li>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理</li><li>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费</li></ul></li><li><p><strong>可靠发布</strong></p><ul><li><p>Reids：不提供，需自行实现，Redis的消息队列，如果在从队列pop出去的时候，worker处理失败的话，数据不会回到队列中，需要从业务中手动把失败的处理数据push到队列中；</p></li><li><p>RabbitMQ：具有发布确认功能，保证消息被发布到服务器RabbitMQ有一个消息确认机制来保证消息的不丢失：</p><ul><li>客户端从队列中取出消息之后，可能需要一段时间才能处理完成，如果在这个过程中，客户端出错了，异常退出了，而数据还没有处理完成，那么非常不幸，这段数据就丢失了，因为RabbitMQ默认会把此消息标记为已完成，然后从队列中移除。</li><li>消息确认是客户端从RabbitMQ中取出消息，并处理完成之后，会发送一个ack告诉RabbitMQ，消息处理完成，当RabbitMQ收到客户端的获取消息请求之后，或标记为处理中，当再次收到ack之后，才会标记为已完成，然后从队列中删除。当RabbitMQ检测到客户端和自己断开链接之后，还没收到ack，则会重新将消息放回消息队列，交给下一个客户端处理，保证消息不丢失，也就是说，RabbitMQ给了客户端足够长的时间来做数据处理。</li></ul></li></ul></li><li><p><strong>高可用</strong></p><ul><li>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案</li><li>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作</li></ul></li><li><p><strong>持久化</strong></p><ul><li>Redis：将整个Redis实例持久化到磁盘</li><li>RabbitMQ：队列，消息，都可以选择是否持久化</li></ul></li><li><p><strong>消费者负载均衡</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：根据消费者情况，进行消息的均衡分发</li></ul></li><li><p><strong>队列监控</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）</li></ul></li><li><p><strong>流量控制</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性</li></ul></li><li><p><strong>总结</strong></p><ul><li>redis： 轻量级，低延迟，高并发，低可靠性；</li><li>rabbitmq：重量级，高可靠，异步，不保证实时；</li><li><strong>rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。</strong></li></ul></li></ul></li><li><p>原生Redis分布式锁有什么问题，怎么解决（TODO 分布式锁的实现）</p></li><li><p>Redis持久化机制</p><ul><li>小林code</li></ul></li><li><p>Redis键过期策略</p><ul><li>小林code（Redis 过期删除策略和内存淘汰策略有什么区别？）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185238672.png" alt="image-20221129145421079"></p></li><li><p>Redis的数据一致性（主备复制）怎么做的？</p><ul><li>小林code</li></ul></li><li><p>（TODO 集群网课）项目是单机还是多机架构？你怎么认为Redis的集群模式？为什么要有集群？</p><ul><li>小林code</li></ul></li><li><p>initServer 启动服务，另外一个就是 aeMain 事件循环</p></li><li><p>SDS（简单动态字符串）</p></li><li><p><strong>quicklist</strong> </p></li><li><p>Redis缓存更新的策略（读写策略出现问题往往是A线程执行的操作把B线程包裹住了）</p><ul><li><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路 | 酷 壳 - CoolShell</a></li><li>小林code相关</li><li>一致性要求低时（一般不会单纯使用这种方式）：使用Redis自带的内存淘汰机制</li><li>一致性要求高时：主动更新，并采用超时剔除兜底方案<ul><li><p>读操作</p><ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库并写入缓存，并设置其超时时间</li></ul></li><li><p>写操作</p><ul><li><strong>先写入数据库然后再删除缓存</strong>（并不写入缓存，只是删除缓存）</li><li><strong>确保数据库和缓存操作的原子性</strong></li></ul></li></ul></li></ul></li><li><p><strong>IO多路复用总结：</strong>(epoll用于Redis，Nginx，JavaNIO（基于Linux）)</p><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/410316787">深入理解 Linux 的 epoll 机制及epoll原理 - 知乎 (zhihu.com)</a></p><ul><li><p>epoll_create：创建一个 epoll 对象</p></li><li><p>epoll_ctl：向 epoll 对象中添加要管理的连接</p></li><li><p>epoll_wait：等待其管理的连接上的 IO 事件</p></li></ul></li><li><p>Select</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141809023.png" alt="image-20221125161407202"></li></ul></li><li><p>Poll</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165519514.png" alt="image-20221125162139212"></li></ul></li><li><p>Epoll</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165600678.png" alt="image-20221125162858367"></li></ul></li><li><p>epool快速的关键</p><ul><li>内部管理 fd 使用了高效的红黑树结构管理，做到了增删改之后性能的优化和平衡；</li><li>epoll 池添加 fd 的时候，调用 file_operations-&gt;poll ，把这个 fd 就绪之后的回调路径安排好。通过事件通知的形式，做到最高效的运行；</li><li>epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；</li></ul></li><li><p>布隆过滤器</p><ul><li><a href="http://c.biancheng.net/redis/bloom-filter.html">Redis布隆过滤器（原理+图解） (biancheng.net)</a></li><li><a href="https://www.bilibili.com/video/BV1zK4y1h7pA/?spm_id_from=333.337.search-card.all.click&vd_source=9a4f938fc995660b06355915cb8675cb">程序员都必须会的技术，面试必备【布隆过滤器详解】，Redis缓存穿透解决方案_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV14K411c7Yo/?spm_id_from=333.999.0.0&vd_source=9a4f938fc995660b06355915cb8675cb">面试阿里，竟然给了我一窝鸟蛋，让我用鸟蛋讲布谷鸟过滤器，这是什么鬼？_哔哩哔哩_bilibili</a></li></ul></li></ul></li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li><p>编码的时候，会做网络序转换，为什么要做这个转换呢？</p><ul><li>由于不同的系统对应的大小端不同需要进行转换，并且使用小端能够更好的进行部分计算机运算</li><li>大小端模式：</li><li><a href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">大端与小端的比较</a></li><li>大端实际上就是按照内存地址递增的方向顺序存储，小端即反向存储对应结构</li><li>网络传输字节序<ul><li>TCP&#x2F;IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化</li></ul></li><li>常见的处理器大小端模式<ul><li>x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian</li><li>Motorola 6800，Motorola 68000，PowerPC 970，System&#x2F;370，SPARC（除V9外）等处理器为Big endian</li><li>ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的</li></ul></li><li>判断大小端的程序写法<ul><li>给定一个int类型的数字num值为1<br>如果是大端字节序，则在内存中存储方式为 0000 0000    0000 0000   0000 0000    0000 0001<br>如果是小端字节序，则在内存中存储方式为   0000 0001    0000 0000   0000 0000    0000 0000<br>要判断它们，我们可以只取出第一个字节，如果是0，则是大端；如果是1，则是小端</li></ul></li></ul></li><li><p>多级cache</p><ul><li><p><a href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell</a>(写的非常好)</p></li><li><p><a href="https://blog.csdn.net/m0_38017860/article/details/122988861">(缓存一致性协议-MESI_小盒子的技术分享的博客-CSDN博客</a>(关于MESI的使用)</p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162858367.png" alt="image-20221120141809023"></p><ul><li><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存</p><p>读取数据过程。就像数据库缓存一样，首先在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，向内存要数据。一次次地未命中，代表取数据消耗的时间越长。</p></li><li><p>CPU缓存(cache)是由很多个Cache line组成的。Cache line是CPU缓存和主存交换数据的最小单位，Cache line大小是固定的，通常为64Byte</p></li><li><p>当数据大小超过Cache line的固定大小时，就没法用缓存一致性协议了，会转而使用总线加锁</p></li><li><p>缓存一致性（MESI）协议</p><ul><li>缓存一致性协议提供了一种高效的内存数据管理方案，它<strong>只会对单个缓存行（缓存行是缓存中数据存储的基本单元）的数据进行加锁，不会影响到内存中其他数据的读写</strong></li><li>缓存一致性协议有MSI，MESI，MOSI，Synapse，Firefly及DragonProtocol等</li><li>其中MESI分别代表缓存行数据所处的四种状态，通过这四种状态的切换，来管理缓存数据。可以使用2bit进行表示<ul><li>M修改（Modefiy）：该缓存行有效， 数据被修改了，和内存中的数据不一样，数据只存在于本缓存行中</li><li>E独享（Exclusive）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据只存在本缓存行中</li><li>S共享（Shared）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据同时存在于其他缓存中</li><li>I无效（Invalid）：该缓存行数据无效</li></ul></li><li>MESI协议总结<ul><li>当CPU进行写操作时，如果发现操作的变量是共享变量，则会发出信号通知其他的CPU将该变量的缓存行置为无效状态，此时其他的CPU需要读取这个变量时，发现自己缓存中是无效的就会从内存中重新读取数据来保证一致性<ul><li>所谓同步化是使用监听（嗅探）其他cpu对该缓存行对应主内存地址的读取操作来实现同步</li></ul></li><li>其正常运行依赖于以下两点<ul><li>读取数据时，其他CPU缓存行如果修改了数据，需要先把修改的数据写入主存中</li><li>当修改数据时，其他CPU中缓存行都必须失效</li></ul></li><li>由于缓存行的形式，可能同时存在多个核需要修改的值存放在同一缓存行的情况，这时就会由于两个核都竞相写入这个缓存行并且导致其他核中缓存无效的重复操作，故需要进行把缓存行中仅存储目标变量，其余空间采用“无用”数据填充补齐64字节</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162139212.png" alt="image-20221122165519514"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165542010.png" alt="image-20221122165542010"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161659369.png" alt="image-20221122165600678"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165626261.png" alt="image-20221122165626261"></li><li>AMD的Opteron处理器使用从MESI中演化出的MOESI协议，O(Owned)是MESI中S和M的一个合体，表示本Cache line被修改，和内存中的数据不一致，不过其它的核可以有这份数据的拷贝，状态为S</li><li>Intel的core i7处理器使用从MESI中演化出的MESIF协议，F(Forward)从Share中演化而来，一个Cache line如果是Forward状态，它可以把数据直接传给其它内核的Cache，而Share则不能</li><li>每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li><li>嗅探所导致的问题：<strong>总线风暴</strong>，由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值</li><li>嗅探本身其实就是缓存一致性的一种实现<ul><li><strong>每个处理器内核都会监听在CPU总线上传播的数据，并检查自己的缓存值是否已过期；如果处理器发现自己缓存行对应的内存地址已被修改，就会将当前处理器的缓存行设置为无效状态当处理器对这个数据进行修改操作时，会重新从主内存中把数据读取到处理器的缓存中。</strong></li></ul></li></ul></li></ul></li><li><p><strong>DMA</strong>  <strong>直接内存访问（Direct Memory Access）</strong></p><ul><li><strong>总结：</strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务（聪明的CPU让DMA去做搬运数据等脏活累活，直到干完活后才通知CPU过来做从内核缓冲区到用户缓冲区这样高难度的工作）</li><li>每个 I&#x2F;O 设备都有自己的 DMA 控制器</li><li>小林code</li></ul></li><li><p>零拷贝及IO优化</p><ul><li>小林code操作系统第九章</li><li><strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong></li><li>零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</li><li>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I&#x2F;O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能</li></ul></li><li><p>PageCash相关</p><ul><li>小林code操作系统第九章</li><li>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题</li><li>在高并发的场景下，针对大文件的传输的方式，应该使用<strong>「异步 I&#x2F;O + 直接 I&#x2F;O」</strong>来替代零拷贝技术。</li></ul></li><li><p>两层循环，循环次数多的放内层还是外层</p><ul><li>结论：存在嵌套循环时，大循环写里面，小循环写外面</li><li>原因：外层的循环次数正比于预测错误的次数，为了尽可能的降低预测错误的次数，故将外层循环次数降低</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164538597.png" alt="image-20221117183934578"></li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li><p>TODO 网络数据传输解析全过程</p></li><li><p>ICMP协议，有了解吗？</p><ul><li>ICMP是（Internet Control Message Protocol）Internet控制报文协议</li><li>主要功能（Ping）<ul><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ul></li></ul></li><li><p>HTTP和HTTPS的区别是什么？</p><ul><li><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&utm_relevant_index=1"> HTTP和HTTPS协议，看一篇就够了_会飞的狗~的博客-CSDN博客</a></li><li><a href="https://tyler-zx.blog.csdn.net/article/details/80969419?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&utm_relevant_index=1"> HTTP 和 HTTPS 的区别（面试常考题）_Tyler_Zx的博客-CSDN博客_http和https区别</a></li></ul></li><li><p>http版本相关</p><ul><li><p>HTTP0.9</p><ul><li>最早版本是<code>1991</code>年发布的<code>0.9</code>版。该版本极其简单，只有一个命令<code>GET</code>。协议规定，服务器只能回应<code>HTML</code>格式的字符串，不能回应别的格式。服务器发送完毕，就关闭TCP连接</li></ul></li><li><p>HTTP1.0</p><ul><li>除了<code>GET</code>，还引入了<code>POST</code>和<code>HEAD</code>方法，丰富了浏览器与服务器的互动手段。此时不仅可以传输文字，还能传输图像、视频、二进制文件。<code>HTTP/1.0</code> 版的主要缺点是，每个<code>TCP</code>连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接（短连接）</li></ul></li><li><p>HTTP1.1</p><ul><li>默认使用长链接，支持管道化，不必等前一个请求响应才发出第二个请求，还提供了与身份认证、状态管理和 <code>Cache</code> 缓存等机制相关的请求头和响应头此外，还新增了五种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code>，并且增加了host字段</li></ul></li><li><p>HTTP2</p><ul><li>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</li><li>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分</li><li>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率</li><li>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li><li>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</li></ul></li><li><p>HTTP3</p><ul><li>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP</li></ul></li></ul></li><li><p>数字证书使用了什么机制？  数字证书为什么可以被创建？</p></li><li><p>http的三次握手四次挥手</p><ul><li>小林code</li></ul></li><li><p>http的几种常见状态码</p><ul><li><a href="https://blog.csdn.net/DGMM_/article/details/120641072">常见的http状态码有哪些_呆瓜瓜瓜的博客-CSDN博客_http状态码</a></li></ul></li><li><p>http长连接</p><ul><li><a href="https://blog.csdn.net/hyxhbj1/article/details/124904092"> HTTP 长连接原理_Leo90567的博客-CSDN博客</a></li></ul></li><li><p>SSL协议和TLS协议</p><ul><li><p><strong>SSL 和 TLS 没有太大的区别。</strong></p><p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p></li></ul></li><li><p>浏览器解析页面的过程（TODO 进一步细化到ARP层）</p><ul><li>在地址栏中输入URL</li><li>对输入的URL进行DNS解析，获取目标服务器IP地址，优先浏览器DNS缓存查询&gt;本地host文件查询，如没有则进行递归或迭代查询，本地区的域名服务器&gt;根DNS域名服务器&gt;顶级域名服务器&gt;依次向下</li><li>像目标IP发送http请求</li><li>建立tcp链接</li><li>接受返回数据</li><li>浏览器渲染线程解析html文件，方向由上至下</li><li>解析HTML文件标签对并渲染</li><li>（从dhcp，到dns解析，到http，到tcp，到arp，到nat、到局域网，因特网，我很详细地说了）</li><li>详见小林code</li></ul></li><li><p>TCP模型、流量控制、拥塞控制</p></li><li><p>tcp如何实现可靠传输</p></li><li><p>tcp和udp区别</p></li><li><p>如何基于udp实现可靠传输</p><ul><li>小林code</li><li>TCP的缺点：<a href="https://mp.weixin.qq.com/s/9kHoRk6QIYOFUR_PCmHY6g">TCP 就没什么缺陷吗？ (qq.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/405387352">https://zhuanlan.zhihu.com/p/405387352</a></li><li>不应该考虑如何在应用层实现TCP的特点（那样不如直接使用TCP），而是要强调UDP的特点</li></ul></li><li><p>线性一致性是什么</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><p>线程、进程和协程</p><ul><li><a href="https://blog.csdn.net/qq_39304851/article/details/119975280">进程、线程、协程_Pinker_Q的博客-CSDN博客_进程 线程 协程</a></li><li>早期操作系统只有进程这个唯一的执行体，而现在出现了<strong>进程内的执行体</strong>（线程和协程）</li><li>进程是<strong>资源分配</strong>（内存，显卡，磁盘）的最小单位，线程是<strong>程序执行</strong>(cpu调度)的最小单元</li></ul></li><li><p>线程上下文切换的开销</p><ul><li>直接开销：操作系统保存恢复上下文（CPU寄存器值，程序计数器值）所需的开销； 线程调度器调度线程的开销</li><li>间接开销：处理器高速缓存重新加载的开销；上下文切换可能导致整个一级高速缓存中的内容被冲刷，即被写入到下一级高速缓存或主存</li></ul></li><li><p>进程和协程之间的互斥</p></li><li><p>PV操作相关</p></li><li><p>多核对于多线程的分配</p><ul><li>同一个核上同时只会有一个线程在跑，线程本身由操作系统调度，操作系统会根据线程的优先级等内容为线程分配时间片，如果所属时间片用完操作系统会将该线程的上下文保存起来，然后把另外的线程选一个将上下文推到栈内，然后切换到对应代码块执行代码</li><li>所以运行态线程多的情况下，需要一小部分cpu用于线程的上下文切换，而且还有执行上下文切换时的内核态和用户态的切换开销</li><li>一个核同一时间只能执行一条线程，所以不能盲目的增加线程，当线程过多时，CPU核快速切换线程也会导致效率下降</li><li>针对不同情况选择不同的线程数，对于计算密集型线程，为了尽可能保证每一个核都被利用，需要将线程数和核心数相统一，对于IO密集型线程，则可以相对创建更多的线程来处理（因为io占用了很长时间导致CPU没有使用很久）</li><li>多线程的话会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，但方便的同时会造成变量值的混乱，所以要通过线程锁来限制线程的执行</li></ul></li><li><p>线程安全队列的设计</p></li><li><p>io密集型和计算密集型分别适合多线程还是多进程</p></li><li><p>mysql以及java里面的乐观锁和悲观锁</p><ul><li><strong>悲观锁</strong>认为出现并发的概率很大，所以一旦线程拥有了锁就不允许其他线程获取</li><li><strong>乐观锁</strong>相对而言更宽泛，不对数据进行加锁操作，只是在数据提交的时候进行校验来判断是否产生冲突，常使用版本(version)或时间戳(timestamp)来实现，其中，版本最为常用</li><li>乐观锁适用于读多写少的场景，可以省去频繁加锁、释放锁的开销，提高吞吐量</li><li>在写比较多的场景下，乐观锁会因为版本不一致，不断重试更新，产生大量自旋，消耗 CPU，影响性能。这种情况下，适合悲观锁</li></ul></li><li><p>进程的通信方式（由于每个进程资源是独立的（地址空间和数据空间），就要在操作系统层面进行通信，如管道，队列，信号等）</p><ul><li><p>管道：管道是最简单，效率最差的一种通信方式。</p><ul><li>管道本质上就是内核中的一个缓存，当进程创建一个管道后，Linux会返回两个文件描述符，一个是写入端的描述符，一个是输出端的描述符，可以通过这两个描述符往管道写入或者读取数据。如果想要实现两个进程通过管道来通信，则需要让创建管道的进程fork子进程，这样子进程们就拥有了父进程的文件描述符，这样子进程之间也就有了对同一管道的操作。</li><li>缺点：半双工通信，一条管道同时只能一个进程写</li></ul></li><li><p>消息队列：数据会被分为一个一个的数据单元，称为消息体，消息发送方和接收方约定好消息体的数据类型，不像管道是无格式的字节流类型，这样的好处是可以边发送边接收，而不需要等待完整的数据</p><ul><li>缺点：1、数据单元的大小有限，队列中的数据单元数量也有限 2、消息队列通信过程中存在用户态和内核态之间的数据拷贝问题。进程往消息队列写入数据时，会发送用户态拷贝数据到内核态的过程，同理读取数据时会发生从内核态到用户态拷贝数据的过程</li></ul></li><li><p>共享内存：共享内存解决了消息队列存在的内核态和用户态之间数据拷贝的问题</p><ul><li>现代操作系统对于内存管理采用的是虚拟内存技术，也就是说每个进程都有自己的虚拟内存空间，虚拟内存映射到真实的物理内存。共享内存的机制就是，不同的进程拿出一块虚拟内存空间，映射到相同的物理内存空间。这样一个进程写入的东西，另一个进程马上就能够看到，不需要进行拷贝</li></ul></li><li><p>信号量：实际上是通过对信号量PV的限定来制约对共享内存的读写限制</p></li><li><p>信号：系统提供的信号用于响应各种事件可以通过kill -l命令查看，例如如下操作</p><ul><li>如果是运行在shell终端的进程，可以通过键盘组合键来给进程发送信号，例如使用Ctrl+C产生SIGINT信号，表示终止进程。</li><li>如果是运行在后台的进程，可以通过命令来给进程发送信号，例如使用kill -9 PID产生SIGKILL信号，表示立即结束进程</li></ul></li><li><p>Socket：跨网络与不同的主机进行通信，也可以用于本机通信，Socket是操作系统提供给程序员操作网络的接口，根据底层不同的实现方式，通信方式也不同，存在TCP的Socket通信和UDP的Sock通信</p><ul><li><p>TCP<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230108120131773.png" alt="image-20221118161635079"></p></li><li><p>UDP</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184605349.png" alt="image-20221118161659369"></p></li></ul></li></ul></li><li><p>TLB</p></li><li><p>进程切换，会刷新TLB吗</p></li><li><p>多核CPU里面，多个线程对缓存的数据操作，会出现什么问题？怎么解决？怎么保证数据的一致性</p></li><li><p>CAS是从乐观的角度出发，尝试用新值更新内存值，更新时会判断内存值是否被别人修改过，如果没有则直接更新。如果被修改过，则重新获取最新值再继续尝试更新，直到更新成功为止，所以CAS方式也称自旋锁</p><ul><li><a href="https://blog.csdn.net/user2025/article/details/109274018">CAS锁机制（无锁、自旋锁、乐观锁、轻量级锁）_</a></li></ul></li><li><p>synchronized跟Lock的区别</p></li><li><p>current包下的其他类</p></li><li><p>线程同步的方式</p></li><li><p>数据的线程安全了解吗？什么是线程安全问题？怎么解决</p></li><li><p>volatile修饰的变量在多个线程同时执行自增操作会发生什么？怎么解决</p><ul><li><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)</a></li><li>volatile保证了可见性和有序性，其原理如下分析<ul><li><p><strong>字节码层面</strong></p><ul><li><p>使用<strong>ACC_VOLATILE</strong>标识，使得后续操作通过判断该标识符来进行操作</p></li><li><p>具体代码如下，看得出其不能保证原子性，因为在读取和写入两个操作之间并不是原子性的</p><ul><li><p>getfield 获取原始值</p></li><li><p>iconst_1 将值入栈</p></li><li><p>iadd 进行加 1 操作</p></li><li><p>putfield 把 iadd 后的操作写回主内存</p></li></ul></li></ul></li><li><p><strong>JVM层面：</strong></p><ul><li>基于内存屏障（或者说是在JMM的层面上）<ul><li><p>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</p></li><li><p>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量</p></li></ul></li></ul></li><li><p><strong>汇编层面：</strong></p><ul><li>Load屏障，是x86上的”ifence“指令，在其他指令前插入ifence指令，<strong>可以让高速缓存中的数据失效，强制当前线程从主内存里面加载数据</strong></li><li>Store屏障，是x86的”sfence“指令，在其他指令后插入sfence指令，<strong>能让当前线程写入高速缓存中的最新数据，写入主内存，让其他线程可见。</strong></li><li>使用lock指令<ul><li>lock前缀，会保证某个处理器对共享内存（一般是缓存行cacheline）的独占使用（MESI协议）。它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。通过独占内存、使其他处理器缓存失效，达到了“指令重排序无法越过内存屏障”的作用，即在每次更改volatile变量的指令前面都添加lock指令，<strong>使得将当前处理器缓存行的数据写回到系统内存并且这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</strong></li></ul></li></ul></li><li><p><strong>特性总结</strong></p><ul><li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</li><li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</li><li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li><li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</li><li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li><li>volatile可以使得long和double的赋值是原子的。</li><li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li></ul></li></ul></li></ul></li><li><p>ThreadLocal发生内存泄漏的原因，线程结束之后是怎么样的</p></li><li><p>进程线程、协程区别（我很详细的说了，从os的底层实现到go的gmp模型）</p></li><li><p>线程池相关</p><ul><li><p>参数</p></li><li><p>执行过程</p></li><li><p>工作流程</p></li><li><p>拒绝策略<a href="https://blog.csdn.net/alan_liuyue/article/details/120995601">(51条消息) 线程池-四种拒绝策略总结_尘光掠影的博客-CSDN博客_线程池拒绝策略</a></p><ul><li><strong>AbortPolicy</strong> - 抛出异常，中止任务。抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行</li><li><strong>CallerRunsPolicy</strong> - 使用调用线程执行任务。当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><strong>DiscardPolicy</strong> - 直接丢弃，其他啥都没有，只是单纯抛弃任务并没有抛出异常的效果</li><li><strong>DiscardOldestPolicy</strong> - 丢弃队列最老任务，添加新任务。当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li></ul></li><li><p><strong>场景</strong>：四种拒绝策略都是有损的，如何优化。</p></li><li><p>i++和++i哪个线程不安全，为什么（深入再考虑一下静态变量的情况，静态变量到变量表的赋值过程，经操作证明对于静态变量而言，两者都是线程不安全的）</p></li><li><p>都是线程不安全的，两者本质在于先将在局部变量表中的读取和加载到操作数栈上的顺序</p></li><li><p>i++情况</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164514248.png" alt="image-20221118164514248"></li></ul></li><li><p>++i情况</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221117183934578.png" alt="image-20221118164538597"></li></ul></li></ul></li><li><p>线程的生命周期</p><ul><li><a href="https://www.cnblogs.com/lingstar/p/16529674.html">线程的生命周期 - 星余明 - 博客园 (cnblogs.com)</a></li><li>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120175358122.png" alt="image-20230108120131773"></li></ul></li></ul><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul><li>并发和并行的区别<ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li></ul></li><li>汇编文件的lock前缀，内存屏障，MESI设计，MESI与volatile的关系，MESI优化队列，总线锁与缓存锁，总线风暴</li></ul><h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><ul><li><p>数据库的四种隔离级别</p></li><li><p>索引</p><ul><li><p>聚集索引</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184621739.png" alt="image-20221124184605349"></li></ul></li><li><p>非聚集索引</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163119964.png" alt="image-20221124184621739"></li></ul></li></ul></li><li><p>事务</p></li><li><p>锁</p></li><li><p>字符集相关</p><ul><li>mysql, mysqladmin, mysqlcheck, mysqlimport, and mysqlshow 这些客户端工具都有一个默认的字符集，MySQL 5.7 是 latin1 ，MySQL 8.0为 utf8mb4 ；</li><li>每个客户端工具都会检测操作系统的字符集，比如Linux系统LANG环境变量的值，如果MySQL支持操作系统的字符集，就会使用操作系统的（这里支持包括不完全精确匹配时，OS字符集将映射到最接近的MySQL字符集）；如果不支持，就使用客户端默认字符集</li><li>Latin1是<a href="https://baike.baidu.com/item/ISO-8859-1?fromModule=lemma_inlink">ISO-8859-1</a>的别名，有些环境下写作Latin-1。ISO-8859-1编码是单<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318?fromModule=lemma_inlink">字节</a>编码，向下兼容<a href="https://baike.baidu.com/item/ASCII?fromModule=lemma_inlink">ASCII</a>，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>，0xA0-0xFF之间是文字符号</li></ul></li><li><p>联合索引，最左匹配法则</p><ul><li><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&utm_relevant_index=2">Mysql最左匹配原则_Summersadness8的博客-CSDN博客</a></li><li><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li></ul></li><li><p>更新 MySQL 时失败如何处理</p></li><li><p>模糊查询索引失效的情况</p></li><li><p>什么情况下索引会失效</p></li><li><p>索引缺点？？</p></li><li><p>模糊查询用%哪种情况会失效</p></li><li><p>inner join、left join、right join</p></li><li><p>怎么避免笛卡尔积，判断条件用哪个关键字</p></li><li><p>SQL优化</p></li><li><p>最左前缀</p></li><li><p>如何设计表</p></li><li><p>行锁和表锁是什么？行锁怎么实现的？</p></li><li><p>SQL的执行计划了解吗？（SQL执行顺序？哦哦是explain）</p></li><li><p>mysql的读写锁了解吗？（一时间没反应过来，直到面试官说共享排他才想起来）什么时候会触发排它锁</p></li><li><p>mysqldump导出sql文件和Navicat导出SQL文件的区别</p><ul><li>mysqldump导出的sql文件中会把尽可能多的数据放到一条“insert”语句中，而navicat导出的sql文件每条“insert”语句只对应一条数据，mysqldump导出的sql文件效率更高</li></ul></li><li><p>MySQL的索引为什么不设计成Hash？</p><ul><li>根本原因在于hash本身只能适用于等值运算和重复数据的影响<ul><li>Hash 索引仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</li><li>Hash 索引无法进行数据的排序操作</li><li>Hash 索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用</li><li>Hash 索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果</li><li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</li></ul></li></ul></li><li><p>安全等于可以用来判断null ， <code>&lt;=&gt;</code> 可以用来对 NULL 进行判断，两者都为 NULL 时返回值为 1</p></li></ul><h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><ul><li><p>grpc</p><ul><li><a href="https://blog.csdn.net/kevin_tech/article/details/120681720">什么是 gRPC </a></li></ul></li><li><p>分布式的两阶段和三阶段（分布式事务）</p><ul><li><a href="https://segmentfault.com/a/1190000022248118">分布式 - 共识、线性一致性与顺序一致性_个人文章 - SegmentFault 思否</a></li><li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理 | 酷 壳 - CoolShell</a></li><li><a href="https://time.geekbang.org/column/article/321346">13 | 全局事务和共享事务是如何实现的？ (geekbang.org)</a></li></ul></li><li><p>一致性描述</p><ul><li>CAP理论：以下三点不可能同时完全达到</li><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition Tolerance）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123162644337.png" alt="image-20221120175358122"></li></ul></li><li><p>一致性的分析</p><ul><li>弱一致性（最终一致性，不保证实时性但是最终一致）：DNS(域名系统),Gossip</li><li>强一致性：同步，Paxos，Raft，ZAB</li></ul></li><li><p>分布式系统对于fault tolorence 的一般解决方案在于state machine replication，而以下的一致性算法实际上就是为了讨论在replication的过程中的共识算法，即这些算法实际上应该称之为<strong>状态机复制的共识算法</strong></p></li><li><p>分布式系统的一致性算法（共识算法）</p><ul><li>Paxos</li><li>Raft（multi-paxos）以下算法都被认为是与 Multi Paxos 的等价派生实现</li><li>ZAB（multi-paxos）</li></ul></li><li><p>base-paxos算法的过程</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163157233.png" alt="image-20221123162644337"></li></ul></li><li><p>base-paxos算法的常见情景</p><ul><li>正常情况</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163247552.png" alt="image-20221123163119964"></li><li>单节点宕机情况</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161635079.png" alt="image-20221123163157233"></li><li>proposer提案期间失败（会有新的Proposer来接替工作）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164415140.png" alt="image-20221123163247552"></li><li>错误情况：活锁（进行争抢提案，导致无效竞争，可以使用随机计时器避免争抢）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164115232.png" alt="image-20221123163400102"></li></ul></li><li><p>base-paxos算法的问题</p><ul><li>实现复杂：角色组成多，实现起来复杂</li><li>效率低：调用两轮RPC操作</li><li>存在活锁问题</li></ul></li><li><p>Multi-paxos算法</p><ul><li>简化两轮RPC操作，通过一轮RPC实现</li><li>无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125161407202.png" alt="image-20221123164115232"></li><li>简化调用过程中的角色为两个</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163400102.png" alt="image-20221123164415140"></li></ul></li><li><p>Raft算法</p><ul><li><p>将问题简化为三个子问题</p><ul><li>leader election</li><li>log replication</li><li>safety</li></ul></li><li><p>重新定义角色</p><ul><li>leader</li><li>follower</li><li>candidate</li></ul></li></ul></li><li><p>分布式锁的实现方案</p><ul><li><p>Java中的锁主要包括synchronized锁和JUC包中的锁，这些锁都是针对单个JVM实例上的锁，对于分布式环境如果我们需要加锁就显得无能为力。</p><p>在单个JVM实例上，锁的竞争者通常是一些不同的线程，而在分布式环境中，锁的竞争者通常是一些不同的线程或者进程。如何实现在分布式环境中对一个对象进行加锁呢？答案就是分布式锁。</p><h3 id="分布式锁实现方案"><a href="#分布式锁实现方案" class="headerlink" title="分布式锁实现方案"></a>分布式锁实现方案</h3><p>目前分布式锁的实现方案主要包括三种：</p><ol><li>基于数据库（唯一索引）</li><li>基于缓存（Redis，memcached，tair）</li><li>基于Zookeeper</li></ol><p>基于数据库实现分布式锁主要是利用数据库的唯一索引来实现，唯一索引天然具有排他性，这刚好符合我们对锁的要求：同一时刻只能允许一个竞争者获取锁。加锁时我们在数据库中插入一条锁记录，利用业务id进行防重。当第一个竞争者加锁成功后，第二个竞争者再来加锁就会抛出唯一索引冲突，如果抛出这个异常，我们就判定当前竞争者加锁失败。</p><p>防重业务id需要我们自己来定义，例如我们的锁对象是一个方法，则我们的业务防重id就是这个方法的名字，如果锁定的对象是一个类，则业务防重id就是这个类名。</p><ul><li>基于缓存实现分布式锁：理论上来说使用缓存来实现分布式锁的效率最高，加锁速度最快，因为Redis几乎都是纯内存操作，而基于数据库的方案和基于Zookeeper的方案都会涉及到磁盘文件IO，效率相对低下。一般使用Redis来实现分布式锁都是利用Redis的SETNX key value这个命令，只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。</li><li>基于Zookeeper：Zookeeper一般用作配置中心，其实现分布式锁的原理和Redis类似，我们在Zookeeper中创建瞬时节点，利用节点不能重复创建的特性来保证排他性。</li></ul><p>在实现分布式锁的时候我们需要考虑一些问题，例如：分布式锁是否可重入，分布式锁的释放时机，分布式锁服务端是否有单点问题等。</p><h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><p>上面已经分析了基于数据库实现分布式锁的基本原理：通过唯一索引保持排他性，加锁时插入一条记录，解锁是删除这条记录。下面我们就简要实现一下基于数据库的分布式锁。</p><h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`distributed_lock`</span> (  <br>  <span class="hljs-symbol">`id`</span> bigint(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <br>  <span class="hljs-symbol">`unique_mutex`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;业务防重id&#x27;</span>,  <br>  <span class="hljs-symbol">`holder_id`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;锁持有者id&#x27;</span>,  <br>  <span class="hljs-symbol">`create_time`</span> datetime DEFAULT <span class="hljs-literal">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CURRENT_TIMESTAMP,  <br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),  <br>  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`mutex_index`</span> (<span class="hljs-symbol">`unique_mutex`</span>)  <br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;  <br></code></pre></td></tr></table></figure><p>id字段是数据库的自增id，unique_mutex字段就是我们的防重id，也就是加锁的对象，此对象唯一。在这张表上我们加了一个唯一索引，保证unique_mutex唯一性。holder_id代表竞争到锁的持有者id。</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> distributed_lock(unique_mutex, holder_id) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;unique_mutex&#x27;</span>, <span class="hljs-string">&#x27;holder_id&#x27;</span>);  <br></code></pre></td></tr></table></figure><p>如果当前sql执行成功代表加锁成功，如果抛出唯一索引异常(DuplicatedKeyException)则代表加锁失败，当前锁已经被其他竞争者获取。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">deletesql <span class="hljs-keyword">from</span> methodLock where <span class="hljs-attribute">unique_mutex</span>=<span class="hljs-string">&#x27;unique_mutex&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">holder_id</span>=<span class="hljs-string">&#x27;holder_id&#x27;</span>;  <br></code></pre></td></tr></table></figure><p>解锁很简单，直接删除此条记录即可。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：就以上的方案来说，我们实现的分布式锁是不可重入的，即是是同一个竞争者，在获取锁后未释放锁之前再来加锁，一样会加锁失败，因此是不可重入的。解决不可重入问题也很简单：加锁时判断记录中是否存在unique_mutex的记录，如果存在且holder_id和当前竞争者id相同，则加锁成功。这样就可以解决不可重入问题。</p><p><strong>锁释放时机</strong>：设想如果一个竞争者获取锁时候，进程挂了，此时distributed_lock表中的这条记录就会一直存在，其他竞争者无法加锁。为了解决这个问题，每次加锁之前我们先判断已经存在的记录的创建时间和当前系统时间之间的差是否已经超过超时时间，如果已经超过则先删除这条记录，再插入新的记录。另外在解锁时，必须是锁的持有者来解锁，其他竞争者无法解锁。这点可以通过holder_id字段来判定。</p><p><strong>数据库单点问题</strong>：单个数据库容易产生单点问题：如果数据库挂了，我们的锁服务就挂了。对于这个问题，可以考虑实现数据库的高可用方案，例如MySQL的MHA高可用解决方案。</p><h3 id="基于缓存实现分布式锁，以Redis为例"><a href="#基于缓存实现分布式锁，以Redis为例" class="headerlink" title="基于缓存实现分布式锁，以Redis为例"></a>基于缓存实现分布式锁，以Redis为例</h3><p>使用Jedis来和Redis通信。</p><h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_IF_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NX&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_WITH_EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PX&quot;</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 加锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁的key  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 竞争者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 锁超时时间，超时之后锁自动释放  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);  <br>    &#125;  <br>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">jedis.<span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> value, <span class="hljs-built_in">String</span> nxxx, <span class="hljs-built_in">String</span> expx, <span class="hljs-built_in">int</span> time);  <br></code></pre></td></tr></table></figure><p>这个set()方法一共五个形参：</p><ul><li>第一个为key,我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，这里写的是锁竞争者的id，在解锁时，我们需要判断当前解锁的竞争者id是否为锁持有者。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期时间的设置，具体时间由第五个参数决定；</li><li>第五个参数为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：1.当前没有锁（key不存在）,那么久进行加锁操作，并对锁设置一个有效期，同时value表示加锁的客户端。2.已经有锁存在，不做任何操作。</p><p>上述解锁请求中，SET_IF_NOT_EXIST(不存在则执行)保证了加锁请求的排他性，缓存超时机制保证了即使一个竞争者加锁之后挂了，也不会产生死锁问题：超时之后其他竞争者依然可以获取锁。通过设置value为竞争者的id，保证了只有锁的持有者才能来解锁，否则任何竞争者都能解锁，那岂不是乱套了。</p><h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Long</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span> = 1L;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 释放分布式锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 锁持有者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否释放成功  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span>(<span class="hljs-params">Jedis jedis, <span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId</span>) &#123;  <br>        <span class="hljs-title class_">String</span> script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;  <br>        <span class="hljs-title class_">Object</span> result = jedis.<span class="hljs-built_in">eval</span>(script, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(lockKey), <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(requestId));  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span>.<span class="hljs-title function_">equals</span>(result);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>解锁的步骤：</p><ol><li>判断当前解锁的竞争者id是否为锁的持有者，如果不是直接返回失败，如果是则进入第2步。</li><li>删除key，如果删除成功，返回解锁成功，否则解锁失败。</li></ol><p>注意到这里解锁其实是分为2个步骤，涉及到解锁操作的一个原子性操作问题。这也是为什么我们解锁的时候用Lua脚本来实现，因为Lua脚本可以保证操作的原子性。那么这里为什么需要保证这两个步骤的操作是原子操作呢？</p><p>设想：假设当前锁的持有者是竞争者1，竞争者1来解锁，成功执行第1步，判断自己就是锁持有者，这是还未执行第2步。这是锁过期了，然后竞争者2对这个key进行了加锁。加锁完成后，竞争者1又来执行第2步，此时错误产生了：竞争者1解锁了不属于自己持有的锁。可能会有人问为什么竞争者1执行完第1步之后突然停止了呢？</p><p>这个问题其实很好回答，例如竞争者1所在的JVM发生了GC停顿，导致竞争者1的线程停顿。这样的情况发生的概率很低，但是请记住即使只有万分之一的概率，在线上环境中完全可能发生。因此必须保证这两个步骤的操作是原子操作。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：以上实现的锁是不可重入的，如果需要实现可重入，在SET_IF_NOT_EXIST之后，再判断key对应的value是否为当前竞争者id，如果是返回加锁成功，否则失败。</p><p><strong>锁释放时机</strong>：加锁时我们设置了key的超时，当超时后，如果还未解锁，则自动删除key达到解锁的目的。如果一个竞争者获取锁之后挂了，我们的锁服务最多也就在超时时间的这段时间之内不可用。</p><p><strong>Redis单点问题</strong>：如果需要保证锁服务的高可用，可以对Redis做高可用方案：Redis集群+主从切换。目前都有比较成熟的解决方案。</p><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><h4 id="加锁和解锁流程"><a href="#加锁和解锁流程" class="headerlink" title="加锁和解锁流程"></a>加锁和解锁流程</h4><p>利用Zookeeper创建临时有序节点来实现分布式锁：</p><ol><li>当一个客户端来请求时，在锁的空间下面创建一个临时有序节点。</li><li>如果当前节点的序列是这个空间下面最小的，则代表加锁成功，否则加锁失败，加锁失败后设置Watcher，等待前面节点的通知。</li><li>当前节点监听其前面一个节点，如果前面一个节点删除了就通知当前节点。</li><li>当解锁时当前节点通知其后继节点，并删除当前节点。</li></ol><p>其基本思想类似于AQS中的等待队列，将请求排队处理。其流程图如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872108920/9F0FB4B766E3BFAF3E92FEAE0553DFC5" alt="img"></p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><strong>解决不可重入</strong>：客户端加锁时将主机和线程信息写入锁中，下一次再来加锁时直接和序列最小的节点对比，如果相同，则加锁成功，锁重入。</p><p><strong>锁释放时机</strong>：由于我们创建的节点是顺序临时节点，当客户端获取锁成功之后突然session会话断开，ZK会自动删除这个临时节点。</p><p><strong>单点问题</strong>：ZK是集群部署的，主要一半以上的机器存活，就可以保证服务可用性。</p><h4 id="利用curator实现"><a href="#利用curator实现" class="headerlink" title="利用curator实现"></a>利用curator实现</h4><p>Zookeeper第三方客户端curator中已经实现了基于Zookeeper的分布式锁。利用curator加锁和解锁的代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 加锁，支持超时，可重入   public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-function"><span class="hljs-keyword">return</span> interProcessMutex.<span class="hljs-title">acquire</span><span class="hljs-params">(timeout, unit)</span></span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;   <span class="hljs-comment">// 解锁   public boolean unlock() &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        interProcessMutex.release();  <br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;  <br>        log.<span class="hljs-keyword">error</span>(e.getMessage(), e);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        executorService.schedule(<span class="hljs-keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="三种方案比较"><a href="#三种方案比较" class="headerlink" title="三种方案比较"></a>三种方案比较</h3><p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872090690/841D619AD8F9824776994757BB726DFB" alt="img"></p></li></ul></li></ul><h2 id="消息队列相关"><a href="#消息队列相关" class="headerlink" title="消息队列相关"></a>消息队列相关</h2><ul><li><p>一个消息队列服务器推给客户端和客户端主动拉取消息的优缺点</p><ul><li><p>Push方式：</p><ul><li>优点：有消息就推给消费者。延迟小,几乎可以做到实时</li><li>缺点：加大Server端的工作量，进而影响Server的性能，并且Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题，解决方法是 给数据设定一个超时时间，当 Consumer 宕机时间超过这个阈值时，则清理数据；但这个时间阈值也并不太容易确定</li><li>总结：1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点</li><li>适用强调实时性的情况</li></ul></li><li><p>Pull方式：</p><ul><li>优点：消费者可以根据自己能力拉取消息处理</li><li>缺点：Client端循环地从Server端拉取消息，主动权在Client手里，但是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</li><li>总结：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull，为了避免空pull带来的性能损耗，使用<strong>长轮询</strong>的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。基本方式是：消费者如果尝试拉取失败，不是直接 return，而是把连接挂在那里（指挂在服务器端） wait，服务端如果有新的消息到来，把连接拉起，返回最新消息<ul><li>长轮询解释：<a href="https://blog.csdn.net/u013978512/article/details/126186884">( 什么是长轮询_法拉弟弟的博客-CSDN博客</a></li></ul></li><li>适用于消费者处理能力较强的情况，适用于消费者可能处于宕机状态的情况</li></ul></li></ul></li><li><p>mq消息队列的优势</p></li><li><p>RocketMQ 重传机制，上限</p></li><li><p>死信队列</p></li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li><p><strong>linux epoll底层原理</strong></p><ul><li>fd 即 文件描述符</li></ul></li><li><p>Linux文件系统</p></li><li><p>Linux中查询内存使用情况语句</p></li><li><p>Linux常用语句</p></li><li><p>epoll poll select讲讲（从底层linux源码机制到对比我都详细讲了）</p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>操作系统内存分配</li><li>缺页中断</li><li>那些操作会触发进程调度</li><li>进程调度算法</li><li>优先级抢占式调度算法，在都处于同一优先级的多个进程中，其中一个进程运行了太久怎么办？</li><li>什么时候会从用户态陷入内核态，具体细节</li></ul><h2 id="go语言拓展"><a href="#go语言拓展" class="headerlink" title="go语言拓展"></a>go语言拓展</h2><ul><li>gin框架了解</li><li>垃圾回收</li><li>协程实现</li></ul><h2 id="spring框架"><a href="#spring框架" class="headerlink" title="spring框架"></a>spring框架</h2><ul><li><p>springmvc的了解（整体辨析）</p></li><li><p>spring异常处理的实现（统一异常处理实现）</p></li><li><p>spring事务（详解）</p><ul><li>事务传播行为</li><li>事务管理机制：@Transactional<ol><li>原理</li><li>注解的参数</li><li>实现原理</li><li>失效情况</li></ol></li></ul></li><li><p>简单讲讲AOP以及常用注解spring的核心就是AOP，平常有没有用过AOP，尝试实战</p></li><li><p>JPA相关</p></li><li><p>springsecurity</p></li><li><p>Bean的生命周期</p><ul><li>javaguide</li></ul></li><li><p>@Resource与@Autowire的区别</p><ul><li>javaguide</li></ul></li><li><p>Spring中涉及到的设计模式</p><ul><li>javaguide</li></ul></li><li><p>Spring中依赖的注入</p></li><li><p>Spring中Bean的作用范围 </p><ul><li>javaguide</li></ul></li><li><p>Restful风格详解</p><ul><li>总结：将过程的调用名称不写在url中，而是使用GET、POST请求等作为区分</li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485510&idx=1&sn=e9273322ae638c8465a606737109ab97&chksm=cea2478df9d5ce9b58b9ff1f1e2ecca99e961b911adcec3d5a579b41e01151160cfb2891d91b&token=1701499214&lang=zh_CN&scene=21#wechat_redirect">后端开发必备的 RestFul API 知识 (qq.com)</a></li></ul></li><li><p>spring容器概念</p></li></ul><h3 id="JavaGuide部分"><a href="#JavaGuide部分" class="headerlink" title="JavaGuide部分"></a>JavaGuide部分</h3><ul><li>IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)</li><li>springboot和Spring等框架的关系<ul><li>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用</li></ul></li><li></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>红黑树</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>只含加减的计算机</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 存放所有的数字</span><br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将所有的空格去掉</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 存放所有的操作，包括 +/-</span><br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 计算到最近一个左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNum(c)) &#123;<br>                    <span class="hljs-comment">//当遇到数字时并不是只把这个位给加入，而是把所有的数字统计成一个数据加入</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty()) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-comment">//计算并且将计算结果直接放到Deque</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        nums.addLast(op == <span class="hljs-string">&#x27;+&#x27;</span> ? a + b : a - b);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加减乘除版本计算器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;()&#123;&#123;<br>        put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br>    &#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        nums.addLast(<span class="hljs-number">0</span>);<br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">if</span> (ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNumber(c)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="hljs-number">10</span> + (cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//为防止 () 内出现的首个字符为运算符，将所有的空格去掉，</span><br>                    <span class="hljs-comment">//并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</span><br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                        <span class="hljs-comment">//判断优先级位置</span><br>                        <span class="hljs-keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;<br>                            calc(nums, ops);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            ans = a + b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            ans = a - b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            ans = a * b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>            ans = a / b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>            ans = (<span class="hljs-type">int</span>)Math.pow(a, b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>            ans = a % b;<br>        &#125;<br>        nums.addLast(ans);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>手写层次遍历（这里问了我为什么前面用add后面用offer，我说我记得add被弃用了，前面紧张写快了就写成add了，后面想起来改成offer，底层是add直接调用offer）</li><li>平衡二叉树（左旋右旋）</li><li>红黑树相关</li><li>栈和队列的使用场景</li><li>反转字符串！</li><li>堆排序稳定吗（这个忘记了，现推说不稳定）</li><li>（排序总结）</li><li>写一个解析csv文件的类（写了40分钟，面试官说超时了。主要是我java好几个api忘了，一般我都是查文档，可是面试不能查，只能一个个试了😢）</li></ul><h2 id="项目场景"><a href="#项目场景" class="headerlink" title="项目场景"></a>项目场景</h2><ul><li>提前思考怎么突出项目中的亮点</li></ul><h2 id="主观问题总结"><a href="#主观问题总结" class="headerlink" title="主观问题总结"></a>主观问题总结</h2><ul><li>挑战性项目</li><li>诱导面试官提问自己熟悉的环节</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解JAVA虚拟机"><a href="#深入理解JAVA虚拟机" class="headerlink" title="深入理解JAVA虚拟机"></a>深入理解JAVA虚拟机</h1><h2 id="第二章：java内存区域和内存溢出异常"><a href="#第二章：java内存区域和内存溢出异常" class="headerlink" title="第二章：java内存区域和内存溢出异常"></a>第二章：java内存区域和内存溢出异常</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221119222233318.png" alt="image-20221119222233318"></p><ul><li><p>程序计数器部分：</p><ul><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域·</li></ul></li><li><p>栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息</p></li><li><p>对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置，不止是指针）</p></li><li><p>局部变量表中还存放了returnAddress类型（指向了一条字节码指令的地址）</p></li><li><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情</p></li><li><p>如果栈支持动态扩展，则当栈扩展无法申请到足够内存则会报错OOM</p></li><li><p>随着逃逸分析技术，栈上分配和标量替换等技术使得对象分配在堆中并不绝对化</p></li><li><p>分代并不是堆的固定“称呼”，只是HotSpot使用的垃圾回收器的流行导致的刻板印象</p></li><li><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存</p></li><li><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来</p></li><li><p>永久代（所谓永久只是因为这部分的垃圾回收不好操作，类卸载也很严格，但的确需要回收）只是HotSpot对于方法区的一种实现，其他虚拟机并没有这个区域，只是为了使得HotSpot的垃圾回收器能够像管理java堆一样管理方法区，由于其本身更容易产生内存溢出的问题，到了java8中将永久代中的类型信息移动到由本地内存实现的元空间中</p></li><li><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p></li><li><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法</p></li><li><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</p></li><li><p>对象的分配方式</p><ul><li>指针碰撞（Bump ThePointer）：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离<ul><li>使用场景：当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效</li></ul></li><li>空闲列表（Free List）：虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录<ul><li>使用场景：用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存</li></ul></li></ul></li><li><p>分配内存可能产生并发（争抢同一块内存）的解决方法：</p><ul><li>对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定</li></ul></li><li><p>内存分配完成后需要对分配好的内存空间（除对象头）全都初始化为0，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来</p></li><li><p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p><ul><li>对象头的组成部分<ul><li>Mark Word ：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特</li><li>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</li><li>（如果这个对象是数组）对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小</li></ul></li></ul></li><li><p>对象的定位方式</p><ul><li>句柄访问</li><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120151423921.png" alt="image-20221120151423921"></li><li>直接指针访问</li><li>优点：使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它<strong>主要使用第二种</strong>方式进行对象访问</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120151434004.png" alt="image-20221120151434004"></li></ul></li><li><p>Java的线程是映射到操作系统的内核线程上，无限制地创建线程会对操作系统带来很大压力，上述代码执行时有很高的风险，可能会由于创建线程数量过多而导致操作系统假死</p></li><li><p>OOM的不同情况分析</p><ul><li>堆溢出<ul><li>使用内存映像分析工具对堆转储快照进行分析，判断是内存泄漏还是内存溢出，<ul><li>内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置</li><li>内存溢出，检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗</li></ul></li></ul></li><li>java虚拟机栈溢出&#x2F;本地方法栈溢出<ul><li>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常，但是如果运行动态扩展栈的大小则报错OOM</li></ul></li><li>方法区和运行时常量池溢出<ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120153930160.png" alt="image-20221120153930160"></li></ul></li><li>随着Spring框架等动态生成类的大量使用，导致方法区容易溢出，但是随着java8将类数据移动到元空间中，即类导致的内存溢出不容易出现</li></ul></li></ul><h2 id="第三章：垃圾收集器与内存分配策略"><a href="#第三章：垃圾收集器与内存分配策略" class="headerlink" title="第三章：垃圾收集器与内存分配策略"></a>第三章：垃圾收集器与内存分配策略</h2><ul><li><p>一般不考虑线程独占的内存部分的数据回收，因为随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的）</p></li><li><p>引用计数法简单高效但是需要很多额外的工作才能保证其工作正常运行（循环引用）</p></li><li><p>目前广泛使用可达性分析算法，使用GCroots进行判断</p></li><li><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，<strong>如果进行局部回收，某个区域里的对象完全有可能被位于堆中其他区域的对象所引用</strong>，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性</p></li><li><p>常见引用分类</p><ul><li>强引用：永远不回收，传统的引用定义</li><li>软引用：有用但不必须，在即将报错内存溢出时，会把软引用的对象纳入回收范围内进行回收，如果还是不够才报错</li><li>弱引用：只能活到下次垃圾回收前</li><li>虚引用：虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</li></ul></li><li><p>对象回收的完整过程（至少进行两次标记）</p><ul><li>可达性分析GCRoots标记，若其没有相连的引用链则进行第一次标记</li><li>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（这句话的含义在于，如果该对象通过finalize方法逃脱过一次垃圾回收，那么下一次垃圾回收就没办法使用这个逃脱方法了），那么虚拟机将这两种情况都视为“没有必要执行“</li><li>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会<strong>触发</strong>这个方法开始运行，但并不承诺一定会等待它运行结束（如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃）</li><li>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了</li></ul></li><li><p>对于方法区的垃圾回收</p><ul><li>JVM虚拟机规范中甚至不要求对方法区进行垃圾回收事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）（但对于方法区的回收实际上有是有必要的，在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力）</li><li>在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此</li></ul></li><li><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型</p></li><li><p>类卸载的三个前提（之所以是前提是因为就算满足了也不一定回收）</p><ul><li>Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收（很难满足）</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li><li><p>建立分代回收机制（分代本身越来越暴露缺陷）的三个前提假说</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数（实际上是前面两个假说的推论，因为强分代最终会因为引用了弱分代而把它拉到老年代中）</li></ul></li><li><p>跨代引用的解决方法</p><ul><li>我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的</li></ul></li><li><p>垃圾回收分类</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。<strong>目前只有CMS收集器会有单独收集老年代的行为。</strong>另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。<strong>目前只有G1收集器会有这种行为</strong></li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li></ul></li><li><p><strong>垃圾回收算法</strong></p><ul><li><p><strong>标记清除算法</strong></p><ul><li>缺点：<ul><li>第一个是<strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记（标记所有）和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>第二个是<strong>内存空间的碎片化</strong>问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul></li><li><p><strong>标记复制算法</strong>（正如其字面意思：半区复制）</p><ul><li>优点：内存分配简单，只需要在栈顶指针进行移动即可，不会有内存碎片的问题</li><li>缺点：只使用了一半的内存，并且当需要保存的对象很多时，内存复制开销大</li><li>适用场景：新生代的垃圾回收（由于新生代的对象短命，故每次内存复制的开销少）<ul><li>PS：同样的这样的算法显然不适合老年代回收，因为老年代往往大量不会被回收，新生代的那点担保空间完全不足以承担老年代的容量</li></ul></li><li>优化算法：“Appel式回收”<ul><li><strong>HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局</strong>[1]。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</li><li>特殊情况下需要保留的对象超过10%时，因此Appel式回收还有一个充当罕见情况的“<strong>逃生门</strong>”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion），即额外的部分直接进入老年代</li></ul></li></ul></li><li><p><strong>标记整理算法</strong></p><ul><li>缺点：移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，即“Stop The World”</li><li>适用场景：老年代垃圾回收</li><li>优化算法：对于老年代的回收可以通过移动来腾出内存，也可以使用<strong>分区空闲分配链表</strong>来解决内存分配问题，但是两者各有利弊移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是<strong>赋值器与收集器</strong>的效率总和。即使不移动对象会使得收集器的效率提升一些，但因<strong>内存分配和访问相比垃圾收集频率要高得多</strong>，这部分的耗时增加，<strong>总吞吐量仍然是下降的</strong>。HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的<ul><li>另外，还有一种<strong>“和稀泥式”</strong>解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机<strong>平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在</strong>，直到内存空间的碎片化程度已经大到影响对象分配时，<strong>再采用标记-整理算法收集一次，以获得规整的内存空间</strong>。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法</li></ul></li></ul></li><li><p>根结点枚举的难处：Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检</p><p>查以这里为起源的引用肯定得消耗不少时间</p></li><li><p>枚举根结点是一定要STW的，即使是所谓的并发分析也只是在一个具有一致性（枚举期间引用关系不能改变）的快照中进行的</p></li><li><p>虚拟机中并不是完全从GCroot开始分析的，虚拟机中有OopMap的数据结构用于存放对象引用</p></li><li><p>安全点：</p><ul><li>HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）</li><li>用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点</li><li>确保每个线程都达到安全的方式<ul><li>抢先式中断（Preemptive Suspension）抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。<strong>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件</strong></li><li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。<strong>轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</strong></li></ul></li><li>HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的test指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了</li><li>安全区域：<ul><li>用户线程处于Sleep状态或者Blocked状态由于没有时间片，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</li><li>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。<strong>我们也可以把安全区域看作被扩展拉伸了的安全点</strong></li><li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止</li></ul></li></ul></li></ul></li><li><p>TODO：记忆表卡表到垃圾回收器期间</p></li><li><p>java垃圾回收中<strong>并发和并行</strong>的定义</p><ul><li>并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li><li>并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响</li></ul></li><li><p>经典垃圾回收器</p><ul><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221121165159996.png" alt="image-20221121165159996"></p></li><li><p><strong>Serial 垃圾回收器</strong></p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221121165405966.png" alt="image-20221121165405966"></li><li>优点：HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是<strong>简单而高效</strong>（与其他收集器的单线程相比）<ul><li><strong>物理机内存受限的情况：</strong>对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗（Memory Footprint）最小的</strong>；</li><li><strong>单核处理器情况：</strong>对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于<strong>没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</strong></li><li><strong>应用本身占用空间少的情况：</strong>在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的</li></ul></li></ul></li><li><p><strong>ParNew收集器</strong></p><ul><li>实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221201173858863.png" alt="image-20221123193014729"></li><li>优点：不少运行在服务端模式下的HotSpot虚拟机<ul><li>除了Serial收集器外，目前只有它能与CMS收集器配合工作</li><li>当处理器多核并且开启了很多线程时比Serial收集器效果更好</li></ul></li><li>缺点：ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍）的环境中</li></ul></li><li><p><strong>Parallel Scavenge收集器：</strong>也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，Parallel Scavenge的诸多特性从表面上看和ParNew非常相似</p><ul><li>特点：Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</li><li>适用场景：停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务</li><li>调节参数：Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，<ul><li>控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数</li><li>直接设置吞吐量大小的-XX：GCTimeRatio参数</li><li>自动优化参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）</li></ul></li><li>和ParNew的区分：<ul><li>Parallel Scavenge注重吞吐量而非相应时间</li><li>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</li></ul></li></ul></li><li><p><strong>Serial Old收集器：</strong>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法(特征类似Serial )</p><ul><li>适用场景：<ul><li>供客户端模式下的HotSpot虚拟机使用</li><li>在服务端情况下作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul></li></ul></li><li><p><strong>Parallel Old收集器：</strong>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现</p><ul><li>适用场景：在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</li></ul></li><li><p><strong>CMS（Concurrent Mark Sweep）收集器：</strong>是一种以获取最短回收停顿时间为目标的收集器</p><ul><li>适用场景：互联网网站或者基于浏览器的B&#x2F;S系统的服务端上（关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验）</li><li>使用步骤<ul><li>初始标记（CMS initial mark）  “<strong>Stop The World”</strong><ul><li>只是标记一下GCRoots能直接关联到的对象，速度很快</li></ul></li><li>并发标记（CMS concurrent mark）<ul><li>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li></ul></li><li>重新标记（CMS remark）        <strong>“Stop The World”</strong><ul><li>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li></ul></li><li>并发清除（CMS concurrent sweep）<ul><li>清理删除掉标记阶段判断的已经死亡的对象，由于<strong>不需要移动存活对象</strong>，所以这个阶段也是可以与用户线程同时并发的</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123202904830.png" alt="image-20221123202904830"></li></ul></li><li>优点：<ul><li>并发收集、低停顿</li></ul></li><li>缺点：<ul><li><strong>CMS收集器对处理器资源非常敏感</strong>（配置要求高）。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。<strong>如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低</strong>。为了缓解这种情况，虚拟机提供了一种称为“增量式并发收集器”在并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK 7开始，i-CMS模式已经被声明为“deprecated”，即已过时不再提倡用户使用，<strong>到JDK 9发布后i-CMS模式被完全废弃</strong></li><li><strong>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生</strong>。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。<strong>同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。</strong>但这又会更容易面临另一种风险：要是CMS运行期间<strong>预留的内存无法满足程序分配新对象的需要</strong>，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，<strong>临时启用Serial Old收集器</strong>来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置</li><li><strong>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦</strong>，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）</li></ul></li></ul></li><li><p><strong>Garbage First（简称G1）收集器：</strong></p><ul><li><p>G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器</p></li><li><p>作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”（PausePrediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java（RTSJ）的中软实时垃圾收集器特征了</p></li><li><p>特点：</p><ul><li>以面向堆内存任何部分来组成<strong>回收集（Collection Set，一般简称CSet）</strong>进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</li><li><strong>G1开创的基于Region的堆内存布局是它能够面向堆内存任何部分回收的关键，</strong>把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果</li><li><strong>Region中还有一类特殊的Humongous区域，专门用来存储大对象</strong>。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li><li><strong>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，</strong>它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它<strong>将Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍，这样可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。更具体的处理思路是让<strong>G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小</strong>，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率</li><li>并非纯粹地追求低延迟，官方给它设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>（即更多的去追求回收速率而不是追求回收百分比，只要能够满足内存分配的速度即可）</li><li><strong>可以由用户指定期望的停顿时间是G1收集器很强大的一个功能</strong>，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为两百毫秒，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的</li></ul></li><li><p><strong>实现过程中解决问题的方式：</strong></p><ul><li>将Java堆分成多个独立Region后，Region里面存在的<strong>跨Region引用对象如何解决？</strong>解决的思路我们已经知道：使用记忆集避免全堆作为GC Roots扫描，但在<strong>G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针</strong>，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有更高的内存占用负担。根据经验，<strong>G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</strong></li><li><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong>这里首先要解决的是用户线程改变对象引用关系时，须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过（见3.4.6节）：<strong>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。</strong>此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，<strong>把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围</strong>。<strong>与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”</strong></li><li><strong>怎样建立起可靠的停顿预测模型？</strong>用户通过-XX：MaxGCPauseMillis参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但G1收集器要怎么做才能满足用户的期望呢？<strong>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息</strong>。这里<strong>强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值</strong>。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益</li></ul></li><li><p>执行过程的分析（如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤）：</p><ul><li><strong>初始标记（Initial Marking）：</strong>  “<strong>Stop The World”</strong><ul><li>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li></ul></li><li><strong>并发标记（Concurrent Marking）：</strong>    <ul><li>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。</li></ul></li><li><strong>最终标记（Final Marking）：</strong>    “<strong>Stop The World”</strong><ul><li>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li></ul></li><li><strong>筛选回收（Live Data Counting and Evacuation）： **    “</strong>Stop The World”**<ul><li>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作<strong>涉及存活对象的移动，是必须暂停用户线程</strong>，由多条收集器线程并行完成的。（CMS基于标记清除，不需要移动对象，自然不用STW）</li><li>PS：回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，<strong>停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案</strong></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123193014729.png" alt="image-20221126173040784"></p></li><li><p><strong>CMS垃圾回收器和G1垃圾回收器比较</strong></p><ul><li><strong>G1 的优点：****相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力</strong>与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li><li><strong>CMS的优点：</strong>虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的</li><li><strong>在执行负载的角度上</strong>，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同，譬如它们都使用到写屏障，<strong>CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障</strong>来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。</li><li><strong>总结：在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</strong></li></ul></li></ul></li></ul></li><li><p>TODO （剩余部分省略）</p></li></ul><h2 id="第六章：类文件结构"><a href="#第六章：类文件结构" class="headerlink" title="第六章：类文件结构"></a>第六章：类文件结构</h2><ul><li>class文件由两部分组成：无符号数和表（更准确的说，class文件的一部分即为常量池，而常量池中的所有数据项都可以看做是“_info”结尾的表，而这些表又由其他表或者基本数据类型所组成）<ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成</li></ul></li><li>由于class文件没有任何分割符，所以必须保证其长度的确定性</li><li>UTF-8缩略编码与普通UTF-8编码的区别是：（尽可能的省）<ul><li>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示</li></ul></li><li>类文件中的数据指向可以看做是连环嵌套的格式，比如下图类索引指向常量池中的类info，而类info中的字面量又指向utf8_info</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126173040784.png" alt="image-20221201173858863"></p><ul><li>相比于全限定名和简单名称，方法和字段的描述符就要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值<ul><li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录成“[I”。</li><li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava&#x2F;lang&#x2F;String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”</li></ul></li><li>方法表中本身没有code，其具体代码存放在方法属性表中<ul><li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在下一节中详细讲解。</li></ul></li><li>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</li><li>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性</li></ul><h2 id="第十章：前端编译和优化（TODO学完编译原理后学习）"><a href="#第十章：前端编译和优化（TODO学完编译原理后学习）" class="headerlink" title="第十章：前端编译和优化（TODO学完编译原理后学习）"></a>第十章：前端编译和优化（TODO学完编译原理后学习）</h2><ul><li><strong>java中的编译的”多种解释”</strong><ul><li>前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；<ul><li>JDK的Javac（C++语言（包含少量C语言））、Eclipse JDT中的增量式编译器（ECJ）</li></ul></li><li>Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；<ul><li>HotSpot虚拟机的C1、C2编译器，Graal编译器</li></ul></li><li>使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程<ul><li>JDK的Jaotc、GNU Compiler for the Java（GCJ）[2]、Excelsior JET</li></ul></li></ul></li><li>前端编译实际上在后期的优化是微乎其微的，选择把对性能的优化全部集中到运行期的即时编译器中，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化措施所带来的性能红利</li><li><strong>java采用解释器和编译器并行的结构</strong><ul><li>解释器优点：<ul><li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行（编译器要想获取优化程度更好的代码自然要编译更长的时间）</li><li>内存角度：当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在）</li></ul></li><li>编译器优点<ul><li>随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</li><li>内存角度：如果内存相对充裕，可以使用编译执行来提升效率</li></ul></li><li>解释器作为编译器的逃生门（编译器做错事的后备选择）<ul><li>解释器还可以作为<strong>编译器激进优化时后备的“逃生门”</strong>（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如图11-1所示。</li></ul></li></ul></li><li></li></ul><h2 id="第十一章：后端编译和优化"><a href="#第十一章：后端编译和优化" class="headerlink" title="第十一章：后端编译和优化"></a>第十一章：后端编译和优化</h2><ul><li><p>即时编译器编译热点代码</p><ul><li>当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化</li></ul></li><li><p><strong>即时编译器分类</strong></p><ul><li>C1编译器——“客户端编译器”（Client Compiler）</li><li>C2编译器——“服务端编译器”（Server Compiler）</li><li>Graal编译器（JDK 10出现，目的用于替代C2编译器，Graal编译器目前还处于实验状态）</li></ul></li><li><p>java虚拟机默认情况都是编译器和解释器一同工作</p><ul><li>“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式（决定使用C1还是C2）</li><li>“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时候编译器完全不介入工作，全部代码都使用解释方式执行</li><li>“-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode），这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程</li></ul></li><li><p><strong>分层编译</strong></p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）</li><li>第1层。使用（C1）客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li><li>不同情况下的分层编译</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125203607563.png" alt="image-20221128104046824"></p></li><li><p>分层编译的好处</p><ul><li>实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间</li></ul></li><li><p>热点代码主要为：<strong>多次调用的方法，多次执行的循环体</strong></p><ul><li>对于这两种情况，<strong>编译的目标对象都是整个方法体，而不会是单独的循环体</strong>。第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为<strong>“栈上替换”（On Stack Replacement，OSR）</strong>，即方法的栈帧还在栈上，方法就被替换了</li></ul></li><li><p>热点探测判定：（两者在虚拟机的不同实现中都有应用）</p><ul><li><p>基于采样的热点探测（Sample Based Hot Spot Code Detection）</p><ul><li>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是<strong>很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li></ul></li><li><p>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</p><ul><li><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器</strong>，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li><li>方法调用计数器（Invocation Counter）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125203205479.png" alt="image-20221128144957798"></p><ul><li>回边计数器（Back Edge Counter“回边”的意思就是指在循环边界往回跳转）<ul><li><strong>在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，很显然建立回边计数器统计的目的是为了触发栈上的替换编译</strong></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128104046824.png" alt="image-20221128145018987"></p><ul><li><strong>当一个方法被调用时</strong>，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求</li><li><strong>当解释器遇到一条回边指令时</strong>，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</li><li>（程序是并行执行的而并不是傻傻的等着编译器）如果没有做过任何设置，执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了</li></ul></li><li><p>计数的衰减</p><ul><li>方法调用计数器：统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的</li><li>回边计数器：与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程</li></ul></li></ul></li><li><p><strong>编译过程</strong>（TODO 11.2.3）</p></li><li><p><strong>提前编译</strong></p><ul><li>现在提前编译产品和对其的研究有着两条明显的分支，<ul><li><strong>传统静态</strong>：一条分支是做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作；<ul><li>这是传统的提前编译应用形式，它在Java中存在的价值直指即时编译的最大弱点：<strong>即时编译要占用程序运行时间和运算资源</strong>，而提前编译由于提前性，所以可以使用大量的时间来进行优化</li></ul></li><li><strong>动态缓存</strong>：另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用<ul><li>本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。这种提前编译被称为动态提前编译（DynamicAOT）或者索性就大大方方地直接叫即时编译缓存（JIT Caching）</li><li>动态缓存存在的<strong>弊端</strong>为：提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定，以及其为了提高本身的兼容性，无法做一些激进的优化操作</li></ul></li></ul></li><li>由于提前编译可以有重负荷的编译过程优势，但是<strong>JIT依旧尤其独特的优势</strong><ul><li><strong>性能分析制导优化（Profile-Guided Optimization，PGO）</strong>上一节介绍HotSpot的即时编译器时就多次提及在解释器或者客户端编译器运行过程中，会不断收集性能监控信息，譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解，最多只能依照一些启发性的条件去进行猜测。但在动态运行时却能看出它们具有非常明显的偏好性。如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它</li><li><strong>激进预测性优化（Aggressive Speculative Optimization）</strong>，这也已经成为很多即时编译优化措施的基础。静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果）与优化前是等效的，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度</li><li><strong>链接时优化（Link-Time Optimization，LTO）</strong>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码，这类事情在Java程序员眼里看起来毫无违和之处。但如果类似的场景出现在使用提前编译的语言和程序上，譬如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。这是因为<strong>主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码</strong>。这些代码的作者、编译的时间，以及编译器甚至很可能都是不同的，当出现跨链接库边界的调用时，那些理论上应该要做的优化——譬如做对调用方法的内联，就会执行起来相当的困难</li></ul></li></ul></li><li><p><strong>编译优化技术</strong></p><ul><li>OpenJDK的官方Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、即时编译器中采用的优化技术列表（见P556）</li><li>前提：<strong>即时编译器对这些代码优化变换是建立在代码的中间表示或者是机器码之上的，绝不是直接在Java源码上去做的</strong></li><li>常见编译优化技术<ul><li>方法内联（方法替换）<ul><li>优点：一是去除方法调用的成本（如查找方法版本、建立栈帧等）；二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。因此各种编译器一般都会把内联优化放在优化序列最靠前的位置</li></ul></li><li>冗余访问消除（Redundant Loads Elimination）<ul><li>如果删除某段代码不会影响最终这个方法的返回结果，则删除</li></ul></li><li>复写传播（Copy Propagation）<ul><li>如果A变量不需要使用B变量间接表达，则删除B</li></ul></li><li>无用代码消除（Dead Code Elimination）<ul><li>无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”</li></ul></li></ul></li><li>代表性编译优化：<ul><li>最重要的优化技术之一：方法内联<ul><li>方法内联重要且是其它优化技术的前提但是在java中本身很多代码是无法进行内联的</li><li><strong>无法内联的原因</strong>其实在第8章中讲解Java方法解析和分派调用的时候就已经解释过：只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，简而言之，Java语言中默认的实例方法是虚方法。对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个方法版本，如果不依赖上下文，是无法确定b的实际类型是什么的。假如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是执行父类的get()方法还是子类的get()方法，这应该是根据实际类型动态分派的，而实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论。更糟糕的情况是，由于Java提倡使用面向对象的方式进行编程，而Java对象的方法默认就是虚方法，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知，内联与虚方法之间会产生“矛盾”，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键字来修饰，但Java选择了在虚拟机中解决这个问题。</li></ul></li><li>最前沿的优化技术之一：逃逸分析</li><li>语言无关的经典优化技术之一：公共子表达式消除</li><li>语言相关的经典优化技术之一：数组边界检查消除</li></ul></li></ul></li></ul><h2 id="第十二章：Java内存模型和线程"><a href="#第十二章：Java内存模型和线程" class="headerlink" title="第十二章：Java内存模型和线程"></a>第十二章：Java内存模型和线程</h2><ul><li><p>每秒事务处理数（Transactions Per Second，TPS）</p></li><li><p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化</p></li><li><p>JMM的意义：屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序</p></li><li><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数</p></li><li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory），线程又各自拥有不同的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系</p></li><li><p>java堆中保存的数据</p><ul><li>对于HotSpot虚拟机来讲，Java堆保存了实例数据，Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）、Klass Point（指向存储类型元数据的指针）及一些用于字节对齐补白的填充数据</li></ul></li><li><p>JMM定义了工作内存和主内存交换数据通过lock,unlock,read,load,use,assign,store,write八种基本操作（这八种操作都是原子性的），后为了简化，将其简化为read、write、lock和unlock四种，并且将处理时需要满足的条件简化为happen-before原则</p></li><li><p>volatile</p><ul><li>volatile是Java虚拟机提供的最轻量级的同步机制，保证可见性可以作为通知变量使用</li><li>volatile作用<ul><li>保证变量具有可见性（A线程更改后B线程能立马得知）</li><li>禁止指令重排序优化，通过添加内存屏障，使得重排序时不能把后面的指令重排序到内存屏障之前的位置</li></ul></li><li>虽然变量具有可见性，但由于递增运算并不是原子性的（根本原因在于Java里面的运算操作符并非原子操作），从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中</li><li>注意字节码也不一定是原子操作：一条字节码指令在解释执行时，解释器要运行许多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令</li><li>volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少</li><li>针对long和double型变量的特殊规则，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）但实际上64位机上不会出现问题，32位机上出现这种问题也十分罕见，所以不用因为这个原因专门声明对应volatile变量</li></ul></li><li><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的</p><ul><li><p>原子性：</p><ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）</li><li>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了<strong>lock和unlock操作</strong>来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令<strong>monitorenter和monitorexit</strong>来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性</li></ul></li><li><p>可见性：</p><ul><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。<strong>普通变量与volatile变量的区别</strong>是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li><li>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</li></ul></li><li><p>有序性</p><ul><li>Java程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</strong><ul><li>前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics）</li><li>后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li></ul></li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul></li><li><p>happen-before原则</p><ul><li><p>“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，<strong>线程是否安全</strong>的非常有用的手段，避免通过苦涩复杂的JMM来判断线程是否安全</p></li><li><p>定义：操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等（所以先行发生不意味着时间上真的先运行）</p></li><li><p>如果两个操作之间的关系不在happen-before原则中，并且无法从下列规则推导出来，则它们就没有顺序性保障，<strong>虚拟机可以对它们随意地进行重排序</strong>（简言之happen-before原则可以作为判断是否能重排序的规则（能重排序不代表一定重排序））</p></li><li><p>注意先行发生原则和时间没有关系，二者互不影响，详细见下分析</p><ul><li>示例一（先执行的不一定先行发生）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128144957798.png" alt="image-20221125203205479"></p><ul><li>线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么?    答案：可能是0，也有可能是1</li><li>分析：由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的</li><li>解决方法：<ul><li>要么把getter&#x2F;setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；</li><li>要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系</li></ul></li><li>示例二（满足先行发生的不一定真的时间上先发生）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128145018987.png" alt="image-20221125203607563"></p><ul><li>根据程序次序规则，“int i&#x3D;1”的操作先行发生于“int j&#x3D;2”，但是“int j&#x3D;2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这一点</li></ul></li></ul></li><li><p>线程相关</p><ul><li><p>Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java类库API中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现（恰好也是java线程是映射到系统线程的体现）</p></li><li><p>实现线程主要有三种方式</p><ul><li><p><strong>使用内核线程实现（1：1实现）</strong></p><ul><li>使用内核线程实现的方式也被称为1：1实现。<strong>内核线程（Kernel-Level Thread，KLT）</strong>就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过<strong>操纵调度器（Scheduler）</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上</li><li>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）</li><li>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——<strong>轻量级进程（LightWeight Process，LWP）</strong>，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型<ul><li>PS：概念上只要不是内核线程都应该被视为用户线程，但LWP是映射在KLT上的，不具有一般意义上的用户线程优点，故仍然被视为内核线程</li></ul></li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125192746870.png" alt="image-20221125192746870" style="zoom:67%;" /><ul><li>优点：<ul><li>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作</li></ul></li><li>局限性：<ul><li>线程切换代价大：由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，<strong>需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换</strong></li><li>线程的数量有限：每个轻量级进程都需要有一个内核线程的支持，因此<strong>轻量级进程要消耗一定的内核资源</strong>（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的</li></ul></li></ul></li><li><p><strong>使用用户线程实现（1：N实现）</strong></p><ul><li>优点：狭义上的用户线程指的是完全建立在用户空间的线程库上，<strong>系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量</strong>，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型</li><li>局限性：成也萧何败也萧何，用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如<strong>“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂，除了有明确的需求外（譬如以前在不支持多线程的操作系统中的多线程程序、需要支持大规模线程数量的应用），一般的应用程序都不倾向使用用户线程。</strong>Java、Ruby等语言都曾经使用过用户线程，最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如Golang、Erlang等，使得用户线程的使用率有所回升</li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125194107906.png" alt="image-20221125194122388" style="zoom:67%;" /></li><li><p><strong>使用用户线程加轻量级进程混合实现（N：M实现）</strong></p><ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现式，被称为N：M实现。在这种混合实现下，<strong>既存在用户线程，也存在轻量级进程</strong>。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，<strong>这大大降低了整个进程被完全阻塞的风险</strong>。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N：M的关系，如图12-5所示，这种就是多对多的线程模型</li><li>总结兼具了以上两种特点，能够使用灵活的用户线程，同时有轻量级进程不容易导致进程完全阻塞的优点<ul><li>N和M，在于可以有多个UT绑定在LWP上，也可以只有UT绑定在LWP上</li></ul></li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125200903780.png" alt="image-20221125194107906" style="zoom:67%;" /></li><li><p>java线程的实现</p><ul><li>JDK 1.2以前：早期的Classic虚拟机上是基于一种被称为“绿色线程”（Green Threads）的用户线程实现的</li><li>从JDK 1.3起：“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型（当然也有其他虚拟就采用另外两种线程实现方式）</li></ul></li><li><p>java线程特点</p><ul><li>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</li><li>由于线程实现很大程度上取决于操作系统的实现，所以java虚拟机规范实际上并不在意是如何实现的，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的（看不见的，无所谓的）</li></ul></li></ul></li><li><p>java线程调度方式（线程调度是指系统为线程分配处理器使用权的过程）</p><ul><li><strong>协同式（Cooperative Threads-Scheduling）线程调度</strong><ul><li>优点：<ul><li>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题</li></ul></li><li>缺点：<ul><li>线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的Windows 3.x系统就是使用协同式来实现多进程多任务的，那是相当不稳定的，只要有一个进程坚持不让出处理器执行时间，就可能会导致整个系统崩溃</li></ul></li></ul></li><li><strong>抢占式（Preemptive Threads-Scheduling）线程调度（java的实现方式）</strong><ul><li>特点：<ul><li>线程的切换，运行时间都是由系统控制的，线程可以调用Thread::yield()方法主动让出运行时间，但是不能通过线程本身获取运行时间，在这种调度方式下不会有线程导致系统崩溃问题</li><li>虽然线程的调度是系统控制的，但是我们可以使用线程优先级来”建议“系统对于线程的青睐，Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）<ul><li>优先级本身依赖于操作系统的实现，Solaris中线程有2147483648（2的31次幂）种优先级，但Windows中就只有七种优先级，所以可能存在一对多，多对一的情况</li><li>优先级本身不靠谱的原因<ul><li>由于优先级的映射问题，可能多个java优先级实际上映射的是同一个系统优先级</li><li>线程调度本质还是系统控制，系统可能因为优化等原因“擅自”改变运行顺序，如在Windows系统中存在一个叫“优先级推进器”的功能（Priority Boosting，当然它可以被关掉），大致作用是当系统发现一个线程被执行得特别频繁时，可能会越过线程优先级去为它分配执行时间，从而减少因为线程频繁切换而带来的性能损耗</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>java线程的状态转化</p><ul><li>Java语言定义了6种线程状态，在任意一个时间点中，<strong>一个线程只能有且只有其中的一种状态</strong>，并且可以通过特定的方法在不同状态之间转换</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125194122388.png" alt="image-20221125200903780"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125200921258.png" alt="image-20221125200921258"></p></li></ul></li><li><p>java和协程</p><ul><li>Java语言抽象出来隐藏了各种操作系统线程差异性的统一线程接口，这本是其优势，但是由于高并发场景的出现，这种模式出现了一些弊病</li><li>现代B&#x2F;S系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在<strong>减少单个服务复杂度、增加复用性</strong>的同时，也不可避免地<strong>增加了服务的数量</strong>，缩短了留给每个服务的响应时间。这要求每一个服务都必须在<strong>极短的时间</strong>内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待</li><li>微服务架构下，java略显疲态：Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，<strong>但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限</strong>。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费</li></ul></li><li><p>切换内核线程为什么比切换用户线程成本要高？</p><ul><li>内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于<strong>响应中断、保护和恢复执行现场的成本</strong>，假设发生了  “  线程A -&gt; 系统中断 -&gt; 线程B  “ 过程</li><li>处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。</li><li>而这里说的<strong>“上下文”</strong><ul><li>以<strong>程序员</strong>的角度来看，是<strong>方法调用过程中的各种局部的变量与资源</strong>；</li><li>以<strong>线程</strong>的角度来看，是<strong>方法的调用栈中存储的各类信息</strong>；</li><li>而以<strong>操作系统和硬件</strong>的角度来看，则是<strong>存储在内存、缓存和寄存器中的一个个具体数值</strong>。</li></ul></li><li>物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作</li></ul></li><li><p>使用用户线程（协程）的好处</p><ul><li>如果说内核线程的切换开销是来自于保护和恢复现场的成本，那如果改为采用用户线程，这部分开销就能够省略掉吗？答案是“不能”。但是，一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上，那我们就可以打开脑洞，通过玩出很多新的花样来缩减这些开销</li><li>由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。又由于<strong>这时候的协程会完整地做调用栈的保护、恢复工作</strong>（自己调度上下文的保护，恢复工作），所以今天也被称为“有栈协程”（Stackfull Coroutine），起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine）区分开。无栈协程不是本节的主角，不过还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限</li><li>协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多，在不进行特殊设定的情况下，则在64位Linux上HotSpot的线程栈容量默认是1MB，此外内核数据结构（Kernel Data Structures）还会额外消耗16KB内存。与之相对的，一个协程的栈通常在几百个字节到几KB之间</li></ul></li><li><p>使用用户线程（协程）的弊端</p><ul><li>协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多</li><li>协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单。不过有不少资料上显示，既然取了“协程”这样的名字，它们之间就一定以协同调度的方式工作（并不绝对，反例并不少见）</li></ul></li><li><p>java实现协程的难点</p><ul><li>到Java语言，还会有一些别的限制，譬如HotSpot这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如Kotlin提供的协程实现，一旦遭遇synchronize关键字，那挂起来的仍将是整个线程</li></ul></li></ul></li></ul><h2 id="第十三章：线程安全与锁优化"><a href="#第十三章：线程安全与锁优化" class="headerlink" title="第十三章：线程安全与锁优化"></a>第十三章：线程安全与锁优化</h2><ul><li><p>线程安全：</p><ul><li>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的</li></ul></li><li><p>可操作的数据的安全状态（从强到弱）</p><ul><li><strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong></li><li>不可变：<ul><li>“不可变”带来的安全性是最直接、最纯粹的</li><li>在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及java.lang.Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型。但同为Number子类型的原子类AtomicInteger和AtomicLong则是可变的（TODO 为什么这两个是可变的）</li></ul></li><li>绝对线程安全（TODO 和相对线程安全的对比）：</li><li>相对线程安全：<ul><li>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</li><li>在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等</li></ul></li><li>线程兼容：<ul><li>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等</li></ul></li><li>线程对立<ul><li>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</li></ul></li></ul></li><li><p>线程安全的实现方法：</p><ul><li><p><strong>一、互斥同步：</strong></p><ul><li>是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的</li><li>互斥同步的应用<ul><li>synchronized关键字<ul><li>最常见的互斥同步的应用是<strong>synchronized关键字</strong>，这是一种块结构（BlockStructured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成<strong>monitorenter和monitorexit</strong>这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<strong>如果Java源码中的synchronized明确指定了对象参数</strong>，那就以<strong>这个对象的引用作为reference</strong>；<strong>如果没有明确指定</strong>，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是<strong>取代码所在的对象实例还是取类型对应的Class对象</strong>来作为线程要持有的锁</li><li>根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</li><li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li><li>synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作（在一些简单的方法中使用synchronized方法可能本身运行的时间还赶不上切换线程的消耗）。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中</li></ul></li><li>重入锁（ReentrantLock）<ul><li>java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，是各种锁的实现基础</li><li>重入锁（ReentrantLock）是Lock接口最常见的一种实现，顾名思义，<strong>它与synchronized一样是可重入的</strong>。在基本用法上，<strong>ReentrantLock也与synchronized很相似</strong>，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：<ul><li><strong>等待可中断：</strong>是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量</li><li><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li></ul></li><li>ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，看起来好像完爆synchronized，但还是在两者都能使用的时候选择synchronized，原因如下<ul><li><strong>简单易用：</strong>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized</li><li><strong>保证释放资源：</strong>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放</li><li><strong>synchronized更好优化的天性：</strong>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>二、非阻塞同步</strong></p><ul><li><p>互斥同步面临的主要问题是<strong>进行线程阻塞和唤醒</strong>所带来的性能开销，因此这种同步也被称为<strong>阻塞同步</strong>（Blocking Synchronization）。从解决问题的方式上看，互斥同步属于一种悲观的并发策略，<strong>其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）</strong>，这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展，我们已经有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>，<strong>通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为<strong>非阻塞同步（Non-Blocking Synchronization）</strong>，使用这种措施的代码也常被称为<strong>无锁（Lock-Free）编程</strong></p></li><li><p>要求操作和冲突检测这两个步骤具备原子性。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所以我们只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：（无论硬件底层使用的命令类型如何，最终暴露出来的都是CAS操作）</p><ul><li>在IA64、x86指令集中有用cmpxchg指令完成的CAS功能，</li><li>在SPARC-TSO中也有用casa指令实现的，</li><li>而在ARM和PowerPC架构下，则需要使用一对ldrex&#x2F;strex指令来完成LL&#x2F;SC的功能</li></ul></li><li><p><strong>CAS指令</strong>需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断</p></li><li><p>在java9之前，是不允许用户调用Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供CAS操作的HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了（并发包中的整数原子类的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS），由于Unsafe类中的方法限定了只有启动类加载器加载的类才能调用CAS操作，所以在JAVA9之前除非使用反射这样的奇技淫巧否则无法调用，直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作</p></li><li><pre><code class="java">//1.8中的incrementAndGet方法public final int incrementAndGet() &#123;        return U.getAndAddInt(this, VALUE, 1) + 1;    &#125;public final int getAndAddInt(Object o, long offset, int delta) &#123;        int v;        do &#123;  //不断进行CAS操作            v = getIntVolatile(o, offset);        &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));        return v;    &#125;    public final boolean weakCompareAndSetInt(Object o, long offset,                                              int expected,                                              int x) &#123;        return compareAndSetInt(o, offset, expected, x);    &#125;//本地方法public final native boolean compareAndSetInt(Object o, long offset,                                                 int expected,                                                 int x);</code></pre></li><li><p>ABA问题：J.U.C包为了解决这个问题（版本号或者时间戳），提供了一个<strong>带有标记的原子引用类AtomicStampedReference</strong>，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类处于相当鸡肋的位置，<strong>大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效</strong></p></li></ul></li><li><p><strong>三、无同步方法</strong></p><ul><li>解决线程安全的根源，即避免出现线程不安全的情况</li><li>常见应用<ul><li><strong>可重入代码（Reentrant Code）：</strong><ul><li>这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，<strong>可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。</strong></li><li>特点：不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等</li><li>判断方式：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的（醉了，实际上就是对重用这个词解释了一下）</li></ul></li><li><strong>线程本地存储（Thread Local Storage）：</strong><ul><li>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。（既然临界数据会导致线程不安全的问题，那么我干脆放到同一个线程中）</li><li>实际应用：<strong>大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式</strong>，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题</li><li>声明一个多线程共享的变量可以使用volatile修饰符，声明一个变量为线程独有的可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量</li></ul></li></ul></li></ul></li></ul></li><li><p>锁优化技术</p><ul><li><p>为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率引入了许多锁优化技术，适应性自旋（Adaptive Spinning）、锁消除（LockElimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（BiasedLocking）等</p></li><li><p><strong>自旋锁：</strong></p><ul><li>由于线程本身的切换开销很大，所以当某个线程请求锁的时候无法成功时，不将这个锁进行挂起而是让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋）</li><li>适用场景：自旋等待时间短，不适合自旋等待时间长的情况（这种情况考虑使用自适应自旋）</li><li>使用参数：<ul><li>-XX：+UseSpinning参数来开启，在JDK 6中就已经改为默认开启了</li><li>-XX：PreBlockSpin来自行更改自旋的次数，默认是10次</li></ul></li><li>自适应自旋<ul><li>自适应意味着自旋的时间不再是固定的了，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态</strong>来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了</li></ul></li></ul></li><li><p><strong>锁消除</strong></p><ul><li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行</li><li>同步代码块的出现频率实际上很高，即使用户没有显示的调用同步代码，实际上在运行过程中也是有很多同步代码和同步代码块优化</li><li>应用场景<ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126130001272.png" alt="image-20221126125054413"></li></ul></li></ul></li><li><p><strong>锁粗化</strong></p><ul><li>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围<strong>限制得尽量小</strong>——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁</li><li>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗</li><li>应用场景：连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了</li></ul></li><li><p><strong>轻量级锁</strong></p><ul><li>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点<strong>，轻量级锁并不是用来代替重量级锁的，</strong>它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li><li>轻量级锁是基于对于对象的Mark Word 实现的，而轻量级锁的加锁解锁操作实际上都是基于CAS实现的</li><li>Mark Word：是一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125628190.png" alt="image-20221126125628190"></p><ul><li><p><strong>轻量级锁的工作流程</strong></p><ul><li>1、在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125826690.png" alt="image-20221126125826690"></p><ul><li>2、然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图13-4所示<ul><li><strong>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。</strong>虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125054413.png" alt="image-20221126130001272"></p><ul><li>3、轻量级锁的解锁过程（把原本存在栈帧中的Mark Word换回来）：上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程</li></ul></li><li><p>轻量级锁的应用分析：</p><ul><li>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在<strong>有竞争</strong>的情况下，轻量级锁反而会比传统的重量级锁更慢（适用于竞争量真的小的情况）</li></ul></li></ul></li><li><p><strong>偏向锁</strong></p><ul><li>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了（我摊牌了，我就赌所有的操作一般都不会有并发请求，所以我偏向第一个获取锁的线程，直到有别的线程来读取这个对象我才进行相关同步操作）</li><li>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</li><li>假设当前虚拟机启用了偏向锁（<strong>启用参数-XX：+UseBiased Locking，默认启动</strong>），<strong>那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作</strong>（例如加锁、解锁及对Mark Word的更新操作等）</li><li><strong>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126161740653.png" alt="image-20221126161740653"></p><ul><li><p>不用担心使用偏向锁时由于线程id和epoch的位置占据了hash值，因为线程ID和hashcode本身就是势不两立的</p><ul><li><p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求[1]时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁</p><p>的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码</p></li></ul></li><li><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能（和CAS操作有一样的弊端，如果这个资源真的是被多个线程并发处理的话，那么最好还是不要用偏向锁（多此一举））</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
