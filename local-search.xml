<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/2023LeetCode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/06/2023LeetCode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="33、搜索旋转后的数组"><a href="#33、搜索旋转后的数组" class="headerlink" title="33、搜索旋转后的数组"></a>33、搜索旋转后的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">//关键在于这种特殊二分的情况</span><br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= nums[mid]) &#123; <span class="hljs-comment">//在左半拉</span><br>                <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//左左</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//在右半拉</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="45、跳跃游戏"><a href="#45、跳跃游戏" class="headerlink" title="45、跳跃游戏"></a>45、跳跃游戏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">maxPosition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里注意，只需要跳到最后一个位子即可</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>           maxPosition = Math.max(maxPosition, i + nums[i]);<span class="hljs-comment">//设定此时能够跳转到的最大值</span><br>           <span class="hljs-keyword">if</span> (i == end) &#123;<br>               end = maxPosition;<br>               steps++;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> steps;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="71、简化路径"><a href="#71、简化路径" class="headerlink" title="71、简化路径"></a>71、简化路径</h3><ul><li>将给定的包含冗杂字符串进行处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplifyPath</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-comment">//对输入的字符串进行切分</span><br>        String[] names = path.split(<span class="hljs-string">&quot;/&quot;</span>);<br>        Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-comment">//注意当字符串为空字符串和为单个点的时候不需要进行处理</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;..&quot;</span>.equals(name)) &#123;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                    stack.pollLast();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-string">&quot;.&quot;</span>.equals(name)) &#123;<br>                <span class="hljs-comment">//实际上就是往末尾添加元素</span><br>                stack.offerLast(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>            ans.append(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                ans.append(<span class="hljs-string">&#x27;/&#x27;</span>);<br>                ans.append(stack.pollFirst());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="89、格雷编码"><a href="#89、格雷编码" class="headerlink" title="89、格雷编码"></a>89、格雷编码</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230223111104766.png" alt="image-20230223111104766"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>            ret.add((i &gt;&gt; <span class="hljs-number">1</span>) ^ i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="93、ip地址复原"><a href="#93、ip地址复原" class="headerlink" title="93、ip地址复原"></a>93、ip地址复原</h3><ul><li>给定由ip的字符串来确定点号的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">restoreIpAddresses93</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEG_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-comment">//由于有四段数字</span><br>    <span class="hljs-comment">//这里很巧妙的使用了共享的数组进行存储，由于每一次dfs实际上只会有一种情况被输出，所以即使又被重新覆盖也无所谓</span><br>    <span class="hljs-type">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br>        dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> segId, <span class="hljs-type">int</span> segStart)</span> &#123;<br>        <span class="hljs-comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span><br>        <span class="hljs-keyword">if</span> (segId == SEG_COUNT) &#123;<br>            <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ipAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SEG_COUNT; ++i) &#123;<br>                    ipAddr.append(segments[i]);<br>                    <span class="hljs-keyword">if</span> (i != SEG_COUNT - <span class="hljs-number">1</span>) &#123;<br>                        ipAddr.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                    &#125;<br>                &#125;<br>                ans.add(ipAddr.toString());<br>            &#125;<br>            <span class="hljs-comment">//如果找完了第四段但是还有剩余的数字没有使用，则说明遍历完全进行返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯(该终止了)</span><br>        <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span><br>        <span class="hljs-keyword">if</span> (s.charAt(segStart) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            segments[segId] = <span class="hljs-number">0</span>;<br>            dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 一般情况，枚举每一种可能性并递归</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">segEnd</span> <span class="hljs-operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;<br>            <span class="hljs-comment">//注意这里没有简单的使用字符串转数字的方式（效率过低）</span><br>            addr = addr * <span class="hljs-number">10</span> + (s.charAt(segEnd) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">//如果满足当前ip条件</span><br>            <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span>) &#123;<br>                segments[segId] = addr;<br>                dfs(s, segId + <span class="hljs-number">1</span>, segEnd + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="172、阶乘后的0的位数"><a href="#172、阶乘后的0的位数" class="headerlink" title="172、阶乘后的0的位数"></a>172、阶乘后的0的位数</h3><ul><li>实际上就是在算5*2组合的个数，但是由于2出现的频率远高于5，所以实际上相当于计算5的个数</li><li>并且由于25可以拆成5*5，所以要将每25出现的这个数看成两个，同理125看成三个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        count += n / <span class="hljs-number">5</span>;<br>        n = n / <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="209、长度最小的子数组"><a href="#209、长度最小的子数组" class="headerlink" title="209、长度最小的子数组"></a>209、长度最小的子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">change</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//这里注意讨论处理没有修改结果返回初始值的情况</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (rightIndex &lt; nums.length) &#123;<br>        sum += nums[rightIndex];<br>        rightIndex++;<br>        <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>            sum -= nums[leftIndex];<br>            leftIndex++;<br>            res = Math.min(rightIndex - leftIndex + <span class="hljs-number">1</span>, res);<br>            change = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> change ? res : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="274、H指数"><a href="#274、H指数" class="headerlink" title="274、H指数"></a>274、H指数</h3><ul><li>论文的引用指数（求至少有N个论文引用次数大于N）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        Arrays.sort(citations);<br>    <span class="hljs-comment">//注意这里需要使用h来记录下来有多少个论文满足</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = citations.length - <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; citations[i] &gt; h) &#123;<br>            h++; <br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><span class="hljs-comment">//上面这种思路的错误写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        Arrays.sort(citations);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">//大于并不意味着一定有对应的次数</span><br>            <span class="hljs-keyword">if</span> (length - i &gt;= citations[i]) &#123;<br>                <span class="hljs-keyword">return</span> citations[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//计数排序，效率更高，但是使用更多的内存</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length, tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//记录下对应的论文引用次数的论文数</span><br>        <span class="hljs-type">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//如果大于论文数量的引用次数就加给最大值（因为H指数不可能大于论文数量）</span><br>            <span class="hljs-keyword">if</span> (citations[i] &gt;= n) &#123;<br>                counter[n]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter[citations[i]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tot += counter[i];<br>            <span class="hljs-keyword">if</span> (tot &gt;= i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="275、H指数2"><a href="#275、H指数2" class="headerlink" title="275、H指数2"></a>275、H指数2</h3><ul><li>上一题给定的数组变成升序排列（有序就考虑使用二分查找）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (citations[mid] &gt;= n - mid) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//注意这里返回的是对应的数量而不是对应的值</span><br>        <span class="hljs-keyword">return</span> n - left;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="475、供暖器"><a href="#475、供暖器" class="headerlink" title="475、供暖器"></a>475、供暖器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRadius</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span>[] heaters)</span> &#123;<br>        Arrays.sort(houses);<br>        Arrays.sort(heaters);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里注意供暖器只进行一次遍历，因为如果前一个房屋选择了当前供暖器，那么下一个房屋一定会离上一个供暖器更远，所以不需要考虑上一个供暖器</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curDistance</span> <span class="hljs-operator">=</span> Math.abs(houses[i] - heaters[j]);<br>            <span class="hljs-comment">//如果后面的供暖器更近，则用后面的供暖器</span><br>            <span class="hljs-keyword">while</span> (j &lt; heaters.length - <span class="hljs-number">1</span> &amp;&amp; Math.abs(houses[i] - heaters[j]) &gt;= Math.abs(houses[i] - heaters[j + <span class="hljs-number">1</span>])) &#123;<br>                j++;<br>                curDistance = Math.min(curDistance, Math.abs(houses[i] - heaters[j]));<br>            &#125;<br>            ans = Math.max(ans, curDistance);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="701、二叉树中的插入操作"><a href="#701、二叉树中的插入操作" class="headerlink" title="701、二叉树中的插入操作"></a>701、二叉树中的插入操作</h3><ul><li>给定一个BST，给定一个数据，将数据插入BST并且保证插入后仍为BST</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &lt; val) &#123;<br>            <span class="hljs-comment">//注意这里需要进行赋值操作来保证二叉树确实被修改了</span><br>            root.right = insertIntoBST(root.right, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root.left = insertIntoBST(root.left, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="752、打开转盘锁"><a href="#752、打开转盘锁" class="headerlink" title="752、打开转盘锁"></a>752、打开转盘锁</h3><ul><li>给定相应的不能出现的密码数组和需要组合的密码，返回能够达到密码的最小次数</li></ul><h3 id="933、最近的请求次数"><a href="#933、最近的请求次数" class="headerlink" title="933、最近的请求次数"></a>933、最近的请求次数</h3><ul><li>注意由于保证每次ping的time都比之前要大所以可以使用队列弹出然后舍弃</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RecentCounter933</span><span class="hljs-params">()</span> &#123;<br>    queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ping</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>    queue.offer(t);<br>    <span class="hljs-keyword">while</span> (queue.peek() &lt; t - <span class="hljs-number">3000</span>) &#123;<br>        queue.poll(); <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.size();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="941、有效的山脉数组"><a href="#941、有效的山脉数组" class="headerlink" title="941、有效的山脉数组"></a>941、有效的山脉数组</h3><ul><li>基本的线性扫描注意条件即可，这里选用了双指针的算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//从左边往右边找，一直找到山峰为止</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; len &amp;&amp; A[left] &lt; A[left + <span class="hljs-number">1</span>])<br>            left++;<br>        <span class="hljs-comment">//从右边往左边找，一直找到山峰为止</span><br>        <span class="hljs-keyword">while</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; A[right - <span class="hljs-number">1</span>] &gt; A[right])<br>            right--;<br>        <span class="hljs-comment">//判断从左边和从右边找的山峰是不是同一个</span><br>        <span class="hljs-keyword">return</span> left &gt; <span class="hljs-number">0</span> &amp;&amp; right &lt; len - <span class="hljs-number">1</span> &amp;&amp; left == right;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="984、不含AAA和BBB的字符串"><a href="#984、不含AAA和BBB的字符串" class="headerlink" title="984、不含AAA和BBB的字符串"></a>984、不含AAA和BBB的字符串</h3><ul><li>给定A的数量和 B的数量，返回不含AAA和BBB的字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用贪心算法，如果A多就用aab如果B多就用bba</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">strWithout3a3b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">while</span> (a &gt; b &amp;&amp; b &gt; <span class="hljs-number">0</span>) &#123; sb.append(<span class="hljs-string">&quot;aab&quot;</span>); --a; --a; --b; &#125;<br>        <span class="hljs-keyword">while</span> (b &gt; a &amp;&amp; a &gt; <span class="hljs-number">0</span>) &#123; sb.append(<span class="hljs-string">&quot;bba&quot;</span>); --b; --b; --a; &#125;<br>        <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span>) &#123; sb.append(<span class="hljs-string">&quot;ab&quot;</span>); --a; --b; &#125;<br>        <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span>) &#123; sb.append(<span class="hljs-string">&#x27;a&#x27;</span>); --a; &#125;<br>        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123; sb.append(<span class="hljs-string">&#x27;b&#x27;</span>); --b; &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1027、最长等差序列"><a href="#1027、最长等差序列" class="headerlink" title="1027、最长等差序列"></a>1027、最长等差序列</h3><h3 id="1129、颜色交替的最短路径"><a href="#1129、颜色交替的最短路径" class="headerlink" title="1129、颜色交替的最短路径"></a>1129、颜色交替的最短路径</h3><ul><li>实际上就是在BFS的基础上对于颜色变换进行计时</li><li>注意重写并且理解使用栈作为BFS的过程中介</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] shortestAlternatingPaths(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] redEdges, <span class="hljs-type">int</span>[][] blueEdges) &#123;<br>    <span class="hljs-comment">//这里注意不是list而是list的二维数组</span><br>       List&lt;Integer&gt;[][] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[<span class="hljs-number">2</span>][n];<span class="hljs-comment">//next是颜色和</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>               next[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : redEdges) &#123;<br>           next[<span class="hljs-number">0</span>][edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : blueEdges) &#123;<br>           next[<span class="hljs-number">1</span>][edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>       &#125;<br>       <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][n]; <span class="hljs-comment">// 两种类型的颜色最短路径的长度</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>           Arrays.fill(dist[i], Integer.MAX_VALUE);<br>       &#125;<br>       Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>       dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//到0的两种颜色的边的路径长度都是0</span><br>       dist[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>       queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//0表示下一步要走红色</span><br>       queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//1表示下一步要走蓝色</span><br>       <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>           <span class="hljs-type">int</span>[] pair = queue.poll();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">0</span>], t = pair[<span class="hljs-number">1</span>];<br>           <span class="hljs-comment">//遍历另外一种颜色能够到达的所有终点</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : next[<span class="hljs-number">1</span> - t][x]) &#123;<span class="hljs-comment">//t表示的是要走的颜色，这里也用到了避免使用ifelse的优化手段</span><br>               <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">1</span> - t][y] != Integer.MAX_VALUE) &#123;<span class="hljs-comment">//满足该条件则说明已经遍历过则不需要继续</span><br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               dist[<span class="hljs-number">1</span> - t][y] = dist[t][x] + <span class="hljs-number">1</span>;<br>               queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;y, <span class="hljs-number">1</span> - t&#125;);<br>           &#125;<br>       &#125;<br>       <span class="hljs-type">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>           answer[i] = Math.min(dist[<span class="hljs-number">0</span>][i], dist[<span class="hljs-number">1</span>][i]);<br>           <span class="hljs-keyword">if</span> (answer[i] == Integer.MAX_VALUE) &#123;<br>               answer[i] = -<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> answer;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h3 id="1138、字母版上的路径"><a href="#1138、字母版上的路径" class="headerlink" title="1138、字母版上的路径"></a>1138、字母版上的路径</h3><ul><li>这里注意由于z在单独的左下角，所以需要保证先运行左边在运行向下的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">alphabetBoardPath</span><span class="hljs-params">(String target)</span> &#123;<br>       <span class="hljs-comment">//这里实际上优先左上角移动</span><br>       <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; target.length(); i++) &#123;<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> target.charAt(i);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">curX</span> <span class="hljs-operator">=</span> (c - <span class="hljs-string">&#x27;a&#x27;</span>) / <span class="hljs-number">5</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">curY</span> <span class="hljs-operator">=</span> (c - <span class="hljs-string">&#x27;a&#x27;</span>) % <span class="hljs-number">5</span>;<br>           <span class="hljs-keyword">if</span> (curY &lt; y) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> y - curY;<br>               sb.append(<span class="hljs-string">&quot;L&quot;</span>.repeat(gap));<br>           &#125;<br>           <span class="hljs-keyword">if</span> (curX &gt; x) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> curX - x;<br>               sb.append(<span class="hljs-string">&quot;D&quot;</span>.repeat(gap));<br>           &#125;<br>           <span class="hljs-keyword">if</span> (curX &lt; x) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> x - curX;<br>               sb.append(<span class="hljs-string">&quot;U&quot;</span>.repeat(gap));<br>           &#125;<br>           <span class="hljs-keyword">if</span> (curY &gt; y) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> curY - y;<br>               sb.append(<span class="hljs-string">&quot;R&quot;</span>.repeat(gap));<br>           &#125;<br>           x = curX;<br>           y = curY;<br>           sb.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> sb.toString();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="1145、二叉树着色游戏"><a href="#1145、二叉树着色游戏" class="headerlink" title="1145、二叉树着色游戏"></a>1145、二叉树着色游戏</h3><ul><li>注意dfs的形式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, lsz, rsz;<br><br>    <span class="hljs-comment">//这里实际上一共就三种情况，先手结点的</span><br>    <span class="hljs-comment">//左子树</span><br>    <span class="hljs-comment">//右子树</span><br>    <span class="hljs-comment">//父节点子树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">btreeGameWinningMove</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(Math.max(lsz, rsz), n - <span class="hljs-number">1</span> - lsz - rsz) * <span class="hljs-number">2</span> &gt; n;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ls</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-comment">//如果node.val == x，则说明完全递归完成</span><br>        <span class="hljs-keyword">if</span> (node.val == x) &#123;<br>            lsz = ls;<br>            rsz = rs;<br>        &#125;<br>        <span class="hljs-comment">//父节点实际上就是两者+1</span><br>        <span class="hljs-comment">//每递归一层就会对其+1</span><br>        <span class="hljs-keyword">return</span> ls + rs + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1210、穿过迷宫的最小移动次数"><a href="#1210、穿过迷宫的最小移动次数" class="headerlink" title="1210、穿过迷宫的最小移动次数"></a>1210、穿过迷宫的最小移动次数</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230205155928444.png" alt="image-20230205155928444"></p><ul><li>具体的贪吃蛇移动路径图<ul><li><a href="https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solution/golang-bfs-by-resara-2/">golang BFS - 穿过迷宫的最少移动次数 - 力扣（LeetCode）</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用BFS求解，注意相比于简单的BFS，这里限制了蛇具有长度2，且为定长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] DIRS = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">vis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">var</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//其中0是横着的意思</span><br>        q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 初始位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; !q.isEmpty(); ++step) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> q;<br>            q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t : tmp) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> d : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> t[<span class="hljs-number">0</span>] + d[<span class="hljs-number">0</span>], y = t[<span class="hljs-number">1</span>] + d[<span class="hljs-number">1</span>], s = t[<span class="hljs-number">2</span>] ^ d[<span class="hljs-number">2</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> x + s, y2 = y + (s ^ <span class="hljs-number">1</span>); <span class="hljs-comment">// 蛇头</span><br>                    <span class="hljs-keyword">if</span> (x2 &lt; n &amp;&amp; y2 &lt; n &amp;&amp; !vis[x][y][s] &amp;&amp;<br>                        g[x][y] == <span class="hljs-number">0</span> &amp;&amp; g[x2][y2] == <span class="hljs-number">0</span> &amp;&amp; (d[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> || g[x + <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> step; <span class="hljs-comment">// 此时蛇头一定在 (n-1,n-1)</span><br>                        vis[x][y][s] = <span class="hljs-literal">true</span>;<br>                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, s&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1223、掷骰子模拟"><a href="#1223、掷骰子模拟" class="headerlink" title="1223、掷骰子模拟"></a>1223、掷骰子模拟</h3><ul><li><a href="https://leetcode.cn/problems/dice-roll-simulation/solution/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-sje6/">教你一步步思考动态规划！（Python&#x2F;Java&#x2F;C++&#x2F;Go） - 掷骰子模拟 - 力扣（LeetCode）</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划待补充</span><br><br><span class="hljs-comment">//方法一：递归和记忆化搜索</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">//为了保证每次递归过程中使用的都是同一个数组，需要定义在类变量中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] rollMax;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][][] cache;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] rollMax)</span> &#123;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">this</span>.rollMax = rollMax;<br>        <span class="hljs-comment">//因为题目规定骰子有六个面，并且最多只能投掷15次</span><br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">6</span>][<span class="hljs-number">15</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; ++j)<br>                <span class="hljs-comment">//这里的cache[i][j]是一个数组，这里使用Arrays.fill填充</span><br>                Arrays.fill(cache[i][j], -<span class="hljs-number">1</span>); <span class="hljs-comment">// -1 表示没有访问过</span><br>        <span class="hljs-comment">//DFS开始(六个都需要遍历)</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//由于这里计算的是种类而不是数字，所以使用 0到5 和使用 1到6 效果一样</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            res += dfs(n - <span class="hljs-number">1</span>, i, rollMax[i] - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % MOD);<br>    &#125;<br><br>    <span class="hljs-comment">//i:剩余能够投掷的次数</span><br>    <span class="hljs-comment">//last：上一个投掷的数字</span><br>    <span class="hljs-comment">//left：上一个数字还能投掷的次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> last, <span class="hljs-type">int</span> left)</span> &#123;<br>        <span class="hljs-comment">//应该跳出的情况</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//这里的0 实际表示的是最后一次投掷</span><br>            <span class="hljs-comment">//自然是最后一种</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cache[i][last][left] &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> cache[i][last][left];<br>        &#125;<br>        <span class="hljs-comment">//继续递归的情况</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; rollMax.length; ++j)<br>            <span class="hljs-keyword">if</span> (j != last)<br>                res += dfs(i - <span class="hljs-number">1</span>, j, rollMax[j] - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>)<br>                res += dfs(i - <span class="hljs-number">1</span>, j, left - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//返回之前注意先存一下</span><br>        cache[i][last][left] = (<span class="hljs-type">int</span>) (res % MOD);<br>        <span class="hljs-keyword">return</span> cache[i][last][left];<br>    &#125;<br><br><span class="hljs-comment">//方法二、动态规划</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] rollMax)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> rollMax.length; <span class="hljs-comment">// 6</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(f[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>        s[<span class="hljs-number">0</span>] = m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> s[i - <span class="hljs-number">1</span>], mx = rollMax[j];<br>                <span class="hljs-keyword">if</span> (i &gt; mx) res -= s[i - mx - <span class="hljs-number">1</span>] - f[i - mx - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == mx) --res;<br>                f[i][j] = (res % MOD + MOD) % MOD; <span class="hljs-comment">// 防止出现负数</span><br>                s[i] = (s[i] + f[i][j]) % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="1233、删除子文件夹"><a href="#1233、删除子文件夹" class="headerlink" title="1233、删除子文件夹"></a>1233、删除子文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方解法 </span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> &#123;<br>        Arrays.sort(folder);<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ans.add(folder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; folder.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> ans.get(ans.size() - <span class="hljs-number">1</span>).length();<br>            <span class="hljs-keyword">if</span> (!(pre &lt; folder[i].length() &amp;&amp; ans.get(ans.size() - <span class="hljs-number">1</span>).equals(folder[i].substring(<span class="hljs-number">0</span>, pre)) &amp;&amp; folder[i].charAt(pre) == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                ans.add(folder[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-comment">//自己的解法（使用hashset代替原本的字符串排序）</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> &#123;<br>        Arrays.sort(folder, Comparator.comparingInt(String::length));<br>        HashSet&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; folder.length; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ifHave</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> folder[i];<br>            String[] strings = s.split(<span class="hljs-string">&quot;/&quot;</span>);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; strings.length; j++) &#123;<br>                stringBuilder.append(<span class="hljs-string">&quot;/&quot;</span>).append(strings[j]);<br>                <span class="hljs-keyword">if</span> (hashSet.contains(stringBuilder.toString())) &#123;<br>                    ifHave = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ifHave) &#123;<br>                hashSet.add(stringBuilder.toString());<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        List&lt;String&gt; res = Arrays.asList(hashSet.toArray());</span><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Object temp : hashSet.toArray()) &#123;<br>            res.add(temp.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1234、替换子串得到平衡字符串"><a href="#1234、替换子串得到平衡字符串" class="headerlink" title="1234、替换子串得到平衡字符串"></a>1234、替换子串得到平衡字符串</h3><ul><li>滑动窗口：之所以使用滑动窗口，<strong>是因为随着 <em>l</em> 的递增，r 也是递增的</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">balancedString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//要把多的变成缺少的，题目给定说字符串长度是四的倍数</span><br>        <span class="hljs-comment">//这里很巧妙的不是讨论总的字符串，而是讨论所有能替换的部分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">quarter</span> <span class="hljs-operator">=</span> s.length() / <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;X&#x27;</span>];<br>        Arrays.fill(count, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            count[c]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;Q&#x27;</span>] == quarter &amp;&amp; count[<span class="hljs-string">&#x27;W&#x27;</span>] == quarter &amp;&amp; count[<span class="hljs-string">&#x27;E&#x27;</span>] == quarter &amp;&amp; count[<span class="hljs-string">&#x27;R&#x27;</span>] == quarter)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 已经符合要求啦</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> s.length();<span class="hljs-comment">//注意待比较的最小值，初始值需要赋值可能情况的最大值</span><br>        <span class="hljs-keyword">for</span> (; r &lt; s.length(); r++) &#123;<br>            count[s.charAt(r)]--;<br>            <span class="hljs-keyword">while</span> (count[<span class="hljs-string">&#x27;Q&#x27;</span>] &lt;= quarter &amp;&amp; count[<span class="hljs-string">&#x27;W&#x27;</span>] &lt;= quarter &amp;&amp; count[<span class="hljs-string">&#x27;E&#x27;</span>] &lt;= quarter &amp;&amp; count[<span class="hljs-string">&#x27;R&#x27;</span>] &lt;= quarter) &#123;<br>                res = Math.min(res, r - l + <span class="hljs-number">1</span>);<br>                ++count[s.charAt(l++)]; <span class="hljs-comment">// 缩小子串</span><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1237、找出给定方程的解"><a href="#1237、找出给定方程的解" class="headerlink" title="1237、找出给定方程的解"></a>1237、找出给定方程的解</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230218173541243.png" alt="image-20230218173541243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSolution</span><span class="hljs-params">(CustomFunction customfunction, <span class="hljs-type">int</span> z)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, y = <span class="hljs-number">1000</span>; x &lt;= <span class="hljs-number">1000</span> &amp;&amp; y &gt;= <span class="hljs-number">1</span>; x++) &#123;<br>            <span class="hljs-keyword">while</span> (y &gt;= <span class="hljs-number">1</span> &amp;&amp; customfunction.f(x, y) &gt; z) &#123;<br>                y--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">1</span> &amp;&amp; customfunction.f(x, y) == z) &#123;<br>                List&lt;Integer&gt; pair = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                pair.add(x);<br>                pair.add(y);<br>                res.add(pair);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1238、循环码排列"><a href="#1238、循环码排列" class="headerlink" title="1238、循环码排列"></a>1238、循环码排列</h3><ul><li>实际上就是格雷码的变体</li><li>结果异或start的原因：<ul><li>因此对于数列(0,1,2,,…,2^n-1) ，我们可以依次根据转换公式得到这个数列的格雷码值，从而使相邻两个数的二进制只有一位不同。但是题目中有一个要求，首个数为start，而这里得到的首个数为0。<br>由于0与任何数异或的结果都是数本身，因此我们可以将start异或到0上。<br>同时，两个数的二进制只有一位不同，异或同一个数的结果，也只有一位不同（只有那不同的一位异或结果不同，其他位异或结果都一样），因此我们可以对整个格雷码数列都异或上start，从而保证相邻数的二进制形式不同，同时起始数为start</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>            ret.add((i &gt;&gt; <span class="hljs-number">1</span>) ^ i ^ start); <span class="hljs-comment">//注意异或了start</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br><span class="hljs-comment">//这里考虑用左右两个数列进行拼接，但是实际上不用</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        List&lt;Integer&gt; retRight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; retLeft  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (i &gt;&gt; <span class="hljs-number">1</span>) ^ i;<br>            <span class="hljs-keyword">if</span> (temp == start) &#123;<br>                retLeft.add(temp);<br>                <span class="hljs-keyword">for</span> (i = i + <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i++) &#123;<br>                    retLeft.add((i &gt;&gt; <span class="hljs-number">1</span>) ^ i);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            retRight.add(temp);<br>        &#125;<br>        retLeft.addAll(retRight);<br>        <span class="hljs-keyword">return</span> retLeft;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1408、数组中的字符串匹配"><a href="#1408、数组中的字符串匹配" class="headerlink" title="1408、数组中的字符串匹配"></a>1408、数组中的字符串匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">stringMatching</span><span class="hljs-params">(String[] words)</span> &#123;<br>        List&lt;String&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; words.length; j++) &#123;<br>                <span class="hljs-comment">//注意对应的javaAPI使用</span><br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; words[j].contains(words[i])) &#123;<br>                    ret.add(words[i]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1410、HTML解析器"><a href="#1410、HTML解析器" class="headerlink" title="1410、HTML解析器"></a>1410、HTML解析器</h3><ul><li>使用javaAPI来对字符串操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">entityParser</span><span class="hljs-params">(String text)</span> &#123;<br>       String reg1=<span class="hljs-string">&quot;&amp;quot;&quot;</span>;<br>       String reg2=<span class="hljs-string">&quot;&amp;apos;&quot;</span>;<br>       String reg3=<span class="hljs-string">&quot;&amp;amp;&quot;</span>;<br>       String reg4=<span class="hljs-string">&quot;&amp;gt;&quot;</span>;<br>       String reg5=<span class="hljs-string">&quot;&amp;lt;&quot;</span>;<br>       String reg6=<span class="hljs-string">&quot;&amp;frasl;&quot;</span>;<br>       <span class="hljs-keyword">return</span> text.replace(reg1,<span class="hljs-string">&quot;\&quot;&quot;</span>).replace(reg2,<span class="hljs-string">&quot;&#x27;&quot;</span>).replace(reg6,<span class="hljs-string">&quot;/&quot;</span>).replace(reg4,<span class="hljs-string">&quot;&gt;&quot;</span>).replace(reg5,<span class="hljs-string">&quot;&lt;&quot;</span>).replace(reg3,<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1414、和为K的最小斐波那契数字的数量"><a href="#1414、和为K的最小斐波那契数字的数量" class="headerlink" title="1414、和为K的最小斐波那契数字的数量"></a>1414、和为K的最小斐波那契数字的数量</h3><ul><li>贪心算法，计算得到次小于给定值的斐波那契数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinFibonacciNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//简单生成斐波那契数列</span><br>        List&lt;Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        f.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (a + b &lt;= k) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>            f.add(c);<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> f.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> f.get(i);<br>            <span class="hljs-comment">//尽可能的使用靠后的数字来组成</span><br>            <span class="hljs-keyword">if</span> (k &gt;= num) &#123;<br>                k -= num;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="1492、n的第k个因子"><a href="#1492、n的第k个因子" class="headerlink" title="1492、n的第k个因子"></a>1492、n的第k个因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthFactor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//实际还是从1开始递增判断是否为因子，唯一优化是在于平方处即可停止递归</span><br>        <span class="hljs-comment">// from start to sqrt(n)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(; i*i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span>((n%i == <span class="hljs-number">0</span>) &amp;&amp; (--k == <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(i * i != n) &#123;<br>            i --;<br>        &#125;<br>        <span class="hljs-comment">// from sqrt(n) again</span><br>        <span class="hljs-keyword">for</span>(; i &gt;= <span class="hljs-number">1</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span>((n%i == <span class="hljs-number">0</span>) &amp;&amp; (--k==<span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">return</span> n/i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1529、最小的后缀反转次数"><a href="#1529、最小的后缀反转次数" class="headerlink" title="1529、最小的后缀反转次数"></a>1529、最小的后缀反转次数</h3><ul><li>这里实际上就是在求有多少个连续的段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlips</span><span class="hljs-params">(String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//这只需要考虑有多少个不同的段即可</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; target.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> target.charAt(i);<span class="hljs-comment">//这里不好对want赋值，可以等到获取到下一个的时候再赋值</span><br>            <span class="hljs-keyword">if</span> (c != prev) &#123;  <span class="hljs-comment">//这里注意只需要一次次判断而不需要在if条件中使用while，徒增编写复杂度</span><br>                count++;<br>                prev = c;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1599、经营摩天轮的最大利润"><a href="#1599、经营摩天轮的最大利润" class="headerlink" title="1599、经营摩天轮的最大利润"></a>1599、经营摩天轮的最大利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">humanCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperationsMaxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] customers, <span class="hljs-type">int</span> boardingCost, <span class="hljs-type">int</span> runningCost)</span> &#123;<br>        <span class="hljs-comment">//注意这里需要输出的是达到最大利润时的次数而不是最大利润本身</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tempCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> customer : customers) &#123;<br>            humanCount += customer;<br>            temp += takeCount() * boardingCost - runningCost;<br>            tempCount++;<br>            <span class="hljs-keyword">if</span> (temp &gt; res) &#123;<br>                res = temp;<br>                resCount = tempCount;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//这里注意判断如果剩下的人没办法使得其为正利润则可以不继续了，但是这里俺没有优化</span><br>        <span class="hljs-keyword">while</span> (humanCount &gt; <span class="hljs-number">0</span>) &#123;<br>            temp += takeCount() * boardingCost - runningCost;<br>            tempCount++;<br>            <span class="hljs-keyword">if</span> (temp &gt; res) &#123;<br>                res = temp;<br>                resCount = tempCount;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">0</span> ? resCount : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">takeCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> humanCount &gt;= <span class="hljs-number">4</span> ? <span class="hljs-number">4</span> : humanCount % <span class="hljs-number">4</span>;<br>        humanCount -= count;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1604、企业的报警人名数"><a href="#1604、企业的报警人名数" class="headerlink" title="1604、企业的报警人名数"></a>1604、企业的报警人名数</h3><ul><li>注意这里的时间限制，注意整数控制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">alertNames</span><span class="hljs-params">(String[] keyName, String[] keyTime)</span> &#123;<br>    <span class="hljs-comment">//这里本身的想法是使用名称+时间组成的字符串做hashmap的键值</span><br>        <span class="hljs-comment">//然后使用对应的数字来存储同一时间段的个数，但是这种并不灵活，遂启用</span><br>        Map&lt;String, List&lt;Integer&gt;&gt; timeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;Integer&gt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> keyName.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> keyName[i]; <span class="hljs-comment">//这里只使用了name作为key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> keyTime[i];<br>            timeMap.putIfAbsent(name, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> (time.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (time.charAt(<span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minute</span> <span class="hljs-operator">=</span> (time.charAt(<span class="hljs-number">3</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (time.charAt(<span class="hljs-number">4</span>) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            timeMap.get(name).add(hour * <span class="hljs-number">60</span> + minute); <span class="hljs-comment">//统一计算成分钟存储</span><br>        &#125;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        Set&lt;String&gt; keySet = timeMap.keySet();<br>        <span class="hljs-keyword">for</span> (String name : keySet) &#123;<br>            List&lt;Integer&gt; list = timeMap.get(name);<br>            Collections.sort(list);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>            <span class="hljs-comment">//注意这个特殊的遍历形式，如果从0开始的话就需要判断i+2的边界条件了</span><br>            <span class="hljs-comment">//但是如果使用这种形式，如果不在边界条件外自动就不会进入循环</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> list.get(i - <span class="hljs-number">2</span>), time2 = list.get(i);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">difference</span> <span class="hljs-operator">=</span> time2 - time1;<br>                <span class="hljs-keyword">if</span> (difference &lt;= <span class="hljs-number">60</span>) &#123;<br>                    res.add(name);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        Collections.sort(res); <span class="hljs-comment">//默认就是字典序排序</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1653、使得字符串平衡的最小删除次数"><a href="#1653、使得字符串平衡的最小删除次数" class="headerlink" title="1653、使得字符串平衡的最小删除次数"></a>1653、使得字符串平衡的最小删除次数</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230306124458133.png" alt="image-20230306124458133"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230306124544305.png" alt="image-20230306124544305"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意使用分支预测后带来的显著性能提升</span><br><span class="hljs-comment">//基本思路，统计左右的AB数量即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumDeletions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">countA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">countB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                countA++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> countA;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                countA--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                countB++;<br>            &#125;<br>            res = Math.min(res, countB + countA);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//巧妙地使用了普适a和b的表达式来规避了if-else分支语句带来的性能开销</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumDeletions2</span><span class="hljs-params">(String S)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> S.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">del</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c : s)<br>            del += <span class="hljs-string">&#x27;b&#x27;</span> - c; <span class="hljs-comment">// 统计 &#x27;a&#x27; 的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> del;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c : s) &#123;<br>            <span class="hljs-comment">// &#x27;a&#x27; -&gt; -1    &#x27;b&#x27; -&gt; 1</span><br>            del += (c - <span class="hljs-string">&#x27;a&#x27;</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>            ans = Math.min(ans, del);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1663、具有给定数值的最小字符串"><a href="#1663、具有给定数值的最小字符串" class="headerlink" title="1663、具有给定数值的最小字符串"></a>1663、具有给定数值的最小字符串</h3><ul><li>在给定字符串的数值和长度的情况下求得对应的最小字典序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪心算法，尽可能使用当前能够使用的字典序最小的来组成 </span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSmallestString</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1</span>, k - (n - i) * <span class="hljs-number">26</span>);<br>            k -= lower;<br>            ans.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + lower - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1664、生成平衡数组的方案数"><a href="#1664、生成平衡数组的方案数" class="headerlink" title="1664、生成平衡数组的方案数"></a>1664、生成平衡数组的方案数</h3><ul><li>给定一个数组，去掉一个数后剩余的部分奇偶和分别相等则为平衡数组，返回有多少种</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//这里没有使用前缀和的方式每一步都进行计算，而是只使用一个变量在遍历过程中维护</span><br><span class="hljs-comment">//不使用前缀和的原因在于前缀和边界条件判断繁琐</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">waysToMakeFair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, even1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, even2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-comment">//判断奇偶</span><br>            <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                odd2 += nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                even2 += nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-comment">//如果为奇数</span><br>            <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                odd2 -= nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果为偶数</span><br>                even2 -= nums[i];<br>            &#125;<br>            <span class="hljs-comment">//每次都要相交换比较</span><br>            <span class="hljs-keyword">if</span> (odd1 + even2 == odd2 + even1) &#123;<br>                ++res;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                odd1 += nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                even1 += nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1669、合并两个链表"><a href="#1669、合并两个链表" class="headerlink" title="1669、合并两个链表"></a>1669、合并两个链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode list2)</span> &#123;<br>    <span class="hljs-comment">//注意以下的2号语句不能直接放在1号语句的后面，因为放在1号语句后就会导致链表错乱</span><br>    <span class="hljs-comment">//经典链表错误问题</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head1</span> <span class="hljs-operator">=</span> list1;<br>        <span class="hljs-keyword">while</span> (count &lt; a - <span class="hljs-number">1</span>) &#123;<br>            head1 = head1.next;<br>            count++;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head1;<span class="hljs-comment">//  1</span><br>        <span class="hljs-keyword">while</span> (count &lt;= b) &#123;<br>            temp = temp.next;<br>            count++;<br>        &#125;<br>        head1.next = list2;   <span class="hljs-comment">//   2</span><br>        <span class="hljs-keyword">while</span> (list2.next != <span class="hljs-literal">null</span>) &#123;<br>            list2 = list2.next;<br>        &#125;<br>        list2.next = temp;<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1685、有序数组中差值的绝对值之和"><a href="#1685、有序数组中差值的绝对值之和" class="headerlink" title="1685、有序数组中差值的绝对值之和"></a>1685、有序数组中差值的绝对值之和</h3><ul><li>若给定下标为n，那么求这个数对应和其他位置的差值绝对值相加然后放到对应的数组下标中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSumAbsoluteDifferences(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-comment">//使用前缀和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            nums[i] += nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//注意对式子推导过程</span><br>        nums[<span class="hljs-number">0</span>] = (<span class="hljs-number">1</span> - length) * nums[<span class="hljs-number">0</span>] + nums[length - <span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> lastSum;<br>            lastSum = nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i] - temp;<br>            nums[i] = (<span class="hljs-number">2</span> * i - length + <span class="hljs-number">1</span>) * num + nums[length - <span class="hljs-number">1</span>] - temp - nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1694、重新排序电话号码"><a href="#1694、重新排序电话号码" class="headerlink" title="1694、重新排序电话号码"></a>1694、重新排序电话号码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reformatNumber</span><span class="hljs-params">(String number)</span> &#123;<br>    <span class="hljs-comment">//这里注意对于string字符串函数的调用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> number.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-comment">//三个三个的遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sb.length() != <span class="hljs-number">0</span>) sb.append(<span class="hljs-string">&quot;-&quot;</span>);<br>            <span class="hljs-comment">//遍历到末尾了</span><br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">5</span> &gt; n) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">3</span> &gt;= n) sb.append(s.substring(i));<br>                <span class="hljs-keyword">else</span> sb.append(s.substring(i, i + <span class="hljs-number">2</span>)).append(<span class="hljs-string">&quot;-&quot;</span>).append(s.substring(i + <span class="hljs-number">2</span>));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            sb.append(s.substring(i, i + <span class="hljs-number">3</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1703、得到连续-K-个-1-的最少相邻交换次数"><a href="#1703、得到连续-K-个-1-的最少相邻交换次数" class="headerlink" title="1703、得到连续 K 个 1 的最少相邻交换次数"></a>1703、得到连续 K 个 1 的最少相邻交换次数</h3><ul><li>TODO</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 例如：[1,0,0,1,0,1,1,1,0,1,1] =&gt; [0,3,5,6,7,9,10]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                pos[index++] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, mid = k / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定长滑窗模板:</span><br>        <span class="hljs-comment">// 1.计算第一个长度为k的窗口, k = 5, pos[i] - pos[i - 1] - 1表示相邻1之间0的个数</span><br>        <span class="hljs-comment">// [0,3,5,6,7] =&gt; (3-0-1)*1 + (5-3-1)*2 + (6-5-1)*2 + (7-6-1)*1 = 4</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;<br>            count += (pos[i] - pos[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) * Math.min(i, k - i);<br>        &#125;<br>        ans = count;<br>        <span class="hljs-comment">// 2.窗口按步长滑动 [0,3,5,6,7] =&gt; [3,5,6,7,9]</span><br>        <span class="hljs-comment">// [0,3,5,6,7] =&gt; (3-0-1)*1 + (5-3-1)*2 + (6-5-1)*2 + (7-6-1)*1 = 4</span><br>        <span class="hljs-comment">// [3,5,6,7,9] =&gt;             (5-3-1)*1 + (6-5-1)*2 + (7-6-1)*2 + (9-7-1)*1 = 2</span><br>        <span class="hljs-comment">// 通过对比发现：count -= (3-0-1)*1 + (5-3-1)*1 + (6-5-1)*0 = 3 - 0 + 5 - 3 + 1 + 1= 5 - 0 + 2</span><br>        <span class="hljs-comment">//             count += (7-6-1)*1 + (9-7-1)*1 = 7 - 6 + 9 - 7 - 1 - 1 = 9 - 6 - 2</span><br>        <span class="hljs-comment">// 类似于差分和前缀和的关系，加减2相互抵消，所以最后结果与窗口内两端点和中位数有关</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; index; i++) &#123;<br>            count -= pos[i - k + mid] - pos[i - k]; <span class="hljs-comment">// 上个区间中位数下标 - 上个区间左端点</span><br>            count += pos[i] - pos[i - mid]; <span class="hljs-comment">// 当前区间右端点 - 当前区间中位数</span><br>            ans = Math.min(ans, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1792、最大平均通过率"><a href="#1792、最大平均通过率" class="headerlink" title="1792、最大平均通过率"></a>1792、最大平均通过率</h3><ul><li>这里易错点在于容易遗漏添加好学生后该班级的总数也会发生改变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">maxAverageRatio</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] classes, <span class="hljs-type">int</span> extraStudents)</span> &#123;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-comment">//判断依据是假设添加好学生后的增长率</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) (b[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) * b[<span class="hljs-number">1</span>] * (a[<span class="hljs-number">1</span>] - a[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) (a[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) * a[<span class="hljs-number">1</span>] * (b[<span class="hljs-number">1</span>] - b[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span> (val1 == val2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> val1 &lt; val2 ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] c : classes) &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;c[<span class="hljs-number">0</span>], c[<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br><br>        <span class="hljs-comment">//给每一个好学生都分配好对应的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; extraStudents; i++) &#123;<br>            <span class="hljs-type">int</span>[] arr = pq.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], total = arr[<span class="hljs-number">1</span>];<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;pass + <span class="hljs-number">1</span>, total + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; classes.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] arr = pq.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], total = arr[<span class="hljs-number">1</span>];<br>            res += <span class="hljs-number">1.0</span> * pass / total;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res / classes.length;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1797、设计一个验证系统"><a href="#1797、设计一个验证系统" class="headerlink" title="1797、设计一个验证系统"></a>1797、设计一个验证系统</h3><ul><li>题目中说可以使用链表优化，实际上就是维护了一个过期时间递增的链表，来加速countUnexpiredTokens</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单hash应用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br>    HashMap&lt;String, Integer&gt; hashMap;<br>    <span class="hljs-type">int</span> gap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AuthenticationManager</span><span class="hljs-params">(<span class="hljs-type">int</span> timeToLive)</span> &#123;<br>        hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        gap = timeToLive;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">(String tokenId, <span class="hljs-type">int</span> currentTime)</span> &#123;<br>        hashMap.put(tokenId, currentTime + gap);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renew</span><span class="hljs-params">(String tokenId, <span class="hljs-type">int</span> currentTime)</span> &#123;<br>        <span class="hljs-keyword">if</span> (hashMap.containsKey(tokenId)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldTime</span> <span class="hljs-operator">=</span> hashMap.get(tokenId);<br>            <span class="hljs-keyword">if</span> (oldTime &gt; currentTime) &#123;<br>                hashMap.put(tokenId, currentTime + gap);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hashMap.remove(tokenId);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUnexpiredTokens</span><span class="hljs-params">(<span class="hljs-type">int</span> currentTime)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer i : hashMap.values()) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; currentTime) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1798、能够构造连续值的最大数目（从0开始）"><a href="#1798、能够构造连续值的最大数目（从0开始）" class="headerlink" title="1798、能够构造连续值的最大数目（从0开始）"></a>1798、能够构造连续值的最大数目（从0开始）</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230205152909534.png" alt="image-20230205152909534"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaximumConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Arrays.sort(coins);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : coins) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; res) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1802、有界数组指定下标的最大值"><a href="#1802、有界数组指定下标的最大值" class="headerlink" title="1802、有界数组指定下标的最大值"></a>1802、有界数组指定下标的最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初步：贪心算法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">while</span> (sum &lt; maxSum) &#123;<br>            <span class="hljs-comment">//实际上maxIndex应该使用二分获取，否则当maxSum很大的时候会导致一步步走很浪费时间</span><br>            sum = ++maxIndex;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index - <span class="hljs-number">1</span>,temp = maxIndex; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">//控制最多只能减少到1</span><br>                <span class="hljs-keyword">if</span> (temp != <span class="hljs-number">1</span>) &#123;<br>                    temp--;<br>                &#125;<br>                sum += temp;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>,temp = maxIndex; i &lt; n; i++) &#123;<br>                <span class="hljs-comment">//控制最多只能减少到1</span><br>                <span class="hljs-keyword">if</span> (temp != <span class="hljs-number">1</span>) &#123;<br>                    temp--;<br>                &#125;<br>                sum += temp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//注意sum大于或者等于两种情况需要做不同的操作</span><br>        <span class="hljs-keyword">return</span> sum == maxSum ? maxIndex : maxIndex - <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//官解1：贪心＋二分</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = maxSum;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (valid(mid, n, index, maxSum)) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> mid + cal(mid, left) + cal(mid, right) &lt;= maxSum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> big, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (length + <span class="hljs-number">1</span> &lt; big) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> big - length;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) (big - <span class="hljs-number">1</span> + small) * length / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> length - (big - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) big * (big - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + ones;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//官解2：数学推导</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> left;<br>            left = right;<br>            right = temp;<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">upper</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">double</span>) (left + <span class="hljs-number">1</span>) * (left + <span class="hljs-number">1</span>) - <span class="hljs-number">3</span> * (left + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> + left + <span class="hljs-number">1</span> + (left + <span class="hljs-number">1</span>) + ((left + <span class="hljs-number">1</span>) * (left + <span class="hljs-number">1</span>) - <span class="hljs-number">3</span> * (left + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> + right + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (upper &gt;= maxSum) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> left + right + <span class="hljs-number">2</span> - maxSum;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.floor((-b + Math.sqrt(b * b - <span class="hljs-number">4</span> * a * c)) / (<span class="hljs-number">2</span> * a));<br>        &#125;<br><br>        upper = ((<span class="hljs-type">double</span>) <span class="hljs-number">2</span> * (right + <span class="hljs-number">1</span>) - left - <span class="hljs-number">1</span>) * left / <span class="hljs-number">2</span> + (right + <span class="hljs-number">1</span>) + ((right + <span class="hljs-number">1</span>) * (right + <span class="hljs-number">1</span>) - <span class="hljs-number">3</span> * (right + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> + right + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (upper &gt;= maxSum) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> - <span class="hljs-number">3.0</span> / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> right + <span class="hljs-number">1</span> + (-left - <span class="hljs-number">1</span>) * left / <span class="hljs-number">2</span> - maxSum;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.floor((-b + Math.sqrt(b * b - <span class="hljs-number">4</span> * a * c)) / (<span class="hljs-number">2</span> * a));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> left + right + <span class="hljs-number">1</span>;;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (-left * left - left - right * right - right) / <span class="hljs-number">2</span> - maxSum;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.floor(-b / a);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1813、句子相关性"><a href="#1813、句子相关性" class="headerlink" title="1813、句子相关性"></a>1813、句子相关性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意具体判断相似性的算法，从左边数两个字符串有i个相同，从右边数两个字符串有j个相同，如果i+j为两个字符串的较小值则相似</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areSentencesSimilar</span><span class="hljs-params">(String sentence1, String sentence2)</span> &#123;<br>        String[] words1 = sentence1.split(<span class="hljs-string">&quot; &quot;</span>);<br>        String[] words2 = sentence2.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; words1.length &amp;&amp; i &lt; words2.length &amp;&amp; words1[i].equals(words2[i])) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; words1.length - i &amp;&amp; j &lt; words2.length - i &amp;&amp; words1[words1.length - j - <span class="hljs-number">1</span>].equals(words2[words2.length - j - <span class="hljs-number">1</span>])) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i + j == Math.min(words1.length, words2.length);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1814、统计数组中好数对的数量"><a href="#1814、统计数组中好数对的数量" class="headerlink" title="1814、统计数组中好数对的数量"></a>1814、统计数组中好数对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNicePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//利用hashMap减少遍历</span><br>        HashMap&lt;Integer, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> num, j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>                j = j * <span class="hljs-number">10</span> + temp % <span class="hljs-number">10</span>;<br>                temp /= <span class="hljs-number">10</span>;<br>            &#125;<br>            num = num - j;<br>            <span class="hljs-comment">//注意不要使用以下这种愚蠢的数字反转，效率很低</span><br><span class="hljs-comment">//            StringBuilder stringBuilder = new StringBuilder(Integer.toString(num));</span><br><span class="hljs-comment">//            num = num - Integer.parseInt(String.valueOf(stringBuilder.reverse()));</span><br>            count = (count + hashMap.getOrDefault(num, <span class="hljs-number">0</span>))%MOD;<br>            hashMap.put(num, hashMap.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (count%MOD);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1824、青蛙最小侧跳次数"><a href="#1824、青蛙最小侧跳次数" class="headerlink" title="1824、青蛙最小侧跳次数"></a>1824、青蛙最小侧跳次数</h3><ul><li>题目使用动态规划处理，经测试使用贪心算法效果更好</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSideJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] obstacles)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">jumpCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; obstacles.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">obstacle</span> <span class="hljs-operator">=</span> obstacles[i];<br>            <span class="hljs-keyword">if</span> (obstacle == now) &#123;<br>                jumpCount++;<br>                <span class="hljs-comment">//这个1获取2、3等操作待优化</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (now + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (now - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>                    x = <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>                    y = <span class="hljs-number">3</span>;<br>                &#125;<br>                obstacle = obstacles[--i];<br>                <span class="hljs-keyword">while</span> (obstacle != x &amp;&amp; obstacle != y) &#123;<br>                    i++;<br>                    <span class="hljs-keyword">if</span> (i &gt;= obstacles.length) &#123;<span class="hljs-keyword">break</span>;&#125;<br>                    obstacle = obstacles[i];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &gt; obstacles.length) &#123;<span class="hljs-keyword">break</span>;&#125;<br>                now = obstacle == x ? y : x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> jumpCount;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1837、K进制下的各位之和"><a href="#1837、K进制下的各位之和" class="headerlink" title="1837、K进制下的各位之和"></a>1837、K进制下的各位之和</h3><ul><li>给定对应十进制数字，然后指定对应的进制，求对应进制下的各位之和</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实际上不需要计算出来其本身的大小，只需要求出来各位的值然后累加即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumBase</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//关键操作</span><br>sum+=n%k;<br>n=n/k;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1904、完成的完整对局数"><a href="#1904、完成的完整对局数" class="headerlink" title="1904、完成的完整对局数"></a>1904、完成的完整对局数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用数轴思想进行解题</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfRounds</span><span class="hljs-params">(String loginTime, String logoutTime)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loginHour</span> <span class="hljs-operator">=</span> Integer.parseInt(loginTime.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">logoutHour</span> <span class="hljs-operator">=</span> Integer.parseInt(logoutTime.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loginMin</span> <span class="hljs-operator">=</span> Integer.parseInt(loginTime.substring(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">logoutMin</span> <span class="hljs-operator">=</span> Integer.parseInt(logoutTime.substring(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">login</span> <span class="hljs-operator">=</span> loginHour * <span class="hljs-number">60</span> + loginMin;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">logout</span> <span class="hljs-operator">=</span> logoutHour * <span class="hljs-number">60</span> + logoutMin;<br>    <span class="hljs-comment">//如果起始时间反而大于结束时间，说明玩了个通宵，则需要给结束时间多添加1440</span><br>        <span class="hljs-keyword">if</span> (login &gt; logout) &#123;<br>            logout += <span class="hljs-number">1440</span>;<br>        &#125;<br>    <span class="hljs-comment">//注意这里由于截断的存在，所以运算结果正好为离logout最近的结束时间</span><br>        logout = logout / <span class="hljs-number">15</span> * <span class="hljs-number">15</span>;<br>        <span class="hljs-keyword">return</span> (logout-login)/<span class="hljs-number">15</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1955、统计特殊子序列的数目"><a href="#1955、统计特殊子序列的数目" class="headerlink" title="1955、统计特殊子序列的数目"></a>1955、统计特殊子序列的数目</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230201140922537.png" alt="image-20230201140922537"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">countSpecialSubsequences1955</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> f0=<span class="hljs-number">0</span>,f1=<span class="hljs-number">0</span>,f2=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//这里的关键点在于f0=0,f1=0,f2=0初始值均为0，并且f0=0,f1=0,f2=0的计算方式也很巧妙</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//f0表示只有0能组成的字符串种类，每多一个0就导致0的个数翻倍并加一</span><br>                f0 = (f0*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)%mod;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//注意这个计算式子很重要</span><br>                f1 = (f1*<span class="hljs-number">2</span>%mod+f0)%mod;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//最终结果只取决于有多少个2</span><br>                f2 = (f2*<span class="hljs-number">2</span>%mod+f1)%mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2053、数组中的第K个独特字符串"><a href="#2053、数组中的第K个独特字符串" class="headerlink" title="2053、数组中的第K个独特字符串"></a>2053、数组中的第K个独特字符串</h3><ul><li>注意这里的独特是相对于整个数组而言</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">kthDistinct</span><span class="hljs-params">(String[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span> (k &gt; length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    <span class="hljs-comment">//注意这里使用LinkedHashMap保证输出的有序性</span><br>        HashMap&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : arr) &#123;<br>            hashMap.put(s, hashMap.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: hashMap.entrySet())&#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">1</span>) &#123;<br>                k--;<br>                <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> entry.getKey();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2208、将数组和减半的最小次数"><a href="#2208、将数组和减半的最小次数" class="headerlink" title="2208、将数组和减半的最小次数"></a>2208、将数组和减半的最小次数</h3><ul><li>优先队列的简单应用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">halveArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//注意最大堆构建</span><br>        PriorityQueue&lt;Double&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; Double.compare(b, a));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nu : nums) &#123;<br>            q.offer((<span class="hljs-type">double</span>) nu);<br>            sum += (<span class="hljs-type">double</span>) nu;<br>        &#125;<br>        <span class="hljs-comment">//这里的now是减去的部分</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (now &lt; sum * <span class="hljs-number">0.5</span>) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> head * <span class="hljs-number">0.5</span>;<br>            now += half;<br>            cnt++;<br>            q.offer(half);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2303、计算应缴税额总量"><a href="#2303、计算应缴税额总量" class="headerlink" title="2303、计算应缴税额总量"></a>2303、计算应缴税额总量</h3><ul><li>根据比例计算应缴纳的税额</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这里可以先使用int作为计算，最后再将int值除以100计算得到对应税值</span><br><span class="hljs-comment">//注意如果想要将int之间的换算转换为double值，可以在运算相乘的时候多乘一个1.0</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] brackets, <span class="hljs-type">int</span> income)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBefore</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; brackets.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">upper</span> <span class="hljs-operator">=</span> brackets[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">percent</span> <span class="hljs-operator">=</span> brackets[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (income &gt; upper) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> (upper - upperBefore) * percent;<br>                upperBefore = upper;<br>                res += money;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> (income - upperBefore) * percent;<br>                res += money;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res/<span class="hljs-number">100</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2347、最好的扑克手牌"><a href="#2347、最好的扑克手牌" class="headerlink" title="2347、最好的扑克手牌"></a>2347、最好的扑克手牌</h3><ul><li>简单hash表引用，注意能快点返回的快点返回，能晚点实例化的晚点实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">bestHand</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ranks, <span class="hljs-type">char</span>[] suits)</span> &#123;<br>        String[] res = &#123;<span class="hljs-string">&quot;Flush&quot;</span>, <span class="hljs-string">&quot;Three of a Kind&quot;</span>, <span class="hljs-string">&quot;Pair&quot;</span>, <span class="hljs-string">&quot;High Card&quot;</span>&#125;;<br>        <span class="hljs-comment">//由于从高到低输出结果</span><br>        HashMap&lt;Character, Integer&gt; suitsHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Integer, Integer&gt; ranksHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ranks.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ranks[i];<br>            ranksHashMap.put(ranks[i], ranksHashMap.getOrDefault(ranks[i], <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            suitsHashMap.put(suits[i], suitsHashMap.getOrDefault(suits[i], <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">suitCount</span> <span class="hljs-operator">=</span> suitsHashMap.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rankCount</span> <span class="hljs-operator">=</span> ranksHashMap.size();<br>        <span class="hljs-comment">//&quot;Flush&quot;：同花，五张相同花色的扑克牌。</span><br>        <span class="hljs-keyword">if</span> (suitCount == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">//&quot;High Card&quot;：高牌，五张大小互不相同的扑克牌。</span><br>        <span class="hljs-keyword">if</span> (rankCount == <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">return</span> res[<span class="hljs-number">3</span>];<br>        &#125;<br>        <span class="hljs-comment">//&quot;Three of a Kind&quot;：三条，有 3 张大小相同的扑克牌。</span><br>        <span class="hljs-comment">//&quot;Pair&quot;：对子，两张大小一样的扑克牌。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> count : ranksHashMap.values()) &#123;<br>            <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">2</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2357、使数组中的所有元素均为0"><a href="#2357、使数组中的所有元素均为0" class="headerlink" title="2357、使数组中的所有元素均为0"></a>2357、使数组中的所有元素均为0</h3><ul><li>本来考虑使用优先队列求解，但是实际上数组中不同的数字个数即为所求结果</li><li>优先队列默认是小顶堆</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>               set.add(num);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> set.size();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2294、划分数组使其最大差为K"><a href="#2294、划分数组使其最大差为K" class="headerlink" title="2294、划分数组使其最大差为K"></a>2294、划分数组使其最大差为K</h3><ul><li>注意这题能够进行排序的原因在于（一般子序列问题是不能进行排序的）<ul><li>我们关心的是子序列中，最大和最小的差值，那么就可以认为和顺序没有关系了。</li><li>结果是返回的个数， 而不是子序列</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tempMin</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num - tempMin &gt; k) &#123;<br>                count++;<br>                tempMin = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2331、计算布尔二叉树的值"><a href="#2331、计算布尔二叉树的值" class="headerlink" title="2331、计算布尔二叉树的值"></a>2331、计算布尔二叉树的值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">evaluateTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//因为项目本身限定了二叉树只能有0个或者2个子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root.val == <span class="hljs-number">1</span>;<span class="hljs-comment">//巧妙转换</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> evaluateTree(root.left) || evaluateTree(root.right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> evaluateTree(root.left) &amp;&amp; evaluateTree(root.right);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2332、乘坐公交车最晚到达时间"><a href="#2332、乘坐公交车最晚到达时间" class="headerlink" title="2332、乘坐公交车最晚到达时间"></a>2332、乘坐公交车最晚到达时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">latestTimeCatchTheBus</span><span class="hljs-params">(<span class="hljs-type">int</span>[] buses, <span class="hljs-type">int</span>[] passengers, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        Arrays.sort(buses);<br>        Arrays.sort(passengers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//注意这里可以将count值在外面定义，这样就可以获取到</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//由于一定要做到最后一辆车，所以这里需要将最后一辆车前面的所有车尽可能的装满</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buses.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bus</span> <span class="hljs-operator">=</span> buses[i];<br>            count = capacity;<br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; passengers.length &amp;&amp; passengers[index] &lt;= bus) &#123;<br>                index++;<br>                count--;<br>            &#125;<br>        &#125;<br>        index--;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> count &gt; <span class="hljs-number">0</span> ? buses[buses.length - <span class="hljs-number">1</span>] : passengers[index]; <span class="hljs-comment">// 在发车时到达公交站 or 上一个上车的乘客</span><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; passengers[index--] == res) --res; <span class="hljs-comment">// 往前找没人到达的时刻</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2335、装满杯子所需的时间"><a href="#2335、装满杯子所需的时间" class="headerlink" title="2335、装满杯子所需的时间"></a>2335、装满杯子所需的时间</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211112037275.png" alt="image-20230211112037275"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fillCups</span><span class="hljs-params">(<span class="hljs-type">int</span>[] amount)</span> &#123;<br>        Arrays.sort(amount);<br>        <span class="hljs-keyword">if</span> (amount[<span class="hljs-number">2</span>] &gt; amount[<span class="hljs-number">1</span>] + amount[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (amount[<span class="hljs-number">0</span>] + amount[<span class="hljs-number">1</span>] + amount[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2380、二进制字符串重新排序所需要的时间"><a href="#2380、二进制字符串重新排序所需要的时间" class="headerlink" title="2380、二进制字符串重新排序所需要的时间"></a>2380、二进制字符串重新排序所需要的时间</h3><ul><li>关键在于考虑每一个元素移动的时间实际上就等于前面的0的个数，并且考虑堵车+1的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secondsToRemoveOccurrences</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//实际上移动的时间取决于最后一个元素移动的时长</span><br>        <span class="hljs-comment">//并且最后一个元素移动的时长实际上等于这个元素前面的0的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>) ++pre0;<br>            <span class="hljs-comment">//这里的后面的一个f表示的是前一个元素的走的路程加一，加一表示堵车，需要等一秒</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre0 &gt; <span class="hljs-number">0</span>) f = Math.max(f + <span class="hljs-number">1</span>, pre0); <span class="hljs-comment">// 前面有 0 的时候才会移动</span><br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2384、利用给定的字符串中的数字构成最大的回文数"><a href="#2384、利用给定的字符串中的数字构成最大的回文数" class="headerlink" title="2384、利用给定的字符串中的数字构成最大的回文数"></a>2384、利用给定的字符串中的数字构成最大的回文数</h3><ul><li>这里注意限定条件是最大并且没有前导零</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestPalindromic</span><span class="hljs-params">(String num)</span> &#123;<br>        <span class="hljs-type">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        Arrays.fill(numbers, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num.length(); i++) &#123;<br>            numbers[num.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">//如果前面都没有添加，则当前0不能添加，添加就成了前导0</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; sb1.length() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (numbers[i] &gt; <span class="hljs-number">1</span>) &#123;<br>                sb1.append(i);<br>                numbers[i] -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//注意不能是注释的写法，因为StringBuilder不是String，调用reverse两个都会变</span><br><span class="hljs-comment">//        StringBuilder sb2 = sb1.reverse();</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(sb1).reverse();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i] == <span class="hljs-number">1</span>) &#123;<br>                sb1.append(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        sb1.append(sb2);<br><span class="hljs-comment">//注意考虑为0的情况</span><br>        <span class="hljs-keyword">return</span> sb1.length()==<span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span>:sb1.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="刷题简介"><a href="#刷题简介" class="headerlink" title="刷题简介"></a>刷题简介</h3><ul><li>注意如果使用同一个变量作为同一个输出口，为了注意在满足条件的情况下需要使用break返回跳出</li></ul><h3 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h3><ul><li>深度遍历获取深度或者结点个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//注意这个dfs是用于计算子节点有多少个数的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs_count</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs_count(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs_count(node.right);<br>        <span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//最大深度的计算</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>            <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//最小深度的计算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs_depth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs_depth(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs_depth(node.right);<br>        <span class="hljs-comment">//注意对于左右结点为null的情况，如果其中有一个为null，那么其结果就是0，会干扰Math.min()的计算</span><br>        <span class="hljs-keyword">return</span> node.left == <span class="hljs-literal">null</span> || node.right == <span class="hljs-literal">null</span> ? left + right + <span class="hljs-number">1</span> : Math.min(left,right) + <span class="hljs-number">1</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="面试题系列"><a href="#面试题系列" class="headerlink" title="面试题系列"></a>面试题系列</h2><h3 id="二进制数字转字符串"><a href="#二进制数字转字符串" class="headerlink" title="二进制数字转字符串"></a>二进制数字转字符串</h3><ul><li>实际上是十进制数字转换成二进制数字的问题</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230302141521205.png" alt="image-20230302141521205"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">printBin</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;0.&quot;</span>);<br>        <span class="hljs-keyword">while</span> (sb.length() &lt;= <span class="hljs-number">32</span> &amp;&amp; num != <span class="hljs-number">0</span>) &#123;<br>            num *= <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) num;<br>            sb.append(digit);<br>            num -= digit;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length() &lt;= <span class="hljs-number">32</span> ? sb.toString() : <span class="hljs-string">&quot;ERROR&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/go/"/>
    <url>/2023/03/06/go/</url>
    
    <content type="html"><![CDATA[<p>go语言中对于数组的复制和传参，都是将其深拷贝，而不是仅仅复制一个指针</p><p>相对于数组而言，切片相当于是动态的数组（go语言自动翻倍扩容），并且会存放对应的  起始的指针，长度，容量</p><ul><li>如果在一个方法中传递一个数组(Array)，则相当于将所有的数组都复制一份到方法中</li><li>如果在一个方法中传递一个切片(Slice)，则只是传递对应slice的指针</li><li>如果在一个方法中传递一个映射(Map)，则只是传递对应Map的指针</li></ul><p>切片截取只是进行浅复制，相当于视图</p><p>传递一个对象的时候，注意可以使用直接传递对象，也可以传递对象的指针，如果需要对这个对象进行修改，则传递一个指针给这个方法</p><p>在golang中，类，函数，变量都满足如果这个变量是小写开头，那么就是当前包内可用，如果是大写就指的是公共的</p><p>注意类型之间可以进行嵌套</p><p>按照惯例，一般是在方法的第一个参数中将context传入</p><p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)</p><p>Go语言中的range关键字使用起来非常的方便，它允许你遍历某个slice或者map，并通过两个参数(index和value)，分别获取到slice或者map中某个元素所在的index以及其值</p><p>go语言中的range 类似java中的foreach，其中对于数组和切片，返回的值是下标和对应的值，对于map而言返回的是对应的键值对</p><p>和java语言不同的是，go语言的结构体并不需要显示实现接口，只需要满足方法匹配即可</p><p>并且go中没有专门的构造函数，可以统一使用new为前缀的函数来创建结构体实例</p><p>需要注意的是 <strong>{</strong> 不能单独放在一行，所以以下代码在运行时会产生错误</p><p><strong>go语言类型转换总结</strong></p><ul><li><a href="https://blog.csdn.net/pdskyzcc1/article/details/104237838">(53条消息) golang语言强制类型转换_golang type 别名强制转换_pdskyzcc1的博客-CSDN博客</a></li></ul><p><strong>go语言使用JWT进行鉴权验证</strong></p><ul><li><a href="https://cloud.tencent.com/developer/article/1770768">Golang语言使用 jwt-go 库生成和解析 token - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li><li><a href="https://blog.csdn.net/sucaiwa/article/details/129249469">(53条消息) 03｜Token：如何降低用户身份鉴权的流量压力？_sucaiwa的博客-CSDN博客</a></li></ul><p><strong>go语言make和new的区别</strong></p><ul><li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2">2</a>；</li><li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:3">3</a>，只能接收类型作为参数然后返回一个指向该类型的指针；</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%89%8B%E5%86%99jvm/"/>
    <url>/2023/03/06/%E6%89%8B%E5%86%99jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="手写jvm相关笔记"><a href="#手写jvm相关笔记" class="headerlink" title="手写jvm相关笔记"></a>手写jvm相关笔记</h1><h2 id="第一章：命令行工具"><a href="#第一章：命令行工具" class="headerlink" title="第一章：命令行工具"></a>第一章：命令行工具</h2><ul><li>使用flag包中的go语言函数能够很方便的解析命令行中</li></ul><h2 id="第二章：搜索class文件"><a href="#第二章：搜索class文件" class="headerlink" title="第二章：搜索class文件"></a>第二章：搜索class文件</h2><p><strong>概述</strong>：实现类路径，使得虚拟机可以找到对应class文件，并将数据加载到内存中</p><ul><li>类路径可以分为以下三个部分<ul><li>启动类路径<ul><li>其默认路径对应于jre&#x2F;lib目录，java的标准库存在于该路径</li></ul></li><li>扩展类路径<ul><li>扩展类路径默认位于jre&#x2F;lib&#x2F;ext目录中，使用java扩展机制的类位于该路径</li></ul></li><li>用户类路径<ul><li>自己实现的和第三方的类库位于用户类路径，可以使用-Xbootclasspath选项修改启动类路径，但一般不这样做</li><li>用户类路径的默认值是当前路径，即“.”,可以在CLASSPATH环境变量中设置对应的路径，但是这样设置并不灵活，所以不推荐使用，更好的办法是使用java命令传递 -classpath(或者可以简写为-cp)，并且使用-classpath(-cp)所设置的选项优先级更高，可以覆盖环境变量的配置</li></ul></li></ul></li><li>entry实际上就是一个访问类路径，并且其有不同类型，当对其进行赋值操作时，并不是简单的进行赋值，而是通过对应方法在调用过程中就设定了对应的entry类型</li><li><strong>本章相关方法解析</strong><ul><li>readClass方法参数是class的相对路径，路径之间使用 &#x2F; 进行分隔，文件名后面有class后缀，该方法的返回值是读取到的字节数据，最终定位到class文件的entry，以及相应错误信息</li></ul></li><li><strong>本章相关go语言特性</strong><ul><li>go的函数或者方法允许返回多个值，按照惯例，可以使用最后一个返回值作为错误信息</li><li>go语言和java不同的是，go语言结构体不需要显式实现接口，只需要进行方法匹配，并且go语言没有专门的构造函数，可以使用统一的new开头的函数作为创建结构体实例的函数</li></ul></li></ul><h2 id="第三章：解析class文件"><a href="#第三章：解析class文件" class="headerlink" title="第三章：解析class文件"></a>第三章：解析class文件</h2><p><strong>概述：</strong>实现class文件解析，可以将class数据解析成一个ClassFile结构体</p><ul><li><p>classreader只是对字节数组进行封装，每次读取就读取数据然后切割数据，对于读取数组类型的数据，则先读取对应的长度，然后迭代读取</p></li><li><p>使用统一的MemberInfo来作为对于<strong>字段或者方法</strong>的描述符，二者合二为一</p></li><li><p>class文件中存储的类名类似于完全限定名，只是将点换成了斜线，java语言规范将这种名称称之为 二进制名</p></li><li><p>常量池实际上也是一个表，但是需要注意如下三点</p><ul><li>表头给出的常量池的大小比实际大1，假设表头给出的值是n，那么常量池的实际大小是n-1</li><li>有效的常量池索引是  1到n-1  ，0是无效索引，表示不指向任何常量</li><li>CONSTANT_Long_info和CONSTANT_Double_info还要各占两个位置，即如果常量池中存在这两种常量，那么常量池中的实际常量数量比n-1还要少，并且索引范围中的部分数也会变成无效索引</li></ul></li><li><p>CONSTANT_Integer_info正好可以容纳一个java的int类型常量，但是实际上比int小的boolean、byte、short和char类型常量也存放在CONSTANT_Integer_info中</p></li><li><p>注意在class文件中，字符串是以MUTF-8（Modified UTF-8）方式编码的，而不是使用标准的UTF-8，同样的java序列化也是使用MUTF-8</p></li><li><p>常量池中的常量可以分为以下两种</p><ul><li><p>字面量（literal）：字面量包括数字常量和字符串常量</p></li><li><p>符号引用（symbolic reference）：符号引用包含类和接口名，字段和方法信息</p></li></ul></li><li><p>除了字面量以外，其他常量都是通过索引间接或者直接的指向CONSTANT_Utf-8_info</p></li><li><p>计算机科学中的任何难题都可以通过增加一个中间层来解决，在本书中的ClassFile结构体就是为了实现类加载功能而增加的中间层</p></li><li><p>由于属性表中的数据并不是固定的，不用的虚拟机可以实现不同的属性，java虚拟机规范没有使用tag来表明属性，而是使用属性名来区分不同的属性</p></li><li><p><strong>本章相关go语言特性</strong></p><ul><li>为了描述class文件结构，java虚拟机规范规定了u1，u2，u4等四种数据类型来表示1、2、4字节的无符号整数，分别对应的是go语言中的uint8、uint16、uint32。相同类型的多条数据一般使用表的形式存储在class文件中，表由表头和表项构成，表头是u2或者u4整数，假设表头是n，后面就紧跟着n个表项数据</li><li>相比于java语言中，go语言的访问控制很简单，只有公开和私有两种，所有首字母大写的都是公开的，可以供其他包进行使用，所有首字母小写的都是私有的，只能在包内部使用</li><li>go语言没有异常处理机制，只有一个panic-recover机制</li><li>go语言没有相关继承定义，但是可以使用结构体嵌套来模拟继承</li></ul></li></ul><h3 id="新代码实现学习："><a href="#新代码实现学习：" class="headerlink" title="新代码实现学习："></a>新代码实现学习：</h3><p>class_reader:使用切片进行数据读取</p><h2 id="第四章：运行时数据区"><a href="#第四章：运行时数据区" class="headerlink" title="第四章：运行时数据区"></a>第四章：运行时数据区</h2><p><strong>概述</strong>：初步实现线程私有的运行时数据区</p><ul><li>运行java程序时，需要内存来存放各式各样的数据，java虚拟机规范将这些内存区域称之为运行时数据区，并且运行时数据区可以分为以下两种：<ul><li>多线程共享：共享的数据区需要在java虚拟机启动的时候就创建好，在java虚拟机退出时销毁，多线程共享区域主要存放以下两种数据<ul><li>类数据：类数据存放在方法区中，类数据包含字段和方法信息，方法的字节码，运行时常量池等，从逻辑上将方法区实际上也是堆的一部分</li><li>类实例：对象信息存放在堆中，该部分信息由垃圾回收器进行处理</li></ul></li><li>单线程私有：私有的数据区在创建线程时才创建，线程退出时销毁，其由以下几部分组成<ul><li>PC寄存器：存放当前正在执行的java虚拟机指令的地址</li><li>java虚拟机栈：其由一系列栈帧组成，栈帧中保存方法执行的状态，包括局部变量表和操作数栈等，在任意时刻，某一线程肯定是在执行某个方法，这个方法称之为当前线程的当前方法，执行该方法的帧称之为线程的当前帧，声明该方法的类称之为当前类</li></ul></li></ul></li><li>java中的引用类型分为<ul><li>类类型，接口类型，数组类型，null</li></ul></li><li>注意当操作数栈弹出一个引用类型变量时，需要对这个slot结构体中的ref设置为nil，以便于更好的帮助go语言实现垃圾回收object结构体实例</li></ul><h2 id="第五章：指令集和解释器"><a href="#第五章：指令集和解释器" class="headerlink" title="第五章：指令集和解释器"></a>第五章：指令集和解释器</h2><p><strong>概述：</strong>在先前的基础上实现一个简单的解释器和150多条指令，这些指令主要用于操作局部变量表和操作数栈，进行数学运算，比较运算，跳转控制等</p><ul><li>可以理解为虚拟机是一个虚拟的机器，而字节码就是这个虚拟的机器上的机器码，由于每一个指令都由一个字节组成，故称之为字节码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instruction <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">//从字节码中提取操作数</span><br>FetchOperands(reader *BytecodeReader)<br>    <span class="hljs-comment">//具体的逻辑实现</span><br>Execute(frame *rtda.Frame)<br>&#125;<br><span class="hljs-comment">//而具体的操作数并不存放在Instruction接口中，而是存放在继承Instruction的类型中</span><br></code></pre></td></tr></table></figure><ul><li>操作数栈和局部变量表只存放数据的值，并不记录数据类型</li><li>如果使用switch来映射执行语句则会使得代码可读性差，本书使用将指令抽象为接口，解码和执行逻辑写在具体的指令实现中</li><li>为了避免每次解码指令都需要创建一个BytecodeReader实例，给BytecodeReader定义一个reset方法来实现对其的复用</li><li>fcmp用于比较浮点数，该指令和lcmp指令很像，但是由于浮点数运算中可能产生NaN值，所以比较两个浮点数时，除了要定义大于、小于、等于之外，还有第四种结果：无法比较</li><li>所有的跳转逻辑都集成在Branch()函数中</li><li>java语言中的switch-case语句有两种实现方式<ul><li>如果case值可以编码成一个索引表（case中的情况是正整数），则实现成tableswitch</li><li>如果不能表示则实现成lookupswitch指令</li></ul></li><li>对于大部分的方法而言，其局部变量表大小都不会超过256，所以使用一字节来表示索引就足够了，但是如果有的方法的局部变量表超过限制则需要使用wide指令来扩展前述指令</li><li>相关指令集中有很大一部分指令集是没有操作数的，所以不需要每次都创建不同的实例，为了优化可以为这些指令定义单例变量，使得每次调用实际上都是使用的同一个单例变量</li><li><strong>本章相关go语言特性</strong><ul><li>由于go语言没有给浮点数类型进行求余的操作符，所以需要另外使用math包中的mod函数进行求余</li></ul></li></ul><h2 id="第六章：类和对象"><a href="#第六章：类和对象" class="headerlink" title="第六章：类和对象"></a>第六章：类和对象</h2><p><strong>概述</strong>：实现线程共享的运行时数据区，包括方法区和运行时常量池，并且将进一步处理ClassFile结构体，并且将其加以转换，放到方法区以供后续使用，实现了类和对象结构体、一个简单的类加载器，以及ldc和部分引用类指令</p><ul><li><p>方法区：属于运行时数据区的一块逻辑区域，由多个线程共享，方法区主要用于存放从class文件中获取的类信息，此外类信息也会存放在方法区中，当java虚拟机第一次使用某个类时，它会搜索类路径找到对应的class文件，然后读取并且解析class文件，将相关信息放入方法区，至于方法区到底位于何处，是固定大小还是动态调整，是否参与垃圾回收，以及如何在方法区中存放类数据等，java虚拟机规范并没有明确规定</p></li><li><p>操作数栈和局部变量表大小是在java编译过程时就计算好的，并不需要额外计算</p></li><li><p>运行时常量池主要存放以下两种信息：</p><ul><li>字面量：包含整数、浮点数、字符串字面量</li><li>符号引用：包含类符号引用、字段符号引用、方法符号引用、接口方法符号引用</li></ul></li><li><p>在结构体中定义cp字段，cp是指向常量池的指针，这样就可以通过符号引用访问到运行时常量池，进一步访问到对应的微数据</p></li><li><p>使用className字段用于存放类的完全限定名，class字段用于缓存解析后的类结构体指针，这样类符号引用只需要解析一次就可以了，后续可以直接使用其缓存值</p></li><li><p>定义ClassMember结构体用于存放字段和方法所共有的信息，类似的也定义了MemberRef结构体来存放字段和方法符号引用共有的信息</p></li><li><p>P135相关的继承关系图</p></li><li><p>类加载器的结构体中存在cp用于保存classpath指针，而使用classMap字段来记录已经加载的类数据（在java虚拟机规范中，方法区只是一个抽象的概念，可以使用classMap作为方法区具体的实现）</p></li><li><p>数组类和普通类并不相同，数组类的数据并不是来自class文件，而是在java虚拟机运行期间动态生成</p></li><li><p>类的加载过程：</p><ul><li>找到class文件并且将数据读取到内存中</li><li>解析class文件，生成虚拟机可以使用的类数据，并放入方法区中</li><li>最后进行连接（类的连接分为验证和准备两个部分）</li></ul></li><li><p>类的连接过程</p><ul><li>验证：在java虚拟机规范中要求在执行类的任何代码之前都需要对类进行严格的验证（本书忽略其实现）</li><li>准备：准备阶段主要是给类变量分配空间并且给予其初始值</li></ul></li><li><p>注意类是可以继承的，在统计实例变量时，要递归的数超类中的实例变量</p></li><li><p>如果静态变量属于基本类型或者String类型，有final修饰符，并且在编译期间已知，则将该值存储在class文件的常量池中</p></li><li><p>ldc系列指令将运行时常量池中的常量推入操作数栈顶</p></li><li><p>new指令的操作数是一个uint16索引，来自字节码，通过这个索引，可以从当前类的运行时常量池中找到一个对应的类符号引用，解析这个类符号引用，拿到对应的类数据，创建对应对象然后将这个对象引用推入栈顶</p></li><li><p>由于接口和抽象类都不能进行实例化，所以当解析后的类是接口或者抽象类，按照java虚拟机规范规定，需要抛出InstaniationError异常，如果解析后的类还是没有初始化则需要首先进行初始化类</p></li><li><p>instanceof指令需要两个操作数，第一个操作数是uint16索引，从方法的字节码中获取，通过这个索引可以从当前类的运行时常量池中找到一个类符号引用，第二个操作数是对象引用，从操作数栈中弹出</p></li><li><p>ldc和ldc_w的唯一区别在于两者的操作数宽度，根据其不同的操作数宽度选用不同的ldc</p></li></ul><h2 id="第七章：方法调用和返回"><a href="#第七章：方法调用和返回" class="headerlink" title="第七章：方法调用和返回"></a>第七章：方法调用和返回</h2><p><strong>概述</strong>：实现方法的调用和返回</p><ul><li>java中的方法实现分类：<ul><li>抽象方法，不进行实现</li><li>使用java语言进行实现</li><li>使用本地语言进行实现（c和c++）</li></ul></li><li>在java7之前一共提供了四条方法调用指令<ul><li>invokestatic</li><li>invokespecial</li><li>invokeinterface</li><li>invokeviturtal</li></ul></li><li>详细的调用指令区分<ul><li><a href="https://blog.csdn.net/kangkanglou/article/details/79422520">(53条消息) JVM指令之invokestatic,invokespecial,invokeinterface,invokevirtual,invokedynamic___HelloWorld__的博客-CSDN博客</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/06/%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>虚拟机网络IP地址动态变化</strong></p><ul><li>TODO</li></ul><p><strong>虚拟机无法连接网络</strong></p><ul><li>将网络适配器设置调整成桥接模式</li></ul><p><strong>VSCODE连接SSH配置</strong></p><ul><li>解决方法：在对应配置文件中进行配置即可</li></ul><p><strong>导入SQL文件不成功</strong></p><ul><li>解决方法：导入的SQL文件是没有创建数据库语句含在其中的，需要手动创建一个数据库然后在这个数据库基础上运行</li><li>还有可能是SQL文件不完整</li></ul><p><strong>git clone 不成功</strong></p><ul><li>报错：GnuTLS recv error (-110): The TLS connection was non-properly terminated.</li><li>解决方法：git clone –recursive  <a href="https://github.com/cloudwego/kitex-examples.git%EF%BC%88%E6%B7%BB%E5%8A%A0--recursive">https://github.com/cloudwego/kitex-examples.git（添加--recursive</a> 参数）</li><li>–recursive是递归的意思，不仅会git clone当前项目中的代码，也会clone项目中子项目的代码。我们有时在git clone的时候漏掉 –recursive选项，导致编译无法通过</li></ul><p><strong>使用hexos部署失败</strong></p><ul><li><p>报错：OpenSSL SSL_read: Connection was reset, errno 10054</p></li><li><p>实际上本身是由于没有开VPN，导致无法访问页面，然后在Git的配置里设置了下文来跳过证书验证，但是由于git优先级的原因，仍旧无法连接github</p></li><li><p>其原因在于git的配置信息具有优先级，所以重新在博客对应的git配置文件中设置下文即可</p><ul><li><p>1、仓库级别 local 【优先级最高】 位置是当前目录下的 <code>.git/config</code></p><p>2、用户级别 global【优先级次之】位置是主目录下的 <code>~/.gitconfig</code> (这个文件里存放有和push pull操作相关的路径)</p><p>3、系统级别 system【优先级最低】位置是根目录下的<code>/etc/gitconfig</code> （这个文件我Ubuntu和MacOS上默认都是不存在的，官网给的路径是<code>$(prefix)/etc/gitconfig</code>,我默认没有<code>$prefix</code>这个变量，所以system层级的配置文件估计是要自己想用时再写。）</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">[http]<br> sslverify = <span class="hljs-literal">false</span><br>[https]<br> sslverify = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>使用Clash Verge无法连接网络</strong></p><ul><li>情况一：需要在windows设置界面选择<strong>关闭使用代理服务器</strong></li><li>情况二：同时开启了UU加速器 加速了STEAM</li></ul><p><strong>使用AirPods连接电脑出现音质过低问题</strong></p><ul><li>删除原来的耳机设备然后重新连接即可</li><li>耳机模式分类<ul><li>「Hands-Free AG Audio」的模式其实是为手机进行适配的，俗称免提AG音频，实现蓝牙免提语音通话的功能，走的SBC编码，而正常电脑使用我们是用不到通话功能的。</li><li>「Stereo（立体声）」设备在蓝牙术语中被称为「高级音频分发配置文件」（Advanced Audio Distribution Profile），或缩写为A2DP，是针对<strong>单方向</strong>传输高质量的双声道立体声设计的。可以简单理解为，音质更高（相对于Hands-free模式）</li></ul></li></ul><p><strong>使用阿里云对象存储配置出错</strong></p><ul><li>area的参数应该是oss-cn-hangzhou而不是oss-cn-hangzhou.aliyuncs.com</li></ul><p><strong>使用git警告warning: LF will be replaced by CRLF in</strong> </p><ul><li>LF和CRLF其实都是换行符，但是不同的是，LF是linux和Unix系统的换行符，CRLF是window 系统的换行符。这就给跨平台的协作的项目带来了问题，保存文件到底是使用哪个标准呢？ git为了解决这个问题，提供了一个”换行符自动转换“的功能，并且这个功能是默认处于”自动模式“即开启状态的。</li><li>这个换行符自动转换会把自动把你代码里 与你当前操作系统不相同的换行的方式 转换成当前系统的换行方式（即LF和CRLF 之间的转换），这样一来，当你提交代码的时候，即使你没有修改过某个文件，也被git认为你修改过了，从而提示”LF will be replaced by CRLF in “</li></ul><p><strong>git在clone过程中总是报错OpenSSL SSL_read: Connection was reset, errno 10054</strong></p><ul><li>原因：电脑中的host文件配置错误的DNS解析</li><li>删除C:\Windows\System32\drivers\etc中的host文件中的github文件相关</li><li>解决方法：git config –global –unset http.<a href="https://github.com.proxy/">https://github.com.proxy</a></li></ul><p><strong>git推送速度慢，并且报错GnuTLS recv error (-110): The TLS connection was non-properly terminated.</strong></p><ul><li>Failed to connect to github.com port 443 after 21091 ms: Timed out</li><li>先删除host中github相关的部分，然后使用下面这个</li><li>解决方法：git config –global –unset http.<a href="https://github.com.proxy/">https://github.com.proxy</a></li></ul><p><strong>内存极少，被联想系统占用</strong></p><ul><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230203140509965.png" alt="image-20230203140509965"></p></li><li><p>禁用上图服务即可</p></li></ul><p><strong>连接校园网失败</strong></p><ul><li>显示错误为代理服务器错误</li><li>解决方法：从windows中设置代理服务器，关闭代理服务器的使用即可</li></ul><p><strong>idea所使用的git插件无论是使用登录还是使用token都显示无法连接到服务器</strong></p><ul><li><p>原因：使用的idea的插件默认选择不使用代理，但是这里需要使用代理来连接github</p><ul><li>这里会发现使用git可以直接push但是使用idea的git插件却不可以，是因为git在宿主机上的windows已经设置了代理连接，但是在idea本身的设置里还没有将代理勾选</li></ul></li><li><p>解决方法：设置对应的git设置，使其使用自动判断是否使用代理</p></li><li><p>解决方法：git config –global –unset http.<a href="https://github.com.proxy/">https://github.com.proxy</a></p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230207134539092.png" alt="image-20230207134539092"></p><p><strong>hexo添加代码块不成功</strong></p><ul><li>原因：无序列表符号和代码块符号解析冲突，导致接下来的解析全部出错</li><li>不要出现无序列表符号和代码块连用的情况</li></ul><p><strong>设置静态IP地址相关</strong></p><ul><li>解决方法：<a href="https://zhuanlan.zhihu.com/p/130984945">VMware虚拟机网络配置-NAT篇 - 知乎 (zhihu.com)</a></li></ul><p><strong>虚拟机无法连接网络</strong></p><ul><li><a href="https://blog.csdn.net/qq_36408196/article/details/103390303">(53条消息) VMware 虚拟机里连不上网的五种解决方案_菜鸟也秃头的博客-CSDN博客_虚拟机系统连不上网</a></li><li>解决方法：VMware中没有设置成NAT模式而是设置成了桥接模式</li></ul><p><strong>报错显示：与终端 pty 主机进程的连接没有响应，终端可能停止工作</strong></p><ul><li>参考资料<ul><li><a href="https://blog.csdn.net/Castlehe/article/details/124196344">(53条消息) vscode使用ssh远程连接失败（及其他问题合集）_与终端pty主机进程的连接没有响应_吨吨不打野的博客-CSDN博客</a></li><li><a href="https://github.com/microsoft/vscode/issues/130320">Connection to terminal’s pty host process is becoming unresponsive · Issue #130320 · microsoft&#x2F;vscode (github.com)</a></li></ul></li><li>设置对应的linux默认终端配置<ul><li><a href="https://blog.csdn.net/weixin_45905650/article/details/121900199">(53条消息) 配置VScode终端_一只嵌入式爱好者的博客-CSDN博客</a></li></ul></li></ul><p><strong>虚拟机挂起后无法通过docker连接</strong></p><ul><li>[(53条消息) 虚拟机挂起之后docker内的容器连接不上_枯玄的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43904316/article/details/109924058#:~:text=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%82%E8%B5%B7%E4%B9%8B%E5%90%8E">https://blog.csdn.net/weixin_43904316/article/details/109924058#:~:text=虚拟机挂起之后</a> docker 内的容器连接不上，需要重启docker,才能连接上。 vi %2Fusr%2Flib%2Fsysctl.d%2F%2F00-system.conf 1)</li><li><a href="https://blog.csdn.net/qq_45297578/article/details/117945769">(53条消息) 解决VMware虚拟机挂起后无法连接docker容器_喜羊羊sk的博客-CSDN博客</a></li></ul><p><strong>配置好SSH密钥后无法通过vscode连接云服务器</strong></p><ul><li>打开前配置的是用管理员身份进行登录，然后调整为兼容模式后就无法登录了</li><li>重新使用管理员身份登录即可</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库相关总结"><a href="#数据库相关总结" class="headerlink" title="数据库相关总结"></a>数据库相关总结</h1><h2 id="第一讲：绪论"><a href="#第一讲：绪论" class="headerlink" title="第一讲：绪论"></a>第一讲：绪论</h2><ul><li>数据模型的组成要素：数据结构（静态特性)，数据操作(动态特性)，完整性约束条件</li><li>任何关系必须满足<strong>实体完整性和参照完整性</strong>两个条件（还有用户自定义完整性）</li><li>层次，网状，关系</li></ul><h2 id="第二讲：关系型数据库"><a href="#第二讲：关系型数据库" class="headerlink" title="第二讲：关系型数据库"></a>第二讲：关系型数据库</h2><ul><li><p>域（domin）：是一组具有相同数据类型的值的集合（类似于数学的取值范围）</p></li><li><p>笛卡尔积：行行相乘</p></li><li><p>元组：一行数据，有n列就n元（向量）</p></li><li><p>分量：一个元组的一个列单元（分量）</p></li><li><p>属性：一列</p></li><li><p>候选码：所有唯一表示的键放一块（可以是好多个，也可以由多个组成一个）</p></li><li><p>全码：所有属性一起才能唯一表示称之为主码</p></li><li><p>主属性：候选码的属性</p></li><li><p><strong>关系模式可以形式化地表示为：</strong>R（U，D，DOM，F）</p><p> R：关系名</p><p> U ：组成该关系的属性名集合</p><p> D ：属性组U中属性所来自的域</p><p> DOM：属性向域的映象集合</p><p> F：属性间的数据依赖关系集合 </p></li><li><p>关系代数运算符</p><ul><li>选择：选择特定行</li><li>投影：输出特定列</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214252997.png" alt="image-20230211214252997"></p><ul><li>连接相关定义</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214910703.png" alt="image-20230211214910703"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214926999.png" alt="image-20230211214926999"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214935965.png" alt="image-20230211214935965"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214948941.png" alt="image-20230211214948941"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211214956483.png" alt="image-20230211214956483"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230211215047974.png" alt="image-20230211215047974"></p><h2 id="第三讲：SQL"><a href="#第三讲：SQL" class="headerlink" title="第三讲：SQL"></a>第三讲：SQL</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230214222518662.png" alt="image-20230214222518662"></p><ul><li><strong>视图</strong><ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据，视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul></li><li>模式（todo）</li><li>删除的相关限制<ul><li>CASCADE 和 RESTRICT</li></ul></li><li>删除附带的情况</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230214223156674.png" alt="image-20230214223156674"></p><ul><li><strong>MySQL数据类型</strong></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230214223234642.png" alt="image-20230214223234642"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"># CLUSTER 表示创建聚蔟索引<br><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>]…)；<br><br># <span class="hljs-keyword">ESCAPE</span>表示指定该符号为转移字符<br><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span>   Course<br><span class="hljs-keyword">WHERE</span>  Cname <span class="hljs-keyword">LIKE</span>‘DB\_<span class="hljs-operator">%</span>i_ _’ <span class="hljs-keyword">ESCAPE</span> ‘\ ’<br>     <br>#这里先用<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>字句按Sno进行分组，然后再用COUNT对每一组计数，<span class="hljs-keyword">HAVING</span>给出了选择组的条件，只有满足条件的组才会被选出    <br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span>  SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span>  <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>；         <br><br><span class="hljs-keyword">HAVING</span>短语与<span class="hljs-keyword">WHERE</span>子句的区别：<br>  作用对象不同；<br>  <span class="hljs-keyword">WHERE</span>子句作用于基表或视图，从中选择满 <br>     足条件的元组；<br> <span class="hljs-keyword">HAVING</span>短语作用于组，从中选择满足条件的组<br><br><br> <br></code></pre></td></tr></table></figure><ul><li>一般情况下<strong>主键会默认创建聚簇索引</strong>，且一张表只允许存在一个聚簇索引</li><li><strong>DISTINCT</strong>表示会去除重复的行</li><li><strong>% 表示任意长度的字符串</strong>。**_ 则表示任意的单个字符**</li><li><strong>Where 子句中是不能用聚集函数作为条件表达式的</strong></li><li><strong>like和&#x3D;的区别</strong><ul><li>like模糊查询，&#x3D;准确查找</li><li>like严格匹配空格，&#x3D;会自动去除多余前缀后缀空格</li></ul></li><li><strong>IS NULL</strong> <strong>或</strong> <strong>IS NOT NULL</strong>其中的is不能用&#x3D;替代</li><li><strong>排序相关</strong><ul><li>升序：ASC；降序：DESC，<strong>缺省值为升序</strong></li><li>当排序列含空值时：<ul><li>ASC：排序列为空值的元组最后显示</li><li>DESC：排序列为空值的元组最先显示</li></ul></li></ul></li><li>当聚集函数遇到空值时，除了count( * )外，都跳过空值只处理非空值</li><li>HAVING短语与WHERE子句的区别：<strong>作用对象不同</strong><ul><li>WHERE子句作用于基表或视图，从中选择满足条件的元组；</li><li>HAVING短语作用于组，从中选择满足条件的组</li></ul></li><li>子查询的限制<ul><li>不能使用 ORDER BY 子句</li><li>层层嵌套方式反映了 SQL 语言的结构，有些嵌套查询可以用连接运算替代；</li></ul></li><li>子查询分类<ul><li>不相关子查询：先内层查询，再外层查询</li><li>相关查询：取得外层中获取一条元组，代入到内层查询中，再查询得到内查询结果，再运行外层查询，然后再取一个元组运算</li></ul></li><li>视图相关<ul><li>视图定义以后，可以当成基本表一样使用，视图定义后，并不执行任何操作，只有在使用视图时，才执行，视图只是虚表，对视图的操作都转化成为对相应基本表的操作</li><li>只能修改行列子视图，其他视图都不能修改</li><li>视图的更新是受限更新<ul><li>1.视图由两个基本表导出，则不可更新:</li><li>2.视图的字段来白聚集函数，不可更新;</li><li>3.视图定义中有GROUP BY或者DISTINCT短语，不允许更新4.定义在视图之上的视图，不允许更新</li></ul></li><li>视图的作用<ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据 </li><li>视图对重构数据库提供了一定程度的逻辑独立性 </li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul></li></ul></li></ul><h2 id="第四章：数据库安全性"><a href="#第四章：数据库安全性" class="headerlink" title="第四章：数据库安全性"></a>第四章：数据库安全性</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span>  <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span>   <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]<br><span class="hljs-keyword">TO</span>   <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION];#设置能否传递数据<br><br>#授予的权限可以由DBA或其他授权者用<span class="hljs-keyword">REVOKE</span>语句收回<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...;<br><br>#对创建数据库模式一类的数据库对象的授权由DBA在创建用户时实现<br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">USER</span>  <span class="hljs-operator">&lt;</span>username<span class="hljs-operator">&gt;</span> <br>［<span class="hljs-keyword">WITH</span>］［DBA <span class="hljs-operator">|</span> RESOURCE <span class="hljs-operator">|</span> <span class="hljs-keyword">CONNECT</span>］<br><br>#角色的创建<br><span class="hljs-keyword">CREATE</span>  ROLE  <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span> <br>#对角色授权 <br> <span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>［，<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>］… <br> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> 对象名  <br>  <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>［，<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>］…<br><br>#对修改SC表结构或修改SC表数据的操作进行审计<br>AUDIT <span class="hljs-keyword">ALTER</span>，<span class="hljs-keyword">UPDATE</span>  <br><span class="hljs-keyword">ON</span>  SC；<br><br># 取消对SC表的一切审计<br>NOAUDIT  <span class="hljs-keyword">ALTER</span>，<span class="hljs-keyword">UPDATE</span>  <br><span class="hljs-keyword">ON</span>  SC；<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\小赵同学\AppData\Roaming\Typora\typora-user-images\image-20230215010656553.png" alt="image-20230215010656553"></p><ul><li><p><strong>常用存取控制方式</strong></p><ul><li>自主存取控制（Discretionary Access Control,DAC）</li><li>强制存取控制（Mandatory Access Control, MAC）</li></ul></li><li><p>对创建数据库模式一类的数据库对象的授权由DBA在创建用户时实现</p></li><li><p><strong>创建数据库模式的权限</strong></p><ul><li>具有CONNECT特权的用户：不能创建新用户，不能创建模式和基本表，可以与数据库连接，能根据授权进行数据库中数据的查询、更新。</li><li>具有RESOURCE特权的用户除具有CONNECT特权外，还能创建表、索引，修改表结构，将自己创建的数据对象的访问权授予其他用户或从其他用户那儿收回，对自己创建的数据对象能进行跟踪审查。 </li><li>具有DBA特权的用户能进行所有的数据库操作</li></ul></li><li><p><strong>数据库角色</strong>：被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合 </li><li>可以为一组具有相同权限的用户创建一个角色</li><li>使用角色来管理数据库权限可以简化授权的过程</li></ul></li><li><p><strong>强制存取控制（Mandatory Access Control,MAC）</strong></p><ul><li>每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的权限，对于任意一个数据对象，只有具有合法许可证的用户才可以存取</li><li>保证更高程度的安全性</li><li>用户不能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门</li><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li><li>仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体</li><li>禁止了拥有高许可证级别的主体更新低密级的数据对象。    </li><li>强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级要求的用户才可以操作数据，从而提供了更高级别的安全性</li></ul></li><li><p>还可以通过使用户观察视图而非控制原表格来实现</p></li><li><p>审计功能</p><ul><li>审计功能是数据库管理系统达到C2以上安全级别必不可少的一项指标<br>审计功能是把用户对数据库的所有操作自动记录下来放入审计日志（audit log）中，审计员可以利用审计日志监控数据库的各种行为，找出非法数据的人、时间和内容，对潜在的威胁提前采取措施加以防范。<br>审计通常很费时间和空间，所以数据库管理系统往往都将审计设置为可选特征，允许数据库管理员根据具体应用对安全性的要求灵活地打开或者关闭审计功能。 </li><li>数据库安全审计系统提供了一种事后检查的安全机制，将特定用户或者特定对象相关的操作记录到审计日志中，作为后续对操作的查询分析和追踪的依据</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230215083646154.png" alt="image-20230215083646154"></p><h2 id="第五章：数据库完整性"><a href="#第五章：数据库完整性" class="headerlink" title="第五章：数据库完整性"></a>第五章：数据库完整性</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建对应断言来简化条件筛选<br><span class="hljs-keyword">CREATE</span>  ASSERTION  ASSE_SC_DB_NUM<br><span class="hljs-keyword">CHECK</span> (  <span class="hljs-number">60</span><span class="hljs-operator">&gt;=</span> (  <span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> Course, SC<br><span class="hljs-keyword">WHERE</span> SC.Cno<span class="hljs-operator">=</span>Course.Cno  <span class="hljs-keyword">AND</span>  Course.Cname<span class="hljs-operator">=</span>‘数据库’  )  )；<br>#触发器的创建相关<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span>  <br>    &#123; BEFORE <span class="hljs-operator">|</span> AFTER &#125;  <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>          <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span>  &#123; <span class="hljs-type">ROW</span> <span class="hljs-operator">|</span> STATEMENT &#125;<br>       ［ <span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>］  <span class="hljs-operator">&lt;</span> 触发动作体 <span class="hljs-operator">&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>实体完整性<ul><li>主码的值必须不为空且唯一</li></ul></li></ul><h2 id="第六章：关系数据理论"><a href="#第六章：关系数据理论" class="headerlink" title="第六章：关系数据理论"></a>第六章：关系数据理论</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230215100818862.png" alt="image-20230215100818862"></p><h2 id="第八章：数据库恢复技术"><a href="#第八章：数据库恢复技术" class="headerlink" title="第八章：数据库恢复技术"></a>第八章：数据库恢复技术</h2><ul><li><strong>为什么要先写入日志</strong><ul><li>写数据库和写日志文件是两个不同的操作在这两个操作之间可能发生故障</li><li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li><li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性</li></ul></li><li>数据库恢复的流程<ul><li>撤销（Undo）故障发生时未完成的事务；</li><li>重做（Redo）已完成的事务。</li></ul></li><li><strong>redo日志和undo日志的本质区别</strong>（数据丢失时回复的流程）<ul><li><strong>重做(REDO)队列</strong>在故障发生前已经提交的事务，这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录</li><li><strong>撤销 (Undo)队列</strong>故障发生时尚未完成的事务，这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230215090521946.png" alt="image-20230215090521946"></p><ul><li>数据库恢复步骤<ul><li>1、正向扫描日志文件（即从头扫描日志文件）<ul><li><strong>重做(REDO)队列</strong>在故障发生前已经提交的事务，这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录</li><li><strong>撤销 (Undo)队列</strong>故障发生时尚未完成的事务，这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录</li></ul></li><li>2、对撤销(Undo)队列事务进行撤销(UNDO)处理<ul><li>反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库</li></ul></li><li>3、对重做(Redo)队列事务进行重做(REDO)处理<ul><li>正向扫描日志文件，对每个REDO事务重新执行登记的操作， 即将日志记录中“更新后的值”写入数据库</li></ul></li></ul></li><li>使用检查点方法可以改善恢复效率<ul><li>当事务 T 在一个检查点之前提交，T 对数据库所做的修改已写入数据库，写入时间是在这个检查点建立之前或在这个检查点建立之时，在进行恢复处理时，没有必要对事务T执行REDO操作。</li></ul></li><li><strong>动态维护日志文件</strong>的方法：周期性地执行如下操作：建立检查点，保存数据库状态<ul><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上；</li><li>在日志文件中写入一个检查点记录；</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中；</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件。</li></ul></li><li>冗余磁盘阵列(Redundent Array of Independent Disks，RAID)<ul><li>RAID将一组磁盘驱动器用某种逻辑方式联系起来，作为逻辑上的一个磁盘驱动器来使用。</li><li>一般情况下，组成的逻辑磁盘驱动器的容量要小于各个磁盘驱动器容量的总和。</li><li>RAID通过冗余技术，提供一个高级别的数据保护。</li><li>RAID的具体实现可以靠硬件也可以靠软件，Windows NT操作系统就提供软件RAID功能。</li><li>优点<ul><li>成本低，功耗小，传输速率高 </li><li>可以提供容错功能 </li><li>具备数据校验（Parity）功能 </li><li>RAID比起传统的大直径磁盘驱动器来，在同样的容量下，价格要低许多</li></ul></li></ul></li></ul><h2 id="第九讲：并发控制"><a href="#第九讲：并发控制" class="headerlink" title="第九讲：并发控制"></a>第九讲：并发控制</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230214230209638.png" alt="image-20230214230209638"></p><ul><li>依赖的事务构成了环则为死锁，可以撤销代价小的事务解决</li><li><strong>两段锁协议</strong><ul><li><strong>第一阶段是获得封锁</strong>，也称为扩展阶段</li><li>事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 </li><li><strong>第二阶段是释放封锁</strong>，也称为收缩阶段</li><li>事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li></ul></li><li><strong>意向锁</strong><ul><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li><li>对任一结点加基本锁，必须先对它的上层结点加意向锁<ul><li>例：对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</li></ul></li><li>SIX锁<ul><li>如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁， 即SIX &#x3D; S + IX。（只和IS锁相容）</li><li>对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）</li><li>之所以其只和is锁相容是因为IX锁只和IS和IX锁相容</li><li>IX锁和IX锁相容是因为两者都只是意向锁</li></ul></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230214231333195.png" alt="image-20230214231333195"></p><h2 id="第十章：数据库设计"><a href="#第十章：数据库设计" class="headerlink" title="第十章：数据库设计"></a>第十章：数据库设计</h2><ul><li><p>数据库设计分6个阶段<br>① 需求分析<br>② 语义数据库建模（概念结构设计）<br>③ 逻辑结构设计<br>④ 物理结构设计<br>⑤ 数据库实现<br>⑥ 数据库运行管理与维护 </p></li><li><p>需求分析和概念设计独立于任何数据库管理系统 </p></li><li><p>逻辑设计和物理设计与选用的DBMS密切相关</p></li><li><p>数据字典的用途</p><ul><li>进行详细的数据收集和数据分析所获得的主要结果</li></ul></li><li><p>数据字典的内容</p></li><li><p>数据项</p></li><li><p>数据结构</p></li><li><p>数据流</p></li><li><p>数据存储</p></li><li><p>处理过程</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>数据库系统的<strong>特点</strong></p><ul><li>数据结构化；数据的共享性高，冗余度低，易扩充；数据独立性高；数据由DBMS统一管理和控制</li></ul></li><li><p>数据模型分为<strong>两类</strong>（分属两个不同的层次）</p><ul><li>概念模型   也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。 </li><li>逻辑模型和物理模型   <ul><li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。<br>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul></li></ul></li><li><p>数据模型的组成要素：数据结构 ；数据操作；完整性约束条件</p></li><li><p>关系数据模型的优缺点</p><ul><li>优点<ul><li>建立在严格的数学概念的基础上</li><li>概念单一</li><li>实体和各类联系都用关系(即表)来表示，对数据的检索结果也是关系</li><li>关系模型的存取路径对用户透明</li><li>具有更高的数据独立性，更好的安全保密性简化了程序员的工作和数据库开发建立的工作</li></ul></li><li>缺点<ul><li>存取路径对用户透明导致查询效率往往不如非关系数据模型</li><li>为提高性能，必须对用户的查询请求进行优化增加了开发DBMS的难度</li></ul></li></ul></li><li><p>先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有通过MAC检查的数据对象方可存取。</p></li><li><p>两段锁协议</p><ul><li>指所有事务必须分两个阶段对数据项加锁和解锁 </li><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul></li><li><p>封锁对象的大小称为封锁粒度(Granularity)<br>封锁的对象：逻辑单元，物理单元<br>封锁粒度与系统的并发度和并发控制的开销密切相关。<br>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；<br>封锁的粒度越小，并发度较高，但系统开销也就越大</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/2023java%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/2023java%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java相关知识点"><a href="#Java相关知识点" class="headerlink" title="Java相关知识点"></a>Java相关知识点</h1><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><ul><li>java版本</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230112160650946.png" alt="image-20230112160650946"></p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230112160706188.png" alt="image-20230112160706188"></p><ul><li>HashMap的遍历方式<ul><li><a href="https://cloud.tencent.com/developer/article/1623343">HashMap 的 7 种遍历方式与性能分析！(强烈推荐) - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代器方式</span><br>Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            Map.Entry&lt;Integer, String&gt; next = iterator.next();<br>            System.out.println(next.getKey());<br>            System.out.println(next.getValue());<br>        &#125;<br><br><span class="hljs-comment">//迭代器单独遍历Key</span><br>Iterator&lt;Integer&gt; iterator = map.keySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.print(key);<br>            System.out.print(map.get(key));<br>        &#125;<br><br><span class="hljs-comment">//foreach-entry整体遍历</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer,String&gt; entry: map.entrySet())&#123;<br>      System.out.println(<span class="hljs-string">&quot;entry.getKey() = &quot;</span> + entry.getKey());<br>      System.out.println(<span class="hljs-string">&quot;entry.getValue() = &quot;</span> + entry.getValue());<br>  &#125;<br><br><span class="hljs-comment">//foreach-Key单独遍历</span><br><span class="hljs-keyword">for</span> (Integer key: map.keySet() )&#123;<br>      System.out.println(key);<br>      System.out.println(map.get(key));<br>  &#125;<br><br><span class="hljs-comment">//lambma表达式</span><br>map.forEach((key,value) -&gt; &#123;<br>            System.out.print(key);<br>            System.out.print(value);<br>  &#125;);<br><br><span class="hljs-comment">//Stream单线程</span><br> map.entrySet().stream().forEach((integerStringEntry -&gt; &#123;<br>            System.out.println(integerStringEntry.getKey());<br>            System.out.println(integerStringEntry.getValue());<br>  &#125;));<br><br><br><span class="hljs-comment">//Stream多线程</span><br>map.entrySet().parallelStream().forEach((integerStringEntry -&gt; &#123;<br>            System.out.println(integerStringEntry.getKey());<br>            System.out.println(integerStringEntry.getValue());<br>   &#125;));<br></code></pre></td></tr></table></figure><ul><li>字符串的compareto方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ad&quot;</span>;        <br>System.out.println(a1.compareTo(a2));<span class="hljs-comment">//结果为-3</span><br><span class="hljs-comment">//并且注意在比较两个长度不同的字符串时</span><br><span class="hljs-comment">//比较结果是纯纯的字典序比较，每次返回的结果都只是一位一位的结果，也就是说对于一个特别长的字符串，实际上有用的比较部分只有后面</span><br><span class="hljs-comment">//严格类比字典即可</span><br></code></pre></td></tr></table></figure><ul><li><p>迭代器</p><ul><li><p>Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 和 <a href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 等集合。</p><p>Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建集合</span><br>        ArrayList&lt;String&gt; sites = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        sites.add(<span class="hljs-string">&quot;Google&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;Runoob&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;Taobao&quot;</span>);<br>        sites.add(<span class="hljs-string">&quot;Zhihu&quot;</span>);<br><br>        <span class="hljs-comment">// 获取迭代器</span><br>        Iterator&lt;String&gt; it = sites.iterator();<br><br>        <span class="hljs-comment">// 输出集合中的所有元素</span><br>        <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双端队列Deque方法辨析</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230122212131179.png" alt="image-20230122212131179"></p><ul><li><p><strong>java字符串split相关</strong></p><ul><li><p>split() 方法根据匹配给定的正则表达式来拆分字符串。</p><p><strong>注意：</strong> <strong>.</strong> 、 **$**、 <strong>|</strong> 和 ***** 等转义字符，必须得加 <strong>\</strong>。</p><p><strong>注意：</strong>多个分隔符，可以用 <strong>|</strong> 作为连字符。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1122/1113///66&quot;</span>;  <span class="hljs-comment">//相当于把空字符串也看成字符串了</span><br>        String[] res = s.split(<span class="hljs-string">&quot;/&quot;</span>);  <span class="hljs-comment">//输出结果为6</span><br>        System.out.println(Arrays.toString(res));<br>        System.out.println(res.length);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="系统优化相关"><a href="#系统优化相关" class="headerlink" title="系统优化相关"></a>系统优化相关</h2><ul><li>局部性原理<ul><li><strong>程序局部性原理</strong>：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。<ul><li><strong>时间局部性：</strong>被引用过一次的存储器位置在未来会被多次引用（通常在循环中）</li></ul></li><li><strong>空间局部性：</strong>如果一个存储器的位置被引用，那么将来他附近的位置也会被引用</li></ul></li></ul><h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><ul><li>死锁的四个必要条件<ul><li>1、 互斥条件：<br>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>2、不可剥夺条件:<br>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li><li>3、 请求与保持条件：<br>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>4、循环等待条件:<br>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示</li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>limit语句相关<ul><li>当更新语句中的where字段没有索引的时候，如果没有使用limit的话会锁全表；而如果使用了limit的话，mysql会通过主键索引找到对应的行记录，此时只会给索引搜寻过的行加上行锁，并不会把后面的行给锁住</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> limit m,n<br>#其中m是指记录开始的index，从<span class="hljs-number">0</span>开始，表示第一条记录<br>#n是指从第m<span class="hljs-operator">+</span><span class="hljs-number">1</span>条开始，取n条。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tablename limit <span class="hljs-number">2</span>,<span class="hljs-number">4</span><br>#即取出第<span class="hljs-number">3</span>条至第<span class="hljs-number">6</span>条，<span class="hljs-number">4</span>条记录<br></code></pre></td></tr></table></figure><ul><li>select  for update相关<ul><li>我们平时使用的select语句只是查询，不涉及修改，故不存在加锁的概念。而select * for update 从字面意思就可以知道，该语句不单单是查询，而是为了后续的修改，所以是要对数据加锁的，并且是<strong>悲观锁</strong>。此时按照select 中where条件字段，又可分为行锁和表锁</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/gin/"/>
    <url>/2023/03/06/gin/</url>
    
    <content type="html"><![CDATA[<h1 id="gin框架学习"><a href="#gin框架学习" class="headerlink" title="gin框架学习"></a>gin框架学习</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/%E7%AE%80%E4%BB%8B.html">简介 · Go语言中文文档 (topgoer.com)</a></li></ul><h2 id="Restful风格"><a href="#Restful风格" class="headerlink" title="Restful风格"></a>Restful风格</h2><ul><li>gin支持Restful风格的API</li><li>即Representational State Transfer的缩写。直接翻译的意思是”表现层状态转化”，是一种互联网应用程序的API设计理念：URL定位资源，用HTTP描述操作<ul><li>获取文章 &#x2F;blog&#x2F;getXxx Get blog&#x2F;Xxx</li><li>添加 &#x2F;blog&#x2F;addXxx POST blog&#x2F;Xxx</li><li>修改 &#x2F;blog&#x2F;updateXxx PUT blog&#x2F;Xxx</li><li>删除 &#x2F;blog&#x2F;delXxxx DELETE blog&#x2F;Xxx</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/javaGuide/"/>
    <url>/2023/03/06/javaGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaGuide精华总结"><a href="#JavaGuide精华总结" class="headerlink" title="JavaGuide精华总结"></a>JavaGuide精华总结</h1><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><ul><li><p>不建议使用外键和级联，应该在应用层面解决对应问题（外键增加工作量并且对分库分表不友好），但也不绝对</p></li><li><p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)</p></li><li><p>drop，truncate，delete的区别</p><ul><li><p>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</p></li><li><p>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</p></li><li><p>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似</p></li><li><p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效</p><ul><li><p>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</p><p>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用</p></li></ul></li></ul></li><li><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库</strong></p></li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li><h3 id="TCP-与-UDP-的区别（重要）"><a href="#TCP-与-UDP-的区别（重要）" class="headerlink" title="TCP 与 UDP 的区别（重要）"></a>TCP 与 UDP 的区别（重要）</h3><ol><li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li><li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</li><li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li><li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多</li></ol></li><li><p><strong>运行于 TCP 协议之上的协议</strong> ：</p><ol><li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li><li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li><li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li><li><strong>POP3&#x2F;IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li><li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li><li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li></ol></li><li><p><strong>运行于 UDP 协议之上的协议</strong> ：</p><ol><li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li><li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议</li></ol></li><li><p><strong>浏览器解析URL过程发生的事情</strong></p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118082249094.png" alt="image-20221118082249094"></p></li><li><h3 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 有什么区别？</h3><ul><li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host头处理</strong> : HTTP&#x2F;1.1在请求头中加入了<code>Host</code>字段。</li></ul></li><li><h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p>**Cookie 被禁用怎么办?**（TODO：更多情况分析以及对session和cookie相关）</p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面</p></li><li><h3 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="什么是 Mac 地址？"></a>什么是 Mac 地址？</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识</p><p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p><blockquote><p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p></blockquote><p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p><p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p><p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p></li><li><h3 id="ARP-协议解决了什么问题地位如何？"><a href="#ARP-协议解决了什么问题地位如何？" class="headerlink" title="ARP 协议解决了什么问题地位如何？"></a>ARP 协议解决了什么问题地位如何？</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题</p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118083427333.png" alt="image-20221118083427333"></p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/osi-model-detail.png" alt="image-20221118083446716"></p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118083446716.png" alt="osi-model-detail"></p></li><li><p><strong>简化后的网络分层模型</strong></p><ul><li><p>应用层（Application Layer）：</p><ul><li><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文，应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</li></ul></li><li><p>传输层（Transport layer）：</p><ul><li><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务</li></ul></li><li><p>网络层（network layer）</p><ul><li><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报</p></li><li><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p></li><li><p><strong>网络层常见协议</strong> ：</p><ul><li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（<strong>Address Resolution Protocol</strong>），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li><li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置</li></ul></li></ul></li><li><p>网络接口层</p><ul><li><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p></li><li><p>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></p><p><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></p></li></ul></li></ul></li><li><p><strong>常见应用层协议总结</strong></p><ul><li><p><strong>HTTP超文本传输协议</strong></p></li><li><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong></p></li><li><p><strong>电子邮件的发送过程？</strong></p><p>比如我的邮箱是“<a href="mailto:&#100;&#x61;&#98;&#x61;&#105;&#64;&#99;&#x73;&#122;&#104;&#105;&#110;&#x61;&#x6e;&#46;&#x63;&#111;&#x6d;">&#100;&#x61;&#98;&#x61;&#105;&#64;&#99;&#x73;&#122;&#104;&#105;&#110;&#x61;&#x6e;&#46;&#x63;&#111;&#x6d;</a>”，我要向“<a href="mailto:&#120;&#x69;&#x61;&#111;&#109;&#97;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;">&#120;&#x69;&#x61;&#111;&#109;&#97;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;</a>”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#105;&#97;&#x6f;&#109;&#97;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#105;&#97;&#x6f;&#109;&#97;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;</a>”的用户来收邮件，然后用户就通过 <strong>POP3&#x2F;IMAP</strong> 协议将邮件取出。</li></ol><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol></li><li><p><strong>文件传输协议FTP</strong></p></li><li><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote></li><li><p><strong>Telnet协议</strong></p></li><li><p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p></li><li><p><strong>SSH协议</strong></p></li><li><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<strong>SSH 建立在可靠的传输协议 TCP 之上。</strong></p></li><li><p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p></li><li><p>POP3&#x2F;IMAP协议：用于接收邮件</p><ul><li><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3&#x2F;IMAP。</strong></p><p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p></li></ul></li></ul></li><li><p>TCP三次握手四次挥手</p><ul><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221117192907693.png" alt="image-20221122175704470"></p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122175704470.png" alt="image-20221122175720755"></p></li><li><p>如果第三次握手丢失会怎样？（TODO ：TCP的具体超时重传机制）</p><ul><li>由于TCP不会为没有数据的ACK超时重传，所以A不会重传ACK，而是会由B一直超时重传第二次握手</li></ul></li><li><p>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</p><ul><li>客户端没有收到 ACK 确认，会重新发送 FIN 请求</li></ul></li><li><p>为什么第四次挥手客户端需要等待 2<em>MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</em></p><ul><li>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。（电脑关了结果服务器以为你没关，就一直发消息）</li></ul><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></blockquote></li><li><p>TCP 如何保证传输的可靠性？</p><ol><li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : <strong>当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传</strong></li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li><li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送</li></ol></li><li><p>TCP中的<strong>Initial Sequence Number</strong>（即上图SEQ）生成规则</p><ul><li><p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><ul><li>M是一个计时器，这个计时器每隔4毫秒加1。</li><li>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择</li></ul></li><li><p>ISN不能固定的原因</p><ul><li><p>从攻击的角度：</p><ul><li>TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续的序列号，从而遭到攻击</li></ul></li><li><p>从TCP连接稳定角度：</p><ul><li>广域网的随机性，复杂性都很高，假设client与server连接状况不好，不停的断开又重连。那么之前交互的报文很可能在连接已断开时还没到达server。如果ISN是固定的，那很可能在新连接建立后，上次连接通信的报文才到达server，这种情况有概率发生上次连接发送的报文的seq序列号正好是server希望收到的新连接的报文seq序列号。这就全乱了</li></ul></li></ul></li></ul></li><li><p>为什么必须是三次握手而不能简化为两次握手</p><ul><li>如果只有前两次握手，则只能确定A和B在A的初始序列号达成了一致但是不能确定A和B在B的初始序列号达成一致</li></ul></li></ul></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>+ </p><h2 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h2><ul><li><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用</p></li><li><p>java为什么是编译和解释共存的语言</p><ul><li>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行</li></ul></li><li><p>静态方法为什么不能调用非静态资源</p><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</li></ul></li><li><p>方法的重写要遵循“两同两小一大”</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li><li><p>可变长参数</p><ul><li>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高</li><li>Java 的可变参数编译后实际会被转换成一个数组</li></ul></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122175720755.png" alt="image-20221117192907693"></p></li><li><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。<ul><li><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</li></ul></li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li><li><strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中（TODO 基本类型的数据存放位置）</li></ul></li><li><p>包装类型的缓存机制了解么？</p><ul><li>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</li><li>Byte<code>,</code>Short<code>,</code>Integer<code>,</code>Long<code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，</code>Character<code> 创建了数值在 [0,127] 范围的缓存数据，</code>Boolean<code>直接返回</code>True<code>or</code>False</li></ul></li><li><p>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p><ul><li><p>避免有时由于包装类型缓存池的影响导致错误的结果产生</p></li><li><p>&#96;&#96;&#96;java<br>public static void main(String[] args) {<br>    Integer i1 &#x3D; 1;<br>    Integer i2 &#x3D; 1;<br>    System.out.println(i1 &#x3D;&#x3D; i2);<br>}<br>&#x2F;&#x2F;输出true，因为引用的是常量池中的同一个对象</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>+ 构造方法不能被 <span class="hljs-keyword">override</span>（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况<br><br>+ ```java<br>  <span class="hljs-comment">//object equals的默认实现</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>String、StringBuffer、StringBuilder 的区别</p><ul><li><p><code>String</code> 是不可变的（后面会详细分析原因）。（TODO ： 使用字节数组实现string和char数组实现的区别）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p></li><li><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险</p></li></ul></li><li><p>string不可变的原因</p><ul><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变</li></ul></li><li><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。（Latin-1相当于是对传统意义上的ASCII码的扩展，传统ASCII只使用了其中的7位，最后一位补0，而Latin-1使用了其中的8位）</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符</p><ul><li>由于Latin-1 只使用了单字节用于编码，换言之可以将任何其他编码转换成单字节编码的Latin-1 进行传输</li></ul></li><li><p>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>（建议在这种情况下直接使用stringbuilder对象进行操作）</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/git%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Git GUI Here：打开Git图形界面</p><p>Git Bash Here：打开Git命令行</p><p>git中仓库不能进行嵌套</p><p>Git相关命令：</p><ul><li>设置用户信息：(这里的设置只是本地的设置，和github或者gitee的账号不同)<ul><li>git config –global user.name “name”</li><li>git config –global user.email  “4he @ qq.com “</li></ul></li><li>查看配置信息：git config –list</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/LeetCode%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/LeetCode%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode题目笔记"><a href="#LeetCode题目笔记" class="headerlink" title="LeetCode题目笔记"></a>LeetCode题目笔记</h1><h2 id="138：邻值查找"><a href="#138：邻值查找" class="headerlink" title="138：邻值查找"></a>138：邻值查找</h2><ul><li>双链表维护排序好的数组，倒序删除对应的元素</li><li>存放对应结点的索引位置</li></ul><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><h3 id="逆波兰表达式相关"><a href="#逆波兰表达式相关" class="headerlink" title="逆波兰表达式相关"></a>逆波兰表达式相关</h3><p>链表相关</p><p>84</p><p>42(接雨水，方块题)</p><p>接雨水（横条和竖条分析）</p><p>239</p><p>1248</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/LeetCode%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/LeetCode%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>如果双指针是往一个方向移动则需要注意当指针移动到0的情况，如果两个指针往一个方向进行移动则不需要判断边界为0的情况</p><p>根据题意，如果没有对题目的所有要求都进行使用则说明没有达到最高性能</p><p>题目中出现定长数组比较问题考虑滑动数组</p><p>使用快慢指针来判断是否出现循环相比于使用哈希表而言能够使用更少的空间</p><p>动态规划即规避重复的计算，通过使用额外的数据空间来保存计算的中间结果，故也将动态规划称之为记忆化检索(recursion with memoization)，即使用空间换时间，也可以理解成带“备忘录”的递归，或者称之为递归树的“剪枝”</p><p>for循环中++i和i++的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (语句<span class="hljs-number">1</span>; 语句<span class="hljs-number">2</span>; 语句<span class="hljs-number">3</span>)<br>  &#123;<br>  被执行的代码块<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>语句 1 在循环（代码块）开始前执行</li><li>语句 2 定义运行循环（代码块）的条件</li><li>语句 3 在循环（代码块）已被执行之后执行</li></ul><p>这就是循环中的++i和i++结果一样的原因，但是性能不一样，在大量数据的时候++i的性能要比i++的性能好原因： i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。 而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能</p><p>创建一个对象数组，即使给定了对应的对象数组的长度，对象数组中的元素也依然是null</p><p><strong>前缀树：</strong></p><ul><li>所谓前缀树实际上就是26叉树</li><li>实际上前缀树的使用相对广泛，在倒排索引和区块脸当中都有所应用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-comment">//如果当前节点的isEnd为true，则说明从根结点遍历到该节点的过程中产生的对应字符串是存在的</span><br>    <span class="hljs-comment">//即实际上是通过这个变量来判断前缀树中是否存在目标字符串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-comment">//获取到单词的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-comment">//转换成对应的下标</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//如果对应下标下面没有数字，则实例化对应结点</span><br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            <span class="hljs-comment">//并将下一次循环的起点设置为该起点</span><br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要使用递归的过程中同时对同一个变量进行操作，那么要么将这个变量作为静态变量，要么在递归调用时将这个变量作为参数进行传递</p><p>前缀表达式称之为波兰式，后缀表达式称之为逆波兰式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Linux%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/06/Linux%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="配置文件总结"><a href="#配置文件总结" class="headerlink" title="配置文件总结"></a>配置文件总结</h1><h2 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h2><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf --restart=always -d redis redis-server /etc/redis/redis.conf</span><br></code></pre></td></tr></table></figure><ul><li>相关报错问题总结<ul><li>报错没有指定路径<ul><li>由于image中本身没有配置文件中的路径，需要进入容器后手动创建</li></ul></li><li>报错信息查看方式<ul><li>使用docker logs + 容器名称查看</li></ul></li></ul></li></ul><h3 id="GVM安装"><a href="#GVM安装" class="headerlink" title="GVM安装"></a>GVM安装</h3><ul><li>权限不足<ul><li>chmod 添加相关指令</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/06/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#注意表之间的连接是在<span class="hljs-keyword">from</span>后声明了就可以使用这两个表之间的数据<br>#<span class="hljs-keyword">where</span>中的表达式只是用来显示两者满足该条件才输出的条件<br><span class="hljs-keyword">SELECT</span> e.last_name, e.salary, j.grade_level <br><span class="hljs-keyword">FROM</span> employees e, job_grades j <br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-keyword">BETWEEN</span> j.lowest_sal <span class="hljs-keyword">AND</span> j.highest_sal;<br></code></pre></td></tr></table></figure><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接</strong>  没有匹配的行时, 结果表中相应的列为空(NULL)</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">#左上图：左外连接<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br>#右上图：右外连接 <br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name <br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d <br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br>#注意连接的方式只取决于<span class="hljs-number">1</span>、左连接还是右链接 <span class="hljs-number">2</span>、<span class="hljs-keyword">JOIN</span>的左右分布<br>#连接方式并不和左右“主语”有关<br></code></pre></td></tr></table></figure><p>多表查询中出现重名字段出现歧义的时候，必须用表名进行指定相关的表名</p><p>建议当出现重名字段时，可以在所有的重名字段前面都加上对应的表名，提高性能</p><ul><li>on限定的是待连接的两个表变为合并后  “待筛选表”  的筛选条件</li><li>where限定的是合并后  “待筛选表”  进一步筛选出所需结果的筛选条件</li></ul><p>注意当筛选结果中存在  “关键词”  时，需要使用外连接对多表进行查询（若使用内连接，则若多表之间一个有数据，一个没数据，导致部分待筛选项缺漏）</p><p>由于在数据库中查询表项本身就隐含 “循环” 的思想，故不需要使用循环相关的流程控制语句</p><p>连续两个字段之间使用空格相连接即为“起别名”</p><p>调用count（）方法中的参数，只有参数非null时才会进行计数</p><p>ifnull函数不仅有判断的作用，而且可以将其理解为用程序员自定义的值替换原null值   </p><p>例如IFNULL(name，0)的作用即为，若name是空，则使用0将其进行替代</p><p>group by a,b   表示的是根据a,b两种表项的所有组合形式进行分组，至于a,b的顺序无关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id,job_id,<span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br><br>#结论<span class="hljs-number">1</span>：<span class="hljs-keyword">SELECT</span>中出现的非组函数的字段必须声明在<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 中反之，<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>中声明的字段可以不出现在<span class="hljs-keyword">SELECT</span>中<br>#结论<span class="hljs-number">2</span>：<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 声明在<span class="hljs-keyword">FROM</span>后面、<span class="hljs-keyword">WHERE</span>后面，<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 前面、LIMIT前面<br>#结论<span class="hljs-number">3</span>：MySQL中<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>中使用<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span><br></code></pre></td></tr></table></figure><ul><li>当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中</li><li>当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以  但是，建议大家声明在WHERE中</li></ul><p><strong>WHERE 与 HAVING 的对比：</strong></p><ul><li>从适用范围上来讲，HAVING的适用范围更广</li><li>如果过滤条件中没有聚合函数：这种情况下，WHERE的执行效率要高于HAVING</li></ul><p>注意字段相应的使用范围和字段应该声明到的位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-keyword">sql</span>标准使用格式<br><br>#sql92语法：<br><span class="hljs-keyword">SELECT</span> ....,....,....(存在聚合函数)<br><span class="hljs-keyword">FROM</span> ...,....,....<br><span class="hljs-keyword">WHERE</span> 多表的连接条件 <span class="hljs-keyword">AND</span> 不包含聚合函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,....<br><span class="hljs-keyword">HAVING</span> 包含聚合函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ....,...(<span class="hljs-keyword">ASC</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">DESC</span> )<br>LIMIT ...,....<br><br>#sql99语法：<br><span class="hljs-keyword">SELECT</span> ....,....,....(存在聚合函数)<br><span class="hljs-keyword">FROM</span> ... (<span class="hljs-keyword">LEFT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">RIGHT</span>)<span class="hljs-keyword">JOIN</span> ....<span class="hljs-keyword">ON</span> 多表的连接条件 <br>(<span class="hljs-keyword">LEFT</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">RIGHT</span>)<span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ....<br><span class="hljs-keyword">WHERE</span> 不包含聚合函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,....<br><span class="hljs-keyword">HAVING</span> 包含聚合函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ....,...(<span class="hljs-keyword">ASC</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">DESC</span> )<br>LIMIT ...,....<br><br>#<span class="hljs-number">4.2</span> <span class="hljs-keyword">SQL</span>语句的执行过程：<br><br>#<span class="hljs-keyword">FROM</span> ...,...<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">LEFT</span><span class="hljs-operator">/</span>RIGNT  <span class="hljs-keyword">JOIN</span>) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> LIMIT<br></code></pre></td></tr></table></figure><p>一般来说单次查询消耗的时间要小于两次查询所消耗的时间</p><p><strong>返回</strong>的数据只有一条时即称之为单行子查询，即所谓单行多行取决于返回的数值的个数</p><p>子查询的编写可以选择从内往外写，先编写出所需数据的对应代码，再写出外部查询对应的代码，然后将子查询嵌入外部查询即可</p><p>如果子查询结果是空，则子查询结果不返回任何数据</p><p>单行函数可以嵌套使用，但是在mysql中聚合函数不是能嵌套使用</p><p>子查询的实质是多次查询，将首次查询所得的数据项看成是新的待筛选范围，然后再进行筛选</p><p>子查询所使用的位置丰富</p><p>相关子查询指的是子查询在查询的过程中需要使用到外部查询的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">#在<span class="hljs-keyword">FROM</span>中声明子查询,查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id<br><span class="hljs-keyword">SELECT</span> e.last_name,e.salary,e.department_id<br><span class="hljs-keyword">FROM</span> employees e,(<br><span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) avg_sal<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) t_dept_avg_sal<br><span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> t_dept_avg_sal.department_id<br><span class="hljs-keyword">AND</span> e.salary <span class="hljs-operator">&gt;</span> t_dept_avg_sal.avg_sal<br>#实际上即为用<span class="hljs-keyword">from</span>内的查询结果视为是一个新的表进行处理<br><br><span class="hljs-keyword">SELECT</span> department_id, department_name <br><span class="hljs-keyword">FROM</span> departments d <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;X&#x27;</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> d.department_id);<br>#<span class="hljs-keyword">EXISTS</span>或者 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>可以看做是一种用于判断布尔值的函数，其返回的结果只有真假而不存在数据<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp2 <br><span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>; 、<br># 相当于通过筛选条件设置为任意一个不可能的条件，使得原表中的所有元素都不符合要求，使得创建一个只有现有表表项而没有现有表表数据的表<br># 创建的emp2是空表<br><br>#去除字段当中的空格可以用如下操作进行<br>#相当于使用空替代了空格<br><span class="hljs-keyword">SELECT</span> REPLACE(NAME,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">FROM</span> BOOKS;<br></code></pre></td></tr></table></figure><p>一般对数据库进行命名时不要使用系统关键词进行命名，如果一定要使用关键词进行命名，在使用的时候要使用单引号括起来将其和关键词相区分</p><p>数据库本身名字是无法进行修改名字的，部分操纵数据库的软件提供了修改名称的方法，实际上是通过创建一个新的库然后进行复制完成的</p><p>数据库删除以后无法进行回滚（撤销）</p><p>如果在使用调用数据表的过程中，对应的数据表不在同一个数据库下，只需要在被调用表前面写全对应的数据库名称  +  <strong>.</strong>  即可  </p><p>desc tablenames（表名） 主要用来查看数据表的表结构</p><p>update本身就存在批量进行修改的能力，和select一样，取决于where中的限定范围进行修改</p><p>修改（删除同理）数据的过程中，是可能存在修改不成功的情况的，这种情况可能是因为约束的影响所造成的</p><p><strong>数据库相关概念分析：</strong></p><ul><li><p>**DDL(data definition language)**数据定义语言</p><p>创建表时用到的一些SQL语句，如：CREATE、ALTER、DROP等  DDL主要是用在定义表 或者 改变表的物理结构、数据类型表之间的链接和物理约束等初始化操作上</p></li><li><p>**DCL(Data Control Language)**数据控制语言</p><p>用来设置或者更改数据库用户角色权限等的语句，如：grant、revoke语句</p></li><li><p><strong>DML(data manipulation language)</strong> 数据操纵语言</p><p>常用的select、update、insert、delete 主要用来对数据库的数据进行的一些操作 即对数据的增删改查</p></li></ul><p>创建数据库、数据表、字段时，均可以指明其对应的字符集，如果没有显式的指明对应的字符集，则取决于上一级所使用的字符集，如果数据库也没有指明对应字符集，则使用配置文件中默认的字符集</p><p>当编码格式是utf8时，每个汉字占三个字节</p><p>枚举类型变量（单选项 )在定义的时候就已经设置了对应能选择的枚举项，在输入的过程中可以使用索引或者使用原文字进行输入，但是不能输入设置好的选项以外的变量</p><p>set数据类型类似多选项，其他特性类似枚举类型</p><p>由于有时候需要删除约束，故需要对约束进行起名保证删除对应的约束</p><p>唯一性约束保证属性的唯一性，特殊的可以有重复个null</p><p>对两个字段组合建立唯一性约束指的是该组合限制唯一性，只要其中有一个不同即可</p><p>只能有一个主键约束，但是可以将多列组合进行主键约束，注意此时只要多列中有一个为null则报错</p><p>可以对一个字段同时进行主键约束和自增长约束（每次递增的编号）</p><p>外部约束的建立和查询无关，外部约束影响的是数据库增删改操作</p><p>由于主键是唯一的，所以没有必要对主键进行命名</p><p>向视图提供数据内容的语句为select语句，可以将视图理解为<strong>存储起来的select语句</strong></p><p>注意concat函数连接的不仅是表头的字段，同时字段对应的数据内容也会被连接</p><p>视图本身不存储数据</p><p>视图和基表两者之间改变会相互影响</p><p>使用in限定的表示的是只用于输入的变量，使用out限定的表示的是只用于输出的变量，使用inout限定的是既输入也输出的变量</p><p>由一个日期对象转化为字符串称之为格式化，将一个字符串转化成一个日期对象称之为解析</p><p>会话变量不需要进行定义数据类型，但是局部变量在声明时需要指明数据类型</p><p>在使用触发器的过程中可以通过使用，old和new来分别代指新添加的数据或者新删除的数据</p><p>只要在from中对表进行起别名后就可以在where或者select中使用别名</p><p>左外连接和右外连接中由左右二字所指向的表称之为主表，主表即相对于从表而言数据项更多的表</p><p>实际上所谓从表和主表的本质并不是比较谁的元素少，而是通过比较查询结果</p><p><strong>满外连接</strong>的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据</p><p>外连接的含义是尽可能的去保护主表中的数据不丢失，即使不满足筛选条件的主表数据也要显示</p><p>从sql优化的角度，建议多表查询时，每个字段前都指明其所在的表</p><p>如果给表起了别名，一旦在SELECT或WHERE中使用表名的话，则必须使用表的别名，而不能再使用表的原名</p><p>注意：MySQL中，字符串的位置是从1开始的</p><p>使用标准格式xxxx-xx-xx传入日期相关函数当成参数，就可以将其看做是一个创建的时间对象</p><p>在时间相关运算中，如果传递的是数字，则数字的单位默认是秒</p><p>起别名的操作在任意语句中都可以进行实现</p><p>通过查询语句获取的数据项存储在一张新的表中称之为派生表</p><p>使用派生表必须指定别名 因为，<code>FROM</code> 子句中的所有表都必须有一个名字</p><p>聚合函数不能嵌套调用</p><p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的</p><p>不能在WHERE子句中使用聚合函数</p><p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>： <br><span class="hljs-keyword">SELECT</span> ...,....,...<br><span class="hljs-keyword">FROM</span> ...,...,.... <br><span class="hljs-keyword">WHERE</span> 多表的连接条件 <br><span class="hljs-keyword">AND</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,... <br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span> <br>LIMIT ...,... <br><br>#方式<span class="hljs-number">2</span>： <br><span class="hljs-keyword">SELECT</span> ...,....,... <br><span class="hljs-keyword">FROM</span> ... <br><span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> 多表的连接条件 <br><span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ... <br><span class="hljs-keyword">WHERE</span> 不包含组函数的过滤条件 <br><span class="hljs-keyword">AND</span><span class="hljs-operator">/</span><span class="hljs-keyword">OR</span> 不包含组函数的过滤条件 <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,... <br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件 <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span> <br>LIMIT ...,... <br><br>#其中： <br>#（<span class="hljs-number">1</span>）<span class="hljs-keyword">from</span>：从哪些表中筛选 <br>#（<span class="hljs-number">2</span>）<span class="hljs-keyword">on</span>：关联多表查询时，去除笛卡尔积 <br>#（<span class="hljs-number">3</span>）<span class="hljs-keyword">where</span>：从表中筛选的条件 <br>#（<span class="hljs-number">4</span>）<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>：分组依据 <br>#（<span class="hljs-number">5</span>）<span class="hljs-keyword">having</span>：在统计结果中再次筛选 <br>#（<span class="hljs-number">6</span>）<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>：排序 <br>#（<span class="hljs-number">7</span>）limit：分页<br><br><br>#查询平均工资最低的部门id，注意使用<span class="hljs-keyword">all</span>修饰符之类<br><span class="hljs-keyword">SELECT</span> department_id <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">ALL</span> <br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal <br>          <span class="hljs-keyword">FROM</span> employees <br>          <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id );<br> <br>#注意使用<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> 修饰符<br><span class="hljs-keyword">SELECT</span> last_name <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> <br>( <span class="hljs-keyword">SELECT</span> manager_id <span class="hljs-keyword">FROM</span> employees );<br><br>#查询departments表中，不存在于employees表中的部门的department_id和department_name<br><span class="hljs-keyword">SELECT</span> department_id, department_name <br><span class="hljs-keyword">FROM</span> departments d <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;X&#x27;</span> <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> d.department_id);<br><br>#使用查询语句的结果作为创建表的数据<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept80 <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> employee_id, last_name, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span> ANNSAL, hire_date <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">80</span>; <br><br>#表示创建一个约束，该约束限制用户名和密码组合不能重复<br><span class="hljs-keyword">CONSTRAINT</span> uk_name_pwd <span class="hljs-keyword">UNIQUE</span>(NAME,PASSWORD)<br><br>#复合唯一，表示的是这种组合唯一<br><span class="hljs-keyword">unique</span> key(sid,cid)<br><br>#复合主键<br><span class="hljs-keyword">primary</span> key(sid,cid) <br><br>#主表 <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept( <br>did <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, #部门编号 <br>dname <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) #部门名称 <br>);<br>#从表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp( <br>eid <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, #员工编号 <br>ename <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>), #员工姓名 <br>deptid <span class="hljs-type">int</span>, #员工所在的部门<br><span class="hljs-keyword">foreign</span> key (deptid) <span class="hljs-keyword">references</span> dept(did) #在从表中指定外键约束 <br>#emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号 <br>);<br>说明： <br>（<span class="hljs-number">1</span>）主表dept必须先创建成功，然后才能创建emp表，指定外键成功<br>（<span class="hljs-number">2</span>）删除表时，先删除从表emp，再删除主表dept<br><br>#外键的设置实际上是为了限制主表和从表中属性之间的映射关系<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept <span class="hljs-keyword">values</span>(<span class="hljs-number">1001</span>,<span class="hljs-string">&#x27;教学部&#x27;</span>); <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept <span class="hljs-keyword">values</span>(<span class="hljs-number">1003</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>); <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">1001</span>); #添加从表记录成功，在添加这条记录时，要求部门表有<span class="hljs-number">1001</span>部门<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">1005</span>); #添加从表记录失败<br></code></pre></td></tr></table></figure><p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的</p><p>注意count有时会不包含null，但是在计算的过程中是需要计算这些null值的，由于AVG &#x3D; SUM &#x2F; COUNT，所以有时要自己编写分子和分母的表达式</p><p>单行操作符对应单行子查询，多行操作符对应多行子查询，所提供的数据数等于需要的数据数</p><p>我们按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询</p><p>成对查询指的是返回的子查询是两条数据</p><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 <strong>关联子查询</strong></p><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用</p><p>注意子查询能够适用的语句关键词很多，要根据想使用的范围进行应用，总结来说，在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询</p><p><strong>自连接和子查询的比较：</strong>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多  可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化</p><p>key是为表添加索引，索引的作用是增加数据库的查询速度。MySQL的数据库引擎是InnoDB，它采用B+树和哈希两种数据结构的方式为表添加索引，同时还可以在key之前添加限定词，来扩充索引的作用</p><p><strong>自增计数器的持久化：</strong>MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p><p><strong>键列：</strong>被设置为key的列</p><p><strong>主表和从表关系：</strong></p><ul><li>约束关系是针对双方的</li><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><p>补充：</p><p>创建多个mysql客户端实例实际上就是使用多个控制台打开数据库终端即可</p><p>根据不同的需求，可以根据主键创建聚簇索引，也可以根据需要使用别的列的值创建聚簇索引</p><p>关键词KEY 即用于创建索引使用的</p><p>多表外连接的条件，实际上连接条件左边的数据相当于是变量，在对被驱动表操作的过程中就已经赋值了左边的数据，进行优化单表查询</p><p>内连接和外连接都存在驱动表的定义，并且额外的，对于内连接的两个表，其驱动表和被驱动表是可以互换的</p><p>子查询就是在查询结果中又进行一次查询，相当于进行递归查询，更好的理解是把子查询得到的结果看做是一个返回值，这个返回值可以存在于查询语句中的任意位置</p><p>非聚簇索引实际上就是二级索引，一个表有且只有一个聚簇索引</p><p>多次查找二级索引会导致查询效率不高，这种情况在InnoDB中有一定的优化，不是认为控制的，而是引擎实现的，通过二级索引查询多了，InnoDB会生成自适应的哈希索引</p><p><img src="/typoraPictureFiles/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p><p><strong>普通索引和唯一索引的区别：</strong></p><ul><li>没啥区别，唯一索引实际上就是使用唯一值作为索引，并且mysql能够对其进行一定优化</li><li>使用唯一索引相较于普通索引的优势：<ul><li>简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率</li><li>MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是MySQL将拒绝插入那条新记录</li><li>唯一索引可以保证数据记录的唯一性  事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复</li></ul></li></ul><p><strong>函数和存储过程的区别</strong></p><ul><li>两者都拥有的优点<ul><li>易用性：共同使用的代码可以只需要被编写一次，而被需要该代码的任何应用程序调用（.net,c++,java，也可以使DLL库）</li><li>一致性：可以在各个开发者之间提供处理数据、控制流程、提示信息等方面的一致性</li><li>高效性：节省内存空间。它们以一种压缩的形式被存储在外存中，当被调用时才被放入内存进行处理。而且多个用户在调用同一个存储过程或函数时，只需要加载一次即可</li><li>安全性：高数据的安全性和完整性。通过把一些对数据的操作方到存储过程或函数中，就可以通过是否授予用户有执行该语句的权限，来限制某些用户对数据库进行这些操作</li></ul></li><li>两者之间的区别<ul><li>存储过程用户在数据库中完成特定操作或者任务（如插入，删除等），函数用于返回特定的数据</li><li>存储过程声明用procedure，函数用function</li><li>存储过程不需要返回类型，函数必须要返回类型</li><li>存储过程可作为独立的pl-sql执行，函数不能作为独立的plsql执行，必须作为表达式的一部分</li><li>存储过程只能通过out和in&#x2F;out来返回值，函数除了可以使用out，in&#x2F;out以外，还可以使用return返回值</li><li>sql语句（DML或SELECT)中不可用调用存储过程，而函数可以</li></ul></li><li>两者适应场景的区别：<ul><li>如果需要返回多个值和不返回值，就使用存储过程；如果只需要返回一个值，就使用函数</li><li>存储过程一般用于执行一个指定的动作，函数一般用于计算和返回一个值</li><li>可以再SQL内部调用函数来完成复杂的计算问题，但不能调用存储过程</li></ul></li><li>区别和联系<ul><li>相同点：<ul><li>创建语法结构相似，都可以携带多个传入参数和传出参数</li><li>都是一次编译，多次执行</li></ul></li><li>不同点：<ul><li>存储过程定义关键字用procedure，函数定义用function</li><li>存储过程中不能用return返回值，但函数中可以，而且函数中必须有return子句</li><li>执行方式略有不同，存储过程的执行方式有两种（1.使用execute2.使用begin和end），函数除了存储过程的两种方式外，还可以当做表达式使用，例如放在select中（select f1() form dual;）</li></ul></li></ul></li></ul><p><strong>WITH CHECK OPTION</strong>的作用：</p><ul><li>保证在使用任意语句后修改后的结果依旧符合视图的筛选要求<ul><li>像第一种情况，WHERE的条件是className的首字符是含有“注册会计”的。那么，视图进行UPDATE修改时，不能把这个条件给改没了</li></ul></li><li>即它会阻止可见行更新为不可见的行</li></ul><p>不能在视图上创建触发器</p><ul><li><strong>关于主从复制相关</strong></li></ul><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。（因为statement模式下是基于语句进行的，而并不是基于行，部分函数调用可能出现问题）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/typoraPictureFiles/image-20221106204811956.png" alt="image-20221106204811956"></p><p><img src="/typoraPictureFiles/image-20221107111530405.png" alt="image-20221107111530405"></p><p><img src="/typoraPictureFiles/image-20221107111655077.png" alt="image-20221107111655077"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/JVM/"/>
    <url>/2023/03/06/JVM/</url>
    
    <content type="html"><![CDATA[<p>java部分内容无法实现，需要通过调用操作系统层面的<strong>本地方法</strong>进行完成功能</p><p><img src="/typoraPictureFiles/image-20220922135030796-16638258383681-16638258399743-16638258420835-16638258429957-16638258441939.png" alt="image-20220922135030796"></p><ul><li>通过修改VM options 来修改虚拟机参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="hljs-comment"> * 这里注意，如果使用的是jdk1.8之前的版本，那时的jdk使用永久代的内存，那么消耗的就是堆中的内存，而不是元空间中的内存</span><br><span class="hljs-comment"> * -XX:MaxMetaspaceSize=8m    这个设置实际上是在idea中进行配置  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123; <span class="hljs-comment">// 可以用来加载类的二进制字节码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Demo1_8</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1_8</span>();<br>            <span class="hljs-comment">//通过疯狂使用类加载器来占用元空间内存</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;<br>                <span class="hljs-comment">// ClassWriter 作用是生成类的二进制字节码</span><br>                <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 版本号， public， 类名, 包名, 父类， 接口</span><br>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-comment">// 返回 byte[]</span><br>                <span class="hljs-type">byte</span>[] code = cw.toByteArray();<br>                <span class="hljs-comment">// 执行了类的加载</span><br>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">// Class 对象</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span><br><span class="hljs-comment">// 取值不同的字符串在StringTable中是唯一的，并且在使用字符串时会优先从其中进行查找使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span><br>    <span class="hljs-comment">// 具体的运行结果如下图所示</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的:即当还没有使用到这个字符串时，不会将其转化成java字符串对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//注意虽然s4 和 s5 看起来是相同的构造方式，但是实际上s4是通过变量进行构建，而s5是通过常量进行构建</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2; <span class="hljs-comment">// 实际上进行的操作为    new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// javac 在编译期间的优化，结果已经在编译期确定为ab，所以运行结果是直接到字符串常量池中去寻找&quot;ab&quot;由于创建s3的时候就已经存放了&quot;ab&quot;，所以会直接使用常量池中的字符串</span><br>        System.out.println(s3 == s4);<span class="hljs-comment">//false  s3是定义好的所以存放在字符串常量池中，s4是通过new创建的存放在对空间中</span><br>        System.out.println(s3 == s5);<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/typoraPictureFiles/image-20220922151958831-16638312002221.png" alt="image-20220922151958831"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.8</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span><br><br>        System.out.println( s2 == x);<span class="hljs-comment">//true</span><br>        System.out.println( s == x );<span class="hljs-comment">//false</span><br>    &#125;<br><br><br><br><span class="hljs-comment">//1.6(1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池,会把串池中的对象返回)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        System.out.println( s2 == x);<span class="hljs-comment">//true</span><br>        System.out.println( s == x );<span class="hljs-comment">//false</span><br>     <span class="hljs-comment">//这里的s是堆中的内存 ，x是常量池中的内存</span><br>    &#125;<br><br><br><br><span class="hljs-comment">//1.8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</span><br>    <span class="hljs-comment">//这里将s放进了常量池中，所以后来x就直接引用了常量池中的&quot;ab&quot;，所以s变成了一个常量池中的字符串，注意如果在intern方法时，常量池中已经存在&quot;ab&quot;,则会导致入池失败，进而使得 s 依旧是堆中的对象而不是常量池中的对象</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        System.out.println( s2 == x);<span class="hljs-comment">//true</span><br>        System.out.println( s == x );<span class="hljs-comment">//true</span><br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/typoraPictureFiles/image-20220922190239428.png" alt="image-20220922190239428"></p><ul><li>官方文档中关于方法区的定义</li></ul><p>CGlib：CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择</p><p>字节码是运行在JVM上的程序，通过JVM来实现多平台的平台无关性</p><p><strong>JDK和JRE的区别：</strong></p><ul><li>JDK全称是Java开发工具包（Java Development Kit），它包含了Java从开发到运行的各种工具</li><li>JRE指的则是Java运行环境（Java Runtime Environment），它包含了基础类库和JVM虚拟机</li><li>JRE是JDK的子集</li></ul><p><strong>JAVA常用指令：</strong></p><ul><li>javac：用于编译java源代码，生成class文件（这个javac编译器就是JRE相比于JDK少了开发功能的决定性元素）；</li><li>javap：用于反编译，根据class文件，反解析出其中的汇编指令和其他信息；</li><li>javadoc：用于生成java文档的命令</li></ul><p><strong>JVM可达性分析：</strong></p><ul><li>可达性分析算法：有一系列  GCRoots  起点，从这些点开始向下搜索，走过的路径称为“引用链”。若一个对象没有任何引用链可到达GC Roots，那么该对象就是不可用的，即使该对象还与其他对象相关联<br>经可达性分析算法所标记出的对象，会进行一次筛选（根据finalize方法）。若经过筛选，判定可回收，那么就会立即回收；若判定没有必要回收，那么就将对象放入F-Queue队列中，进行二次筛查。二次筛查会执行对象的finalize()方法。若对象在这个过程重新与引用链上的任何一个对象建立关联，那么该对象就会从回收集合中移除。否则，对象会被回收</li><li>常见作为GCRoots的对象<ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul></li></ul><p>有一系列“GCRoots”起点，从这些点开始向下搜索，走过的路径称为“引用链”。若一个对象没有任何引用链可到达GC Roots，那么该对象就是不可用的，即使该对象还与其他对象相关联。<br>经可达性分析算法所标记出的对象，会进行一次筛选（根据finalize方法）。若经过筛选，判定可回收，那么就会立即回收；若判定没有必要回收，那么就将对象放入F-Queue队列中，进行二次筛查。二次筛查会执行对象的finalize()方法。若对象在这个过程重新与引用链上的任何一个对象建立关联，那么该对象就会从回收集合中移除。否则，对象会被回收。</p><p>由于操作数栈和局部变量表值存放数据的值，而不存放数据的数据类型，所以操作指令必须知道自己在操作什么样的数据</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/6.824%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/03/06/6.824%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>当你能够不使用分布式应用时，就应该避免使用分布式应用</p><p>实现分布式接口需要尽量将分布式实现的细节不进行暴露，而是创建合理的接口</p><p>分布式系统由于使用了大量计算机集群，单机的故障率在基数的增大前提下，整体故障率也在提高</p><p><strong>分布式所面临的挑战：</strong></p><ul><li>时序性(Timing)，如何确保运行在不同网络下的机器中的进程如何判断一些事件发生的顺序</li><li>并发性(Concurrency) 如何确保不同网络下的机器进程之间共享资源而互不干扰，如访问共同的数据库</li><li>健壮性(Robustness) 如何应对网络的不稳定性和硬件的不稳定性</li><li>一致性(Consistency) 如何保证访问哪个服务结点都是获得相同的数据</li></ul><p><strong>高容错</strong>  :</p><ul><li>可用性(Availability)</li><li>可恢复性(Recoverabilty)  1.non-volatile storage 2.replication</li></ul><p>强一致性的分布式系统需要通信等各方面代价很高的操作，有时会使用弱一致性的系统来应用，使用弱一致性的系统可能读到的数据并不是最新的数据</p><p>要尽可能保证不同的服务器之间发生故障的概率是不相关的（eg:避免两个副本服务器放在同一个机架上）</p><p>线程切换需要保存一些状态，也就是所谓上下文，所以实际上实现线程切换是消耗资源的操作</p><p><strong>多线程的好处：</strong></p><ul><li>实现IO并发操作（IO concurrency）</li><li>CPU并行化（CPU parallelism）</li><li>保证在主线程执行的过程中，在后台调用一些检查的后台进程</li></ul><p><strong>多线程和多进程：</strong></p><ul><li>多进程是指不同的运行程序，不同的操作系统使用不同的实现，但是都会为不同的进程分配一块独立的内存空间，进程之间无法相互访问</li><li>多线程是指程序内部有多个执行过程，即在进程内部又可以有多个线程，不同线程可以使用chanel等方式进行分享数据</li></ul><p>在使用go语言的过程中，go并不知道什么数据被上锁，锁和变量并没有一一对应，而是只对锁的获取和释放进行管理</p><p>对于加锁的另外一种理解可以将其认为希望在加锁过程中的代码执行是原子性的</p><p>对于一个爬虫程序，它会不断的递归爬取一个网站中的URL，然后再从这个URL中爬取其他URL，在这个过程中形成了一个树状的结构，但是同样也有可能在递归过程中产生环状结构，为了避免产生环状问题，我们需要对其遍历过的URL维护一个变量map进行记录</p><p>有时为了限制使用过多的线程，可以使用线程池技术将线程的数量控制在一个范围中</p><p>channel本身使用了内置的互斥锁来保证临界资源的访问互斥性 </p><p>raft并不保证命令一定会被执行，如果某条指令没有被超过半数的结点所接受则不会commit这条指令</p><p>只要leader所发送的信息被半数以上的结点<strong>接受</strong>到，leader就会执行这条指令并且返回结果给客户端</p><p>如果一个foller接收到了比当前记录大的任期号，就会将当前follower的</p><p><strong>大型分布式存储：</strong></p><ul><li>为了保证对数据存储的性能，需要对数据进行分片操作</li><li>由于对数据进行了分片操作，导致错误发生会显著提高，需要保证良好的容错性</li><li>使用数据副本进行复制数据来保证容错性</li><li>使用复制本身很自然的会导致数据的不一致性</li><li>为了保证数据的一致性自然会导致影响一定的性能</li></ul><p><img src="/typoraPictureFiles/image-20221003111145740.png" alt="image-20221003111145740"></p><p>nv(非易失的)  v(易失的)</p><p><strong>容错系统中所使用的容错模式：</strong></p><ul><li>MapReduce所使用的复制方案，但其复制操作完全由单个master所控制</li><li>GFS通过主备方案（primary backup）复制实际的文件内容，但其依赖于单一的master节点为每一片数据选择primary</li><li>VMware ft 复制方案，其在一台primary虚拟机和backup虚拟机上执行写入操作，当运行过程出现差错时，需要借助一台test-and-set服务器来帮助其选择一台backup 来接管 primary</li><li>以上三种方式的共同点在于都需要一个单一的实体来决定primary的产生，其好处在于一定能做出决策，但同样也受限于单一实体，可能出现单点错误情况</li></ul><p><strong>数据不一致的产生情况：</strong></p><ul><li>分布式系统中的一致性需要依赖于客户端能够对所有的服务器进行访问，如果客户端只能对其中的部分服务器访问，就会出现数据不一致的现象，称之为脑裂（split brain）,每一个客户端都觉得自己沟通的就是master，导致产生了两个master结点，称之为脑裂</li><li>解决脑裂的方式：<ul><li>构建完全稳定的网络，确保客户端能够访问到所有的服务器（实际上由于网络分区的存在，所以不可能能够构建完全稳定的网络）</li><li>人为设置，确保客户端只能在访问到所有的服务器的情况下才能够进行数据使用</li><li>基于“少数服从多数的”raft协议来保证数据一致，由于存在奇数台服务器，所以无论对服务器如何进行分隔，总是最多只有其中的一组拥有所有服务器的半数以上，即只能选举出一个master</li></ul></li></ul><p><strong>raft协议解析：</strong></p><ul><li>存在奇数台服务器，每次执行必须要保证半数以上的服务器确认（3台服务器中两台确认），注意这里的服务器指的是所有的服务器，而不是只有存活的服务器</li><li>如果拥有 2f+1 台服务器，那么就能够承受 f 台服务器发生服务故障（3台服务器中，即使1台发生故障，也能保证至少有半数以上的服务器确认）</li><li>raft 以 lib库的形式被连接到某些服务器程序中，并且会有基于RPC的程序供给调用</li><li>当leader在发送请求过程中如果出现了错误，则会导致部分服务器获取到了更新日志，而另外一部分服务器没有获取到更新日志，但是基于raft协议会在运行一段时间内达到最终一致性，并且只有在达到最终一致性后才会执行对应的语句</li><li>raft中要解决的常见问题<ul><li>如何进行leader选举：</li><li>当日志存在不一致的处理方式：</li></ul></li></ul><p><strong>Raft选举过程详解：</strong></p><ul><li>结点维护一个选举计时器，当选举计时器定期结束后就开始进行选举，首先将当前term++（确保当前节点能够成为leader），将当前节点转化成候选人结点，并且向其他结点发送参与选举信息，默认参与选举的结点会为自身投一票<ul><li>由于在选举过程中，有可能并不是因为原本的leader结点宕机了，而是无法通信，这时由于双方无法得知对方的存在会导致重复的leader结点出现</li><li>如果网络中存在单向数据传输问题，那么可能会导致leader结点无法接收到客户端发来的请求，但是leader会持续向外界发送心跳包从而抑制其他结点的leader选举来保证功能的可用性</li><li>在raft中我们需要确认一个term中最多只能存在一个leader，通过选举leader必须在一半以上，并且在同一个term中只能给一个候选人投票来保证这一点</li><li>基于majority原则，保证只要系统中没有一半的结点都宕机了的话，就能够保证一定能够选举出来一个leader</li><li>实际上当一个服务器成为一个leader后，其并不会向其他结点发送“我成为了一个leader结点，任期为22！”这样的信息，因为在raft协议中，实际上只有leader结点能够发送AppendEntries信息，所以只要一个结点接受到了AppendEntries信息就说明已经产生了新的leader，这个AppendEntries信息就像heartbeat包一样，会重置当前节点的选举计数器</li><li>由于在选举过程中严重依赖大部分选票的获取，所以为了避免多个结点同时发出选举（三个结点同时都开始选票，三个结点都面对其他结点的选票要求无动于衷，最后导致循环往复）导致选票被瓜分的情况出现，raft会进行限制，随机化每个结点的选举计数器来避免多个结点同时成为候选人，即避免同时多个结点的选举计数器到时</li><li>至少要限定选举计数器的时间要大于两次心跳包之间的时间，来避免由于心跳传输所导致的额外选举</li><li>选举计数器的时间实际上是有一个区间的，在最小值和最大值之间随机选取一个值作为选举计数器时间，注意选举计数器时间的最大值标志着这个系统中的对于故障的反应速度，选举计数器的最大值越大，则一个系统从故障到重新进行选举的恢复时间越长（在这段时间中，即使你知道其他的服务器是正常工作的也得等待）</li><li>并且对于不同结点的选举计数器也需要有足够差值来保证当其中等待时间较小的结点当成为候选人发送投票请求时，时间较长的结点能够收到这个投票请求而不是也成为一个候选人</li><li>注意使用的选举时间不要重复复用，而是每次选举时间都需要重新获取一个随机值，避免错误情况：如瓜分选票，的情况重复出现</li><li>相对于新选举得到的leader结点而言，原来的由于网络故障等原因得不到majority的旧leader结点会被废弃，同时也由于得不到majority的原因，也不会对客户端的请求进行提交</li><li>log分叉是指，在log传递过程中可能由于网络问题等原因，一部分server收到了log，而另外一部分server并没有收到log，导致不一致的情况产生</li><li>只要半数以上的服务器中拥有的log，那么这个命令就是合理的，是能够被提交的</li><li>可能会对log中的末尾数据进行丢弃，保证所有的server的log的末尾指令是来自同一个term</li><li>发送每一个log信息时，其中会附带前一个日志的log slot ，并且也会附带前一个日志的term号，避免日志出现错误</li><li>leader会为每一个follower记录一个nextIndex，来记录最后发送的log slot号，当leader服务器重启后，会以当前leader服务器中最后一条log对应的数字作为其他所有follower的nextIndex，如果发送信息后对应的nextindex不正确，则leader服务器会自动减小对应的nextindex号码，并且follower结点会根据leader结点传送的数据来丢弃部分先前不匹配的数据</li><li>leader通过一种类似复制的算法，找到每一个follower结点对应的和leader相同的log的位置，并从这个位置开始向后进行复制同步</li><li>被抛弃的没执行的log操作可行的前提是由于，这个被抛弃的log一定没有被majority所确定，所以一定还尚未被执行，即可以安全删除</li><li>所以如何确定当前服务器的结点哪个为leader，很自然的想到应该将拥有最多log的作为leader，但是实际上这样是不对的</li><li>如果选取了最长log的结点作为leader，那么当这个节点成为leader时，其会导致其他结点中与该节点不同的log被抛弃，但其中可能有部分log已经被majority所拥有并执行，所以如果选用最长log的结点作为服务器，可能会导致其强行更新其他服务器的log产生错误</li></ul></li></ul><p><strong>当raft协议中出现分区的处理和解决方案</strong></p><ul><li>由于产生了分区，所以一个网络中最多只会有一个分区中能够拥有超过半数的服务器，并且其他分区由于没有超过半数的服务器，在这些分区中的伪leader虽然一直在工作，但是由于没有超过半数的foller能获取到数据，所以该leader无法对client所发出的数据进行回应</li><li>当分区问题解决，之前那个拥有超过半数结点分区的leader由于term号更大，自然就使得其他伪leader在接收到该leader的消息后转变为foller</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Go_Error/"/>
    <url>/2023/03/06/Go_Error/</url>
    
    <content type="html"><![CDATA[<p><strong>安装go语言源代码的时候报错归档文件中异常的 EOF</strong> </p><ul><li>错误原因：源代码本身完整性不正确</li><li>解决方式：重新下载对应的安装包进行压缩即可</li></ul><p><strong>Do not untar the archive into an existing &#x2F;usr&#x2F;local&#x2F;go tree. This is known to produce broken Go installations</strong></p><ul><li>错误原因：同上所述，先创建了一个&#x2F;usr&#x2F;local&#x2F;go文件夹，导致源代码解压的时候出错，各种报错</li><li>解决方法：重新安装，不要乱搞</li></ul><p>VScode安装go语言相关插件不成功</p><ul><li>错误原因：没有在Linux Path变量中添加GOPATH</li><li>解决方法：在PATH变量中注意设置GOROOT和GOPATH两个的bin</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Redis/"/>
    <url>/2023/03/06/Redis/</url>
    
    <content type="html"><![CDATA[<p><strong>TTL返回值：</strong></p><ul><li>-1表示该数据永久有效</li><li>-2表示该数据已经超过有效时限了</li></ul><p>可以使用层级结构来表示对象的键值，同时可以将java对象进行序列化转变成json格式</p><p>Redis可以用于缓存用户登录信息，因为当存在多个服务器时，存放在session数据中的用户信息无法在多个服务器之间共享，这时可以使用Redis来存储用户信息，因为redis恰好满足共享session所需要的条件，这里是指使用Redis来代替共享session的方案</p><p>对于Redission，spring官方提供了一个对应的starter，但是不建议使用这个starter来启动，因为这样会覆盖掉原本对于Redis的配置，建议自己编写一个配置类RedisConfig来进行配置</p><p>Redis中配置相关的处理都可以在conf中进行设置，设置文件种类，大小方式等</p><p>string有多种类型无论是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p><p>自定义序列化的过程中，存储类本身的信息占用了大量空间，为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式  省去了我们自定义RedisTemplate的过程</p><p>如果不对redisTemplate进行重写，则Redis会自动使用一个默认的redisTemplate，这个redisTemplate使用的序列化器有时会使用产生不便，所以建议在使用的过程中对redisTemplate进行重写，修改其对应的序列化器，但是实际上也不需要进行重写，一般的操作使用StringRedisTemplate即可</p><p>利用set ex设置过期时间的目的是，保证当故障时锁依然能释放，避免死锁，提高安全性</p><p><strong>缓存击穿的两种解决方式：</strong></p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><strong>简单实现互斥锁的方法：</strong></p><ul><li>使用setnx lock 1 ,利用一个变量结合setnx的特性来实现，多个人获取lock但是只有一个人返回1的情况，而且使用delete lock来设置释放锁的操作</li><li>由于为了避免在设置锁和设置锁的过期时间之间产生冲突可以将两者用同一行代码进行表示<ul><li>SET   lock   thread1   EX   10   NX</li></ul></li></ul><p><strong>超买问题的出现：</strong></p><ul><li>超买问题的出现在于检查是否存在库存到真正修改库存之间存在非原子性，导致其他线程在检查完是否存在库存和真正修改数据库之前产生了大量并发数据</li><li>可以使用版本号的方法来判断是否出现超买问题，并且如果使用数据量本身的校验来代替版本号则称之为CAS方法</li><li>CAS方法存在误判的存在，实际上售卖只要库存量大于0即可，但是实际上却用了是否改变来判断能不能买，这样会导致有些时候明明仍有库存但是却不能进行购买的现象出现</li><li>为了解决这种方法，可以使用 stock &gt; 0，来判断，不管有没有修改，只要够卖就卖</li><li>由于乐观锁会出现成功率较低的问题，并且如果有些数据只能通过是否修改来进行判断，此时可以使用分段锁的方式，将库存进行分段，提高成功率</li></ul><p><strong>限购问题的解决：</strong></p><ul><li>在购买之前查询订单数据库中是否存在对应的订单，如果存在则不允许购买</li><li>限购问题出现的原因实际上是和超买问题相同，但是由于限购问题的判断是根据查询到的结果而不是对现成的数据是否修改进行判断，所以不能使用乐观锁</li><li>使用悲观锁要注意使用的锁的对象，尽量选择限定范围小的锁来提高并发的效率，并且注意spring的事物注解对象需要获取到对应的代理类再进行设置，否则会出现spring事物注解失效的现象</li><li>当存在多个服务器时，每个服务器有对应的jvm，而jvm中使用不同的锁监视器，所以锁只能满足单体式架构而不能应用于分布式架构</li><li>为了避免由于锁监视器多个的情况导致的限购失败，我们可以使用基于Redis的锁机制，因为所有的服务器都是向同一个数据库中发送请求，所以可以实现限购问题</li><li>最基础的Redis锁机制实际上不完全，由于任何线程都能获取锁和释放锁，所以可能导致A线程最先来的获取了锁，但是由于A线程因为某种原因持续的占用锁，<strong>甚至使得占用锁的时间超过了锁本身的TTL</strong>，在这种情况下锁自动释放了，但是A仍在进行，并且这时又有新的进程抢占了空闲的锁，使得锁又被占用，在锁被占用的这段时间内，线程A结束，“无意”的释放了锁，导致了线程不安全的情况发生</li><li>为了解决这种问题，我们需要使得线程在释放锁的时候多一步判断是否为自己占用的锁，从而避免失误释放锁的情况发生</li><li>但是经典问题又来了，由于判断锁是否是自己的和释放锁这两个动作之间有间隙，这个间隙很小，但是由于多线程的原因可能会有较大的空闲，所以还是会有误删锁导致并发的可能性</li></ul><p><strong>可重入锁的相关问题：</strong></p><ul><li>重入锁即在上锁的时候判断一下，这个锁是不是当前线程所占用了锁，如果是当前线程占用了对应的锁，则对其count++，并且以后释放对应的锁的过程使得count–，当count–到0才将其进行释放</li><li>当操作逻辑复杂的时候，注意使用lua脚本来保证代码运行逻辑过程中的原子性</li><li>当调用的脚本数量行数并不复杂时，可以使用evalWriteAsync( )进行设置对应的脚本文件代码</li></ul><p><strong>使用阻塞队列来完成异步秒杀功能：</strong></p><ul><li>思想：利用阻塞队列作为缓冲区，将秒杀购买过程进行分离<ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li></ul></li><li>潜在问题：<ul><li>内存限制问题（由于阻塞队列是基于内存存储，在大量的请求下可能内存不足）</li><li>数据安全问题（由于数据没有进行持久化，数据存在不安全的情况）</li></ul></li></ul><p><strong>使用消息队列代替阻塞队列的优点在于：</strong></p><ul><li><p>首先明确使用阻塞队列存在如下问题：</p><ul><li>队列的实现是基于jdk所实现的，而这种阻塞队列的实现需要依靠内存进行存储，在高并发的环境下，大量的请求可能会导致请求过多导致内存溢出</li><li>队列没有进行持久化处理，一旦服务发生问题可能会导致数据丢失的情况发生，导致数据不安全的情况发生</li></ul></li><li><p>使用消息队列正好能够完美解决以上两个问题：</p><ul><li>消息队列是一个额外的应用，所以不需要担心内存丢失或者内存泄漏的问题</li><li>消息队列可以对数据进行持久化，并且可以保证数据的安全性</li></ul></li><li><p>Redis中内嵌了多种消息队列来解决该类问题</p><ul><li><p>list结构：基于list结构模拟消息队列，最基本的BL</p><ul><li>优点：利用Redis存储，不受限于JVM内存上限基于Redis的持久化机制，数据安全性有保证可以满足消息有序性</li><li>缺点：无法避免消息丢失只支持单消费者</li></ul></li><li><p>PubSub：基本的点对点消息模型，和rabbitMQ中的发布订阅模型类似</p><ul><li>优点：采用发布订阅模型，支持多生产、多消费</li><li>缺点：不支持数据持久化无法避免消息丢失消息堆积有上限，超出时数据丢失</li></ul></li><li><p>Stream：比较完善的消息队列模型</p><p>   STREAM类型消息队列的XREAD命令特点</p><ul><li><p>优点：消息可回溯，一个消息可以被多个消费者读取，可以阻塞读取</p></li><li><p>缺点：有消息漏读的风险</p><p> STREAM类型消息队列的XREADGROUP命令特点</p></li><li><p>消息可回溯可以多消费者争抢消息，加快消费速度可以阻塞读取没有消息漏读的风险有消息确认机制，保证消息至少被消费一次</p></li></ul></li></ul></li></ul><p><strong>Redis主从配置：</strong></p><ul><li>配置主从的关键命令：slaveof 192.168.150.101  7001（在子Redis中调用这个命令就让该命令中的ip对应的Redis成为主节点）</li><li>由于从结点在成为从结点之前，默认是一个父节点，所以会有唯一的replid表示，在建立主从关系时传递replid进行连接</li><li>repl_baklog是一个环形的数组，用于更新主从结点之间的数据，当主从结点之间的数据差距过大时，导致repl_baklog无法存放完全，即从结点无法对主节点进行增量更新，就不得不使用全量更新</li><li>哨兵机制只需要监控主节点即可，因为主节点中包含了子节点对应的信息，所以不需要额外配置<ul><li>所以在Redis客户端的yml文件中配置的地址也是哨兵对应的地址信息</li></ul></li><li>Redis中的哨兵机制是自带的，只需要在Redis对应的目录下，像redis-cli一样调用执行redis-sentinel即可</li></ul><p><strong>Redis常用命令：</strong></p><ul><li>基于配置文件进行启动：redis-server   redis.conf</li><li>查看Redis是否启动成功：ps -ef | grep redis  </li><li>进入Redis操作命令行客户地：redis-cli</li><li>进入客户端后输入密码：auth abc1234</li><li>退出对应的客户端：exit</li></ul><p>–appendonly yes 表示使用AOF的方式进行持久化操作</p><p><strong>配置docker容器redis的方式</strong></p><p>docker run -p 6379:6379 –name redis -d </p><p>-v &#x2F;mydata&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf  </p><p>-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data</p><p>-d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p>docker run -p 6379:6379 –name redis -d -v &#x2F;mydata&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf  -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p><strong>Redis采用先执行命令再记录日志的方式的原因在于：</strong></p><ul><li>AOF 为了避免额外的检查开销，并不会检查命令的正确性，如果先记录日志再执行命令，就有可能记录错误的命令，再通过 AOF 日志恢复数据的时候，就有可能出错，而且在执行完命令后记录日志也不会阻塞当前的写操作</li><li>AOF 机制提供了三种选择（appendfsync 的三个可选值）</li></ul><table><thead><tr><th>Always</th><th>同步写回：每个命令执行完立马写入磁盘</th></tr></thead><tbody><tr><td><strong>Everysec</strong></td><td><strong>每秒写回：每个命令执行完，先把日志写入 AOF 文件的缓冲区，每隔一秒把缓冲区的内容写入磁盘</strong></td></tr><tr><td><strong>No</strong></td><td><strong>操作系统的写回：每个命令执行完，先把日志写入 AOF 文件的缓冲区，由操作系统决定何时把缓冲区的内容写入磁盘</strong></td></tr></tbody></table><ul><li>由于随着记录的时间增加，AOF文件中需要记录的数据也日益增多，即需要对AOF文件进行重写来避免文件过大，AOF 重写的过程是通过主线程 fork 后台的 bgrewriteaof 子进程来实现的，可以避免阻塞主进程导致性能下降</li><li>由于随着AOF文件的增加，重新读取文件内容的耗时逐渐增加，需要通过内存快照（RDB）来保证</li><li>Redis 提供了两个命令来生成 RDB 文件，分别是<strong>save</strong>和<strong>bgsave</strong>：<ul><li>save：在主线程中执行，会导致阻塞</li><li>bgsave：会创建一个子进程，该进程专门用于写入 RDB 文件，可以避免主线程的阻塞，也是默认的方式</li></ul></li><li>执行快照期间数据能不能修改呢?如果不能修改，快照过程中如果有新的写操作，数据就会不一致，这肯定是不符合预期的。Redis 借用了操作系统的<strong>写时复制</strong>，在执行快照的期间，正常处理写操作</li></ul><p><strong>Redis集群模式通知hash slot 的方法：</strong></p><ul><li>在最开始客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端，实例之间会把自己的哈希槽信息发给和它相连的实例，完成哈希槽的扩散。这样客户端访问任何一个实例的时候，都能获取所有的哈希槽信息</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/JVM_gitbook_%E7%B2%BE%E5%8D%8E%E7%89%88/"/>
    <url>/2023/03/06/JVM_gitbook_%E7%B2%BE%E5%8D%8E%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p><strong>对于 slot 的理解：</strong></p><ul><li>JVM 虚拟机会为局部变量表中的每个 slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this，会存放在 index 为 0 的 slot 处，其余的参数表顺序继续排列。</li><li>栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li></ul><p><strong>GC Roots 是指：</strong></p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中常量引用的对象</li><li>方法区中类静态属性引用的对象</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Spring_Error/"/>
    <url>/2023/03/06/Spring_Error/</url>
    
    <content type="html"><![CDATA[<p><strong>通过Spring Initializr构建SpringBoot项目没有自动设置成spring项目：</strong></p><ul><li>将对应的java、resources文件夹右键点击mark as …</li><li>将对应的pom.xml文件右键点击Add as maven project …</li></ul><p><strong>使用maven导包一直导入不进来：</strong></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加对应配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在导入行显示进行了导入但是使用对应类的时候仍然显示没有import包时报程序包不存在的问题</strong></p><ul><li>清除 Idea 缓存，很多情况下idea导致的问题通过这个方式基本都能解决</li><li>方式：-&gt; 工具栏 -&gt; File -&gt; Invalidate Caches &#x2F; Restart</li></ul><p><strong>报错expected single matching bean but found 2：</strong></p><ul><li>@MapperScan(“com.hmdp.mapper”)中限定的范围不小心改成了@MapperScan(“com.hmdp”)</li></ul><p><strong>使用maven导包一直显示waiting for maven import completion：</strong></p><ul><li>将maven版本由3.8.5降为3.5.4</li><li>idea对于不同的maven适配不同，需要进行相应适配<ul><li>IDEA 2022 兼容maven 3.8.1及之前的所用版本</li><li>IDEA 2021 兼容maven 3.8.1及之前的所用版本</li><li>IDEA 2020 兼容Maven 3.6.3及之前所有版本</li><li>IDEA 2018 兼容Maven3.6.1及之前所有版本</li><li><a href="https://libin9ioak.blog.csdn.net/article/details/117571120?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-117571120-blog-123527235.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-117571120-blog-123527235.pc_relevant_antiscanv2&utm_relevant_index=6">IDEA各版本对Maven版本兼容</a></li></ul></li></ul><p><strong>显示xml不对并且一直无法导入：</strong></p><ul><li>配置镜像源的时候多打了一列标签导致识别错误</li><li>显示某个依赖包导入不成功可以将其在仓库中手动删去，然后在idea中清除缓存重新导入</li></ul><p><strong>测试类中使用@Autowired无法将对应的服务类进行导入报错空指针：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加下面两个注解在测试类上即可</span><br><span class="hljs-meta">@SpringBootTest(classes = ReggieApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishMapper dishMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishService dishService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println((<span class="hljs-string">&quot;----- selectAll method test ------&quot;</span>));<br>        List&lt;Dish&gt; dishList = dishMapper.selectList(<span class="hljs-literal">null</span>);<br>        dishList.forEach(System.out::println);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>Maven相关配置：</strong></p><ul><li>Use settings from .mvn&#x2F;maven.config：表示使用后面的配置文件来覆盖原来的设置</li></ul><p><strong>报错Unsupported class file major version 60：</strong></p><ul><li><a href="https://blog.csdn.net/m0_51426055/article/details/124748032">(39条消息) Java新建Maven项目学习Spring注解开发显示：Unsupported class file major version 60_此方星河的博客-CSDN博客</a></li></ul><p><strong>配置好了Redis相关的属性但是依旧报错：</strong></p><ul><li><p>配置Redis的文档不正确</p></li><li><p>由于yaml是根据缩进进行控制的，所以可能是缩进没有配置好</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">reggie_take_out</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3307/hotelmanage?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">abc1234</span><br>  <span class="hljs-attr">redis:</span>  <span class="hljs-comment"># 注意Redis的配置时在spring中的</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.129</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">abc1234</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">time-between-eviction-runs:</span> <span class="hljs-string">10s</span><br><br></code></pre></td></tr></table></figure></li><li><p>配置Redis相关的xml配置缺漏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入Redis对应的依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--使用Redis必须导入的依赖的包 (这个包要是缺失就会报错 Unsatisfied dependency expressed through field ‘redisTemplate‘；)--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>使用mybatis-Plus过程中正常调用方法但是显示SQL语法错误</strong></p><ul><li>错误原因：使用了order作为表名，但是order本身就是SQL中的关键导致报错</li><li>解决方法：修改数据库表名，然后使用mybatisPlus的注解手动映射即可  @TableName(“my_order”)</li></ul><p><strong>使用SQL文件运行后数据库依然错误：</strong></p><ul><li>错误原因：由navicat生成的sql文件只会产生新增加的表，但不会自动删除原本SQL文件中不存在的表</li><li>解决方法：清空数据库再运行SQL文件</li></ul><p><strong>慢慢配置了Redis的对应配置文件的密码但是报错ERR AUTH<password> called without anypassword configured for the default user</strong></p><ul><li><p>错误原因：配置没有生效，所以导致其实并没有给docker容器设置对应密码</p></li><li><p>解决方法：在yml中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">redis:</span><br>   <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.85</span><span class="hljs-number">.129</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>   <span class="hljs-attr">password:</span>    <span class="hljs-comment"># 注意这里是空密码</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>给某个实体类设置了null值但是实际运行过程发现可以对实体赋值正常数值，但是不能设null</strong></p><ul><li><p>错误原因：</p><ul><li>使用Mybatis-plus操作数据库时，如果未自己写sql而是采用Mybatis-plus的方法设置sql的情况下，默认Mybatis-plus生成sql时会将设置为null的字段忽略掉(不更新该字段)；所以默认情况下，使用Mybatis-plus的方法操作数据库时没办法设置一个字段的值为null(除非该字段数据库表设置默认值就为null)</li><li>Mybatis-plus设计如此很好理解，比如现在我们的系统中一般都是做逻辑删除即修改删除标记的字段为删除状态的值，此时执行update语句时，一般根据id作为条件只设置删除标记字段的值就行，其他字段值不做设置也就是为null，如果Mybatis-plus也将这些字段进行更新的话，那么其他字段全是null，这样会造成数据丢失，问题很大；如果每个字段全部设置成之前的值，需要先进行一次查询操作，以及设置每个字段的值的操作，比较麻烦一些，很明显没有必要；所以Mybatis-plus默认忽略字段值为null的字段不做更新</li></ul></li><li><p>解决方法：</p><ul><li><p>手动写sql语句</p><ul><li>在mapper.xml中写对应的sql语句(insert语句&#x2F;update语句&#x2F;where条件中设置对应字段的值为null即可)</li></ul></li><li><p>实体类对应字段添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@TableField(insertStrategy = FieldStrategy.IGNORED)</span>   <br><span class="hljs-comment">//添加该注解值的字段在Mybatis-plus生成insert sql时会忽略该字段值的判断</span><br><span class="hljs-meta">@TableField(updateStrategy = FieldStrategy.IGNORED)</span>   <br><span class="hljs-comment">//添加该注解值的字段在Mybatis-plus生成update sql时会忽略该字段值的判断</span><br><span class="hljs-meta">@TableField(whereStrategy = FieldStrategy.IGNORED)</span>    <br><span class="hljs-comment">//添加该注解值的字段在Mybatis-plus生成sql时的where条件中会忽略该字段值的判断</span><br><span class="hljs-meta">@TableField(insertStrategy = FieldStrategy.IGNORED,updateStrategy = FieldStrategy.IGNORED,whereStrategy = FieldStrategy.IGNORED)</span> <br><span class="hljs-comment">//综合上面三个注释</span><br><br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>报错400 ：JSON parse error: Cannot deserialize instance of <code>java.lang.Integer</code> out of VALUE_TRUE token：</strong></p><ul><li>错误原因：JSON解析错误，前端传过来的值与后端值类型不匹配，例如前端传一个字符串，结果使用的是int接受</li><li>解决方法：修改对应的数值</li></ul><p><strong>下载  jetbrain  系的IDE无法正常使用破解软件进行激活</strong></p><ul><li>错误原因：自带的软件破解方式只能破解2021年的软件而不能破解2022年的软件版本</li><li>解决方法：重新下载前一年的版本</li></ul><p><strong>无法连接上数据库</strong></p><ul><li>错误原因：使用的Linux 上的mysql是使用docker进行搭建的，所以忘记了密码</li><li>解决方法：在配置文件中增加  skip-grant-tables 跳过密码校验进行登录</li></ul><p><strong>编写的配置类一直无法生效</strong></p><ul><li>错误原因：config包未放在同一目录下，没有仔细放置</li><li>解决方法：放到同一目录下</li></ul><p><strong>在使用Spring框架中的Config配置中心时，设置了配置文件并commit到了仓库但依然无法通过http获取</strong></p><ul><li>错误原因：java.nio.charset.MalformedInputException: Input length &#x3D; 1，  是因为你的配置文件里面有中文或者是你的编码格式不正确导致</li><li>解决方法：使用英语或者使用UTF-8编码集</li></ul><p><strong>Idea配置cmd脚本时，报错open Local Terminal_Failed to start [powershell.exe]</strong></p><ul><li>错误原因：idea找不到对应的cmd.exe文件</li><li>解决方法：setting-&gt;tool-&gt;终端，设置对应的cmd.exe即可</li></ul><p><strong>无法通过idea ssh连接Ubuntu虚拟机</strong></p><ul><li>错误原因：缺少相关设置</li><li>解决方法：安装OpenSSH，修改OpenSSH相关配置文件</li></ul><p><strong>使用nacos配置中心的时候无法读取对应的设置好的配置</strong>（尚未解决）</p><ul><li>错误原因：没有在pom.xml中导入对应的依赖（有一次导入错误，导入到了父项目的xml中）</li><li>解决方法：在对应项目中导入nacos相关依赖即可</li><li>提示：当配置 yml 时，如果部分属性出现警告或者没有自动补全，说明很可能是没有引入对应的依赖</li></ul><p><strong>使用linux无法登陆到root用户</strong></p><ul><li>错误原因：部分系统默认不开启root用户登陆，需要手动打开并且设置 root用户的密码</li><li>解决方法：sudo passwd root 修改密码即可</li></ul><p><strong>使用Xshell有时运行指令速度较慢：</strong></p><ul><li>解决方法：在ssh配置文件中关闭DNS 解析即可</li></ul><p><strong>在对微服务项目进行打包时发现报错：dependencies.dependency.[com.xiaozhao:commons:0.0.1-SNAPSHOT] for com.xiaozhao:commons:0.0.1-SNAPSHOT is referencing itself. @</strong> </p><ul><li>错误原因：父项目本身只是个框架，却错误的在pom.xml中增加了对common模块的依赖</li><li>解决方法：删除对common模块的依赖即可</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E3%80%8ARedis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E3%80%8ARedis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>实际上Redis的直接启动无法自定义配置，所以这种方式是不适合在生产环境中使用的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Linux%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/Linux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Linux不存在所谓分区，所有的文件都是以树状进行排列</p><p>Linux存在一个超级用户为root，正常用户只能在自己的用户目录下，但是在root下，他可以操纵所有用户的文件</p><p>一般不建议使用root对Linux进行访问，避免由于过高的权限级导致删除部分重要数据，使得系统崩溃</p><p>单纯一个斜杠表示的即为在根目录下查看</p><p>常见使用错误：</p><ul><li><p>Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</p><p>需要在root用户下使用命令</p></li><li><p>Docker: driver failed programming external connectivity on endpoint xxx </p><p>重启docker即可  systemctl restart docker</p></li><li><p>Windows无法连接到docker的容器</p><p>重启Ubuntu，注意不是重启docker</p></li><li><p>登录密码不正确</p><p>忘记打开小键盘数字键，没能输入正确</p></li></ul><p>使用过的Linux指令：</p><p>sudo lsb_release -a：查看当前Ubuntu的版本，LTS是Long Term Support:长时间支持版本</p><p><strong>常见不同Linux发行版本不同，其对应的包管理工具也不同：</strong></p><ul><li>Red Hat 系列：centOS等 使用 rpm ，yum</li><li>Debian   系列：Ubuntu 等 使用 apt</li></ul><p><strong>Linux虚拟机连接过程中的网络设置：</strong></p><ul><li>使用桥连网络：为客户机操作系统提供直接访问外部以太网网络的权限，客户机在外部网络上必须有自己的ip地址（客户机和宿主机是分立的）</li><li>使用网络地址转换（NAT）：为客户机操作系统提供使用主机ip地址访问主机拨号连接或者外部以太网网络连接的权利（相当于客户机封装到宿主机里面，在外部看就是一体的）</li></ul><p><strong>虚拟机的磁盘管理方式：</strong></p><ul><li>虚拟磁盘：虚拟磁盘由主机文件系统上的一个或者多个文件组成，客户机操作系统会将其视为单个硬盘，虚拟磁盘可以在一台主机或者多台主机之间轻松复制或者移动</li><li>物理磁盘：为虚拟机直接提供访问本地磁盘的权限，需要具有管理员特权</li></ul><p><strong>Linux终端符号含义：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xiaozhao@ubuntu:~ $    <br>root@ubuntu:/home/xiaozhao # <br></code></pre></td></tr></table></figure><ul><li>格式：  用户名@主机名 ：当前路径  $<ul><li>~:是指在根目录下</li><li>普通用户的标志是 $ ，root用户的标志是 #</li></ul></li></ul><p><strong>ISO镜像文件：</strong></p><p>.iso是电脑上 光盘镜像（CD Mirror）的存储格式之一，因为其是根据ISO-9660有关 CD-ROM 文件系统标准存储的文件，所以通常在电脑中以后缀.iso命名，俗称iso镜像文件。它形式上只有一个文件，可以真实反映光盘的内容，可由<a href="https://baike.baidu.com/item/%E5%88%BB%E5%BD%95%E8%BD%AF%E4%BB%B6/6282041">刻录软件</a>或者<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a>文件制作工具创建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%A1%A5%E5%85%85%E7%89%88%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%A1%A5%E5%85%85%E7%89%88%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>路由器可以看做是一种特殊的计算机，只是我们一般不将其看作为主机，路由器起到分组交换作用，也是最重要的分组交换机，其负责将各种网络互联起来，并对接收到的分组进行转发，也就是进行分组交换</p><p>分组信息中的信息单元存在头部，用于存放分组信息的元素属性等</p><p>当多个联网设备之间连接距离过小，则称之为多处理机系统，而不称之为计算机网络</p><p>信道利用率并不是越高越好，越高会导致拥堵</p><p><strong>局域网：</strong>局域网自然就是局部地区形成的一个区域网络，其特点就是分布地区范围有限，可大可小，大到一栋建筑楼 与相邻建筑之间的连接，小到可以是办公室之间的联系。局域网自身相对其他网络传输速度更快，性能更稳定</p><p><strong>数据链路层的三个重要问题：</strong>封装成帧、差错检测、可靠传输</p><p>停止等待协议由于本身发送数据所耗费的时间很短，而花费了大量时间用于等待信息的传递，导致信道利用率很低</p><p><strong>MAC地址：</strong></p><ul><li>Media Access Control(媒体接入地址)，属于数据链路层地址，mac地址一般被固化在网卡的只读存储器上，因此Mac地址也称之为硬件地址、物理地址（虽然称之为物理地址，但是其属于数据链路层而不是物理层）</li><li>注意Mac地址并不是固定不变的，如果当设备的网卡损坏后，需要更换网卡时，则设备对应的Mac地址则为新网卡的Mac地址，所以Mac地址实际上并不是设备的物理地址，更准确的说应该是网络接口的物理地址</li></ul><p>ARP协议只能在一段链路或者一个网络上使用，而不能跨网络进行使用</p><p>集线器的使用会导致广播域和碰撞域都被扩大，而使用交换机则只会增大广播域而不会增大碰撞域，使得交换机的性能远远高于集线器，集线器已被淘汰</p><p>交换机中的数据是会定期删除的，因为主机的Mac地址并不是一成不变的</p><p>为了避免在交换机设备之间出现环状网络，需要使用生成算法得到对应的生成树，并且当生成树中的链路发生故障时，利用剩余的链路重新构造出生成树</p><p>IP地址和Mac地址类似，其地址都是表示接口的对应地址而不是主机的对应地址</p><p>ip地址经历了以下<strong>三种阶段</strong>：分类编址、划分子网、无分类编址</p><p><strong>网络地址和广播地址解析：</strong></p><ul><li>网络地址是识别网络ID用的  如192.168.1.0  说明该网段属于192.168.1的段  属于不可用IP</li><li>广播地址是用来进行广播的  如ARP广播 这个地址是一个通用地址  如192.168.1.255  ip为192.168.1.1–192.168.1.254 这些机器在询问网关的时候把信息发往192.168.1.255  所有的机器都可以接收到它发来的信息</li><li>网络地址和广播地址都是保留给网络使用的，不能作为IP使用，并且网络地址和广播地址是机器自动识别的 在所有机器上应用<ul><li>即每台机器上的广播地址都是192.168.1.255，而只要配置了192.168.1.x范围内的网段的机器 通过标准的子网掩码255.255.255.0机器都会默认自己是属于192.168.1.0的网段</li></ul></li></ul><p>网络使用多少位作为子网的划分区间取决于其子网掩码的值</p><p><strong>网络地址和ip地址：</strong></p><ul><li>主机所在的ip地址和对应的子网掩码进行按位与运算就可以得到该主机所在网络的网络地址，并且如果将该主机的ip地址和另外一台主机即目标主机所在的ip地址进行按位与运算就能得到目标主机的网络地址</li><li>即主机的ip地址和主机所在的网络的网络地址不是一回事，主机的ip地址是由网络号、子网号以及主机号组成的，需要使用主机的ip地址和子网掩码进行按位与运算得到对应的网络地址</li><li>在路由器进行转发的过程中，路由器从路由表中取出一条条目的网络地址，子网掩码，以及下一跳数据对应的行，先将目标地址和该条数据的子网掩码进行按位与运算，然后跟该条数据目标网络地址比较得到</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\计算机网络图片\微信图片_20220905140605.jpg" alt="微信图片_20220905140605"></p><ul><li>路由器是隔离广播域的，当收到广播信息后路由器不会对其进行转发操作，避免产生广播风暴造成资源浪费</li></ul><p>为了使得OSPF能够应用于规模很大的网络，OSPF将一个自治系统划分成若干个更小的范围，称之为区域，采取这样分层次划分区域的方法，将交换信息的种类增多了，但减少了每一个区域内部交换路由协议的通行量大大减小，划分区域同时也能够将利用洪泛法交换链路状态信息的范围局限于每一个小区域，减少了一个自治系统的通信量</p><p>ipv4的意思是ip协议的版本号为4</p><p>使用三次握手而不是两次握手的原因在于，第三次握手的存在能够防止在网络中传输滞留的连接请求报文段突然有传送到了TCP服务器导致错误</p><p>注意确认报文段中的序号是 “ 第一个未接收的报文序号 ”</p><p>新增的主机向网络中发送DHCP数据报的源ip地址为 0.0.0.0，因为此时主机还未分配ip地址</p><p>并不是在每一个网络上都存在DHCP服务器，这样会使得DHCP服务器数量过多，对于无DHCP的网络的解决办法是给该网络中对应的路由器配置其他网络中DHCP服务器的IP地址使其成为DHCP的中继代理，当该网络中需要使用DHCP时，由该路由器向对应DHCP服务器发出单播</p><p><strong>防火墙：</strong></p><ul><li>防火墙可以针对ip，域名、协议、软件、端口、关键词等，限定只有某一种网络数据能够通过</li><li>防火墙的分类<ul><li>主机防火墙：安装在主机上的防火墙，用于单独保护主机，win系统自带防火墙，或者许多杀毒软件等也提供主机防火墙</li><li>网络型防火墙：网络型防火墙由软件和硬件组成，其运行在网络层，放置在私有网络和公共网络之间，其能够管理整个网络中的通信，网络型防火墙可以是专门的硬件、内置在路由器中或部署在云服务器中</li><li>在实际应用中往往主机防火墙和网络型防火墙都会进行使用</li><li>例如国内防火墙往往使用DNS污染或者劫持、过滤关键字、流量限制、ip地址封锁等方式来限制访问</li></ul></li></ul><p><strong>VPN：</strong></p><ul><li><p>VPN即 <strong>虚拟专用网络</strong></p></li><li><p>VPN实际上是在两个主机通信之间增加两个vpn集线器，当A主机发送数据包时，会先经过VPN集线器，并将该数据包中的源地址修改为这个VPN集线器的地址，而目标地址改为另一个VPN集线器的地址，就好像在两个主机之间增加了一个隧道进行通信</p></li><li><p>vpn有以下三种作用</p><ul><li>保密：对数据进行加密，往往使用AES、3DES进行加密</li><li>完整：保护数据的完整性、往往通过Hash算法，双方通过对消息计算Hash、进行比对来判断是否进行过篡改</li><li>认证：常常使用PSK或RSA进行认证</li></ul></li><li><p>VPN的实现主要运用了以下两大协议，其两大协议的核心都是安全</p><ul><li>IPsec（IP security）：可以应用于客户端对站点，也可以应用于站点对站点、多数是用于站点对站点VPN，其运行在网络层</li><li>SSL&#x2F;TLS：往往应用于客户端对站点的情况，只要使用支持VPN的浏览器就能使用VPN，其运行在表示层上</li></ul></li></ul><p>主机能够识别普通以太网MAC帧，但是不能识别801.2Q帧只能对该帧进行丢弃</p><p><strong>最长前缀匹配：</strong>当匹配到多条能够抵达目标地址的IP地址时，使用斜线后数字最大的网络，即最具体的网络</p><p><strong>对等网络：</strong>对等网络，即对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。“Peer”在英语里有“对等者、伙伴、对端”的意义。因此，从字面上，P2P（Peer-to-peer）可以理解为对等计算或对等网络。国内一些媒体将P2P翻译成“点对点”或者“端对端”，学术界则统一称为对等网络（Peer-to-peer networking）或对等计算</p><p><strong>中继器（RP repeater）</strong>：工作于<a href="https://baike.baidu.com/item/OSI/5520?fromModule=lemma_inlink">OSI</a>的<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82?fromModule=lemma_inlink">物理层</a>，是<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91?fromModule=lemma_inlink">局域网</a>上所有<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9?fromModule=lemma_inlink">节点</a>的中心，它的作用是放大信号，补偿信号<a href="https://baike.baidu.com/item/%E8%A1%B0%E5%87%8F?fromModule=lemma_inlink">衰减</a>，支持远距离的通信。中继器。工作于物理层，只是起到扩展传输距离的作用，对高层协议是透明的。</p><p><a href="https://blog.csdn.net/damountain/article/details/78047832">单播，组播，多播 解析</a></p><p>网关和路由器的区别：</p><ul><li>网关：让两个不同网络相互之间进行通信，可以使具有不同协议的网络相互连接</li><li>路由器：能在计算机网络之间发送和接收数据包的设备，并且提供最佳路由路径的一种网络互联设备。但是只能在使用相同协议的网络中转发数据包</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h2 id="1-1什么是Internet"><a href="#1-1什么是Internet" class="headerlink" title="1.1什么是Internet"></a>1.1什么是Internet</h2><p><strong>BPS：</strong></p><ul><li>比特率，是指单位时间内传送的bit数，单位为bps（bit per second）</li><li>在近代数字通信中，数字化的视频等信息传输量较大，因此往往以每秒千比特或每秒兆比特为单位于以计量，分别写作kbit&#x2F;sec（或kbps）和Mbit&#x2F;sec（或Mbps）</li></ul><p>遵守同一协议的数据才能进行相互通信</p><p><strong>PDU：</strong></p><ul><li>协议数据单元，是指在分层网络结构，例如在开放式系统互联（OSI）模型中，在传输系统的每一层都将建立协议数据单元（PDU）</li></ul><p><strong>ICP：</strong></p><ul><li>ICP即网络内容服务商，英文为 Internet Content Provider ，即向广大用户综合提供互联网信息业务和增值业务的电信运营商</li></ul><p>分层的意义在于，只要同层使用相同的协议就可以保持正常通信，并且其他层可以更换不同的协议，将大的问题转换成多个小的问题</p><p>计算机分层只允许层与层之间进行调用，而不允许跨层调用</p><p><strong>互联网的理解：</strong></p><ul><li>互联网不是唯一的网络，只是应用最为广泛的网络，网络是由一堆网络通过连接设备进行互联的网络</li><li>互联网也可以理解成分布式的应用，以及为分布式应用提供通信服务的基础设施，应用层以下的都可以看做基础设施</li></ul><p><strong>网络的组成：</strong></p><ul><li><p>结点：</p><ul><li><p>主机结点：服务器</p></li><li><p>数据交换结点：路由器、交换机（不是数据的源也不是数据的目标，而是中间结点）</p></li></ul></li><li><p>边：即通信链路</p><ul><li>接入网链路：主机连接到互联网的链路 </li><li>主干链路：路由器间的链路</li></ul></li><li><p>协议：对等层的应用进程在通行过程中应该遵守的规则集合</p></li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p><strong>网络结构：</strong></p><ul><li>网络边缘：端系统，主机，应用程序</li><li>网络核心：互连着的路由器 ，网络的网络，完成网络边缘的设备的数据交换</li><li>接入网、物理媒体： 有线或者无线通信链路</li></ul><p><strong>C&#x2F;S和B&#x2F;S的区别</strong></p><p><strong>P2P模式</strong>：每个结点都是服务器和客户端，文件分发系统往往使用这个模式，如迅雷等</p><p><strong>TCP和UDP的关系：</strong></p><ul><li>TCP 传输控制协议（Transmission Control Protocol ） <ul><li>可靠地：按顺序地传送数据 确认和重传</li><li>流量控制 ：发送方不会淹没接收方</li><li>拥塞控制 ：当网络拥塞时，发送方降低发送速率</li><li>使用TCP的应用：<ul><li>HTTP (Web), FTP (文件传送), Telnet (远程登录), SMTP (email)</li></ul></li></ul></li><li>UDP 用户数据报协议( User Datagram Protocol ) <ul><li>无连接 </li><li>不可靠数据传输 </li><li>无流量控制 </li><li>无拥塞控制</li><li>使用 UDP的应用：<ul><li>流媒体、远程会议、 DNS、Internet电话</li></ul></li></ul></li></ul><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>TCP是面向连接而不是有连接：因为这个所谓的连接只体现在端系统（源主机和目标主机）的TCP实体上，中间的路由器不维护两个端系统的通信状态，故称之为面向连接</p><p><strong>交换数据的方式：</strong></p><ul><li>电路交换：为每个呼叫预留一条专有电路<ul><li>电路交换不适用于计算机的原因<ul><li>连接建立时间长</li><li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多 即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li><li>可靠性不高</li></ul></li></ul></li><li>分组交换：分组交换的最大意义是实现了资源的共享性，提高了共享效率<ul><li>注意要使用存储转发的方式，否则交换数据的方式就退化成电路交换了</li><li>同样的网络资源，分组交换允许更多用户使用网络</li></ul></li></ul><h2 id="1-4-接入网和网络媒体"><a href="#1-4-接入网和网络媒体" class="headerlink" title="1.4 接入网和网络媒体"></a>1.4 接入网和网络媒体</h2><p><strong>调制解调器（Modem）：</strong></p><ul><li>调制解调器，其实就是Modulator（调制器）与Demodulator（解调器）的简称。是一种把要传输的数字信号调制到载波上或从载波上把数字信号分离出来</li><li>计算机在发送数据时，先由Modem把数字信号转换为相应的模拟信号，这个过程称为“调制”。经过调制的信号通过电话载波传送到另一台计算机之前，也要经由接收方的Modem负责把模拟信号还原为计算机能识别的数字信号，这个过程称为“解调”。正是通过这样一个  调制  与  解调  的数模转换过程，从而实现了两台计算机之间的远程通讯</li></ul><p><strong>物理媒体：</strong></p><ul><li>导引型媒体: 信号沿着固体媒介被导引：同轴电缆、光纤、 双绞线</li><li>非导引型媒体： 开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li></ul><h2 id="1-5-Internet结构和ISP-Internet-Service-Providers"><a href="#1-5-Internet结构和ISP-Internet-Service-Providers" class="headerlink" title="1.5 Internet结构和ISP((Internet Service Providers)"></a>1.5 Internet结构和ISP((Internet Service Providers)</h2><ul><li>端系统通过接入ISPs (Internet Service Providers)连接到互联网 <ul><li>住宅，公司和大学的ISPs ，也可以是个人的接入</li></ul></li><li>接入ISPs相应的必须是互联的 <ul><li>因此任何2个端系统可相互发送分组到对方   导致的“网络的网络”非常复杂</li></ul></li><li>发展和演化是通过经济的和国家的政策来驱动的</li></ul><h2 id="1-6-分组延时、丢失和吞吐量"><a href="#1-6-分组延时、丢失和吞吐量" class="headerlink" title="1.6 分组延时、丢失和吞吐量"></a>1.6 分组延时、丢失和吞吐量</h2><p><strong>分组延时：</strong></p><ul><li>节点处理延时</li><li>排队延时</li><li>传输延时</li><li>传播延时</li></ul><p><strong>分组丢失：</strong></p><ul><li>产生丢失的原因：链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组将会丢失</li><li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传，比如tcp就会进行重传，而udp就不会进行重传</li></ul><p>流量强度达到1时，排队延迟将变得非常大，以至于部分分组会产生丢失问题，流量强度随着逐渐趋近于1导致排队延迟激增</p><p><strong>瓶颈链路：</strong>端到端路径上，限制端到端吞吐的链路</p><h2 id="1-7-协议层次及服务模型"><a href="#1-7-协议层次及服务模型" class="headerlink" title="1.7  协议层次及服务模型"></a>1.7  协议层次及服务模型</h2><p><strong>层次化方式实现复杂网络功能:</strong> </p><ul><li>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务 </li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务 </li><li>在实现本层协议的时候，直接利用了下层所提供的服务</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务</li></ul><p><strong>服务( Service)：</strong>低层实体向上层实体提供它们之间的通信的能力 </p><ul><li>服务用户(service user) </li><li>服务提供者(service provider )</li></ul><p><strong>原语(primitive)：</strong>上层使用下层服务的形式，高层使用低层提供的服务，原语即提供服务的形式，以及低层向高层提供服务都是通过服务访问原语来进行交互的形式，下层提供的函数调用</p><p><strong>服务访问点 SAP (Services Access Point) ：</strong>上层使用下层提供的服务通过层间的接口—地点； 服务访问点总结就是用于下层的服务提供者来区分不同上层用户的穿过层间的信息</p><ul><li>例子:邮箱 </li><li>地址(address)：下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用 </li><li>可以有不同的实现，队列 </li><li>例子:传输层的SAP: 端口(port)</li></ul><p><strong>服务的类型：</strong></p><ul><li><p>面向连接的服务( Connection-oriented Service) ：连接(Connection)即两个通信实体为进行通信而建立的一种结合</p></li><li><p>无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃</p></li></ul><p><strong>服务和协议的关系：</strong></p><ul><li>服务与协议的区别：<ul><li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直 </li><li>协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li></ul></li><li>服务与协议的联系：<ul><li>本层协议的实现要靠下层提供的服务来实现 </li><li>本层实体通过协议为上层提供更高级的服务</li></ul></li></ul><p><strong>数据单元：</strong>上一层通过SAP传下来SDU然后将其转换成本层的多个PDU然后进行传递，本层产生的数据头部一部分来自于上层的ICI，一部分来自于本身的信息组成，并且PDU每层的称呼都不相同（数据报，帧，分组等）</p><p><strong>分层处理和实现复杂系统的利弊：</strong></p><ul><li>概念化：结构清晰，便于标示网络组件，以及描述其相互关系<ul><li>分层参考模型</li></ul></li><li>结构化：模块化更易于维护和系统升级 <ul><li>改变某一层服务的实现不影响系统中的其他层次 <ul><li>对于其他层次而言是透明的</li></ul></li><li>如改变登机程序并不影响系统的其它部分 <ul><li>改变2个秘书使用的通信方式不影响2个翻译的工作 </li><li>改变2个翻译使用的语言也不影响上下2个层次的工作</li></ul></li></ul></li><li>分层思想的问题<ul><li>效率相对于以整体的稍低</li></ul></li></ul><p><strong>OSI参考模型分层结构：</strong></p><ul><li>应用层: 网络应用 <ul><li>为人类用户或者其他应用进程提供网络应用服务 </li><li>FTP, SMTP, HTTP,DNS</li></ul></li><li>传输层: 主机之间的数据传输 <ul><li>在网络层提供的端到端通信基础上，细分为进程到进程（使用端口进行区分进程到进程之间的区分），将不可靠的通信变成可靠地通信 </li><li>TCP, UDP</li></ul></li><li>*表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机器相关的表示转换</li><li>*会话层: 数据交换的同步，检查点，恢复</li><li>网络层: 为数据报从源到目的选择路由 （路由即“找路”）<ul><li>主机主机之间的通信，端到端（可以跨越多个端点）通信，不可靠 </li><li>IP（做转发的协议）, 路由协议</li></ul></li><li>链路层: 相邻网络节点间的数据传输 <ul><li>2个相邻2点的通信，点到点（两台主机之间直接相连）通信，传输帧，可靠或不可靠 </li><li>点对对协议PPP, 802.11(wifi), Ethernet（一般链路层和物理层是一并写在网卡上的）</li></ul></li><li>物理层: 在线路上传送bit </li><li>注意：在互联网协议栈没有表示层、会话层、这两层，这些服务被归属到应用层上</li></ul><p><strong>各层次的协议数据单元：</strong></p><ul><li>应用层：报文(message)</li><li>传输层：报文段(segment)：TCP段，UDP数据报</li><li>网络层：分组(packet)，如果无连接方式则称之为数据报(datagram） </li><li>数据链路层：帧(frame)</li><li>物理层：位(bit)</li></ul><h1 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h1><h2 id="2-1-应用层原理"><a href="#2-1-应用层原理" class="headerlink" title="2.1 应用层原理"></a>2.1 应用层原理</h2><p>TCP和UDP分别占用不同的端口号进行使用</p><p><strong>网络应用的体系架构</strong></p><ul><li>客户-服务器模式（C&#x2F;S:client&#x2F;server） ：随着用户增多性能呈断崖式下降</li><li>对等模式(P2P:Peer To Peer) ：随着用户增多效率慢慢线性下降</li><li>混合体：客户-服务器和对等体系结构  eg:Napster</li></ul><p><strong>对进程进行编址（addressing）</strong> </p><ul><li>进程为了接收报文，必须有一个标识<ul><li>即：SAP（发送也需要标示）</li><li>主机：唯一的 32位IP地址 <ul><li>仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行</li></ul></li><li>所采用的传输层协议：TCP or UDP</li><li>端口号（Port Numbers）</li></ul></li><li>一些知名端口号的例子：<ul><li>HTTP: TCP 80 Mail: TCP25 ftp:TCP 2</li></ul></li><li>一个进程：用IP+port标示 端节点，一个进程最基本使用IP+port标示</li><li>本质上，一对主机进程之间的通信由2个端节点构成</li></ul><p><strong>套接字（socket）</strong></p><ul><li>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有<strong>本地意义的标示</strong><ul><li>4元组：(源IP，源port，目标IP，目标port)</li><li>唯一的指定了一个会话（2个进程之间的会话关系）</li><li>应用使用这个<strong>标示</strong>，与远程的应用进程通信</li><li>不必在每一个报文的发送都要指定这4元组</li><li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li><li>简单，便于管理，减少穿过层间的信息量</li></ul></li><li>socket并不是直接标明了端口号等信息，在TCP中socket表示的是本地的ip、本地TCP端口、对方ip、对方TCP端口的一个<strong>本地标识</strong> ，是为了便于本地和对方之间通行的一个本地标识、注意这个socket是本地机的应用层和传输层之间建立的约定，只有这两层知道，物理层次上只是一个整数，甚至对方主机也不知道这个socket含义，具体socket的含义可以通过查表获得</li><li>注意UDP的套接字和TCP的套接字格式不同，对于使用无连接服务（UDP）的应用而言<ul><li>UDP socket： UDP服务，两个进程之间的通信需要之前无需建立连接 ，由于其具有如下特点<ul><li>每个报文都是独立传输的 </li><li>前后报文可能给不同的分布式进程</li><li>只能用一个整数表示本应用实体的标示 </li><li>报文可能传给另外一个分布式进程 ·1</li><li>保证穿过层间接口的信息大小最小</li></ul></li><li>UDP socket：本IP,本端口<ul><li>但是传输 报文时：必须要提供对方IP，port </li><li>接收报文时： 传输层需要上传对方的IP，port</li></ul></li><li>传输信息必要条件<ul><li>数据本身</li><li>源主机的socket：本IP,本端口</li><li>对方的IP，port（使用特殊的数据结构但不是socket）</li></ul></li><li>UDP socket解析<ul><li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示</li><li>2元组：IP，port （源端指定）</li><li>UDP套接字指定了应用所在的一个端节点（end point） </li><li>在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port 但是在发送报文时，必须要指定对方的ip和udp port(另外一个段节点)</li></ul></li></ul></li></ul><p><strong>TCP和UDP的区别</strong></p><ul><li><p>TCP 服务：可靠的传输服务</p><ul><li><p>流量控制：发送方不会淹没接受方</p></li><li><p>拥塞控制：当网络出现拥塞时，能抑制发送方</p></li><li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p></li><li><p>不能提供的服务：时间保证、最小吞吐保证和安全</p></li></ul></li><li><p>UDP 服务：不可靠数据传输</p><ul><li>不需要建立连接，由于不可靠减少了很多原本为了保证可靠的操作</li><li>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接</li></ul></li><li><p>UDP服务的意义 </p><ul><li>能够区分不同的进程，而IP服务不能<ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li>无需建立连接，省去了建立连接时间，适合事务性的应用</li><li>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用 <ul><li>因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发）</li></ul></li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li></ul><p><strong>安全性相关：</strong></p><ul><li>由于TCP &amp; UDP 都没有加密，明文通过互联网传输，甚至密码也是明文</li><li>SSL在TCP上面实现，提供加密的TCP连接<ul><li>私密性</li><li>数据完整性</li><li>端到端的鉴别</li></ul></li><li>SSL在应用层<ul><li>应用采用SSL库，SSL库使用TCP通信</li></ul></li><li>SSL socket API<ul><li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li></ul></li><li>HTTPS &#x3D; HTTP +SSL</li></ul><h2 id="2-2-Web-and-HTTP"><a href="#2-2-Web-and-HTTP" class="headerlink" title="2.2  Web and HTTP"></a>2.2  Web and HTTP</h2><p>持久化HTTP和非持久化HTTP的主要区别就是看有无持久化的连接，非持久化每发送一次请求就创建一次连接，而持久化HTTP创建一个连接后多次使用</p><p><strong>持久HTTP分类：</strong></p><ul><li><p>流水方式的持久HTTP：</p><ul><li>HTTP&#x2F;1.1的默认模式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所有引用（小）对象只花费一个RTT是可能的</li></ul></li><li><p>非流水方式的持久HTTP：</p><ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li></ul><p><strong>web缓存（代理服务器）</strong></p><ul><li>目标：不访问原始服务器，就满足客户的请求</li><li>用户设置浏览器： 通过缓存访问Web</li><li>浏览器将所有的HTTP 请求发给缓存 <ul><li>在缓存中的对象：缓存直接返回对象 </li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul></li><li>缓存既是客户端又是服务器</li><li>通常缓存是由ISP安装 (大学、公司、居民区ISP)</li><li>使用web缓存的意义<ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存：可以使较弱的ICP也能够有效提供内容</li><li>相对于增加接入链路带宽消耗更低，所有的请求都需要经过本地缓存代理服务器，进行减少请求</li></ul></li></ul><p><strong>条件GET方法</strong></p><ul><li>为了避免缓存服务器中的数据和源服务器上的数据不同，需要使用get方法中的请求头参数来指明更新缓存的时间</li></ul><h2 id="2-3-FTP"><a href="#2-3-FTP" class="headerlink" title="2.3  FTP"></a>2.3  FTP</h2><ul><li>向远程主机上传输文件或从远程主机接收文件</li><li>客户&#x2F;服务器模式 <ul><li>客户端：发起传输的一方 </li><li>服务器：远程主机</li></ul></li><li>ftp: RFC 959</li><li>ftp服务器：端口号为21</li></ul><h2 id="2-4-EMail"><a href="#2-4-EMail" class="headerlink" title="2.4 EMail"></a>2.4 EMail</h2><p><strong>Base64：</strong></p><ul><li>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范</li><li>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读</li><li>由于Base64能够将二进制转化成8Bit字节码，并且email协议限定使用8Bit字节码，使得base64能够天生适应email协议的传送请求</li></ul><p><strong>MIME(Multipurpose Internet Mail Extensions)</strong></p><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种<a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E5%90%8D/103577">扩展名</a>的<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6/6270998">文件</a>用一种<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445">应用程序</a>来打开的方式类型，当该扩展名文件被访问的时候，<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8/213911">浏览器</a>会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式</li><li>它是一个互联网标准，扩展了电子邮件标准，使其能够支持：<ul><li>非<a href="https://baike.baidu.com/item/ASCII/309296">ASCII</a>字符文本；非文本格式附件（二进制、声音、图像等）；由多部分（multiple parts）组成的消息体；包含非ASCII字符的头信息（Header information）</li></ul></li><li>这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 MIME改善了由RFC 822转变而来的RFC 2822，这些旧标准规定电子邮件标准并不允许在邮件消息中使用7位ASCII<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6/4768913">字符</a>集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息原本都不能在电子邮件中传输(MIME可以)。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的<a href="https://baike.baidu.com/item/HTTP/243074">HTTP</a>协议中也使用了MIME的框架，标准被扩展为互联网媒体类型</li></ul><h2 id="2-5-DNS"><a href="#2-5-DNS" class="headerlink" title="2.5  DNS"></a>2.5  DNS</h2><ul><li><p>DNS的主要思路</p><ul><li><p>分层的、基于域的命名机制</p></li><li><p>若干分布式的数据库完成名字到IP地址的转换</p></li><li><p>运行在UDP之上端口号为53的应用服务</p></li><li><p>核心的Internet功能，但以应用层协议实现 </p><ul><li>在网络边缘处理复杂性</li></ul></li></ul></li><li><p>DNS主要目的：</p><ul><li>实现主机名-IP地址的转换(name&#x2F;IP translate)</li></ul></li><li><p>其它目的 </p><ul><li>主机别名到规范名字的转换：Host aliasing </li><li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing </li><li>负载均衡：Load Distribution</li></ul></li><li><p>DNS的二级域名的划分是根据其顶级域名所决定的，各顶级域名之间的划分互不干扰</p></li></ul><h2 id="2-6-P2P应用"><a href="#2-6-P2P应用" class="headerlink" title="2.6 P2P应用"></a>2.6 P2P应用</h2><p><strong>传统CS架构：</strong>文件传输的最长时间取决于，每个用户下载的最长时间和服务器的上传时间的最大值</p><p><strong>P2P架构：</strong>随着客户端的增加，请求资源的结点增加，但是提供服务的结点也在增加，使得随着请求量变大，所需要的时间缓慢增加</p><p>常见非结构化P2P模式：</p><ul><li>Napster模式<ul><li>当对等方连接时，它告知中心服务器，中心服务器负责管理目录来查找文件：</li><li>数据类型 ：IP地址 内容</li></ul></li><li>KaZaA模式<ul><li>利用不匀称性，结合P2P和CS模式</li><li>使用组长管理信息目录，并通过组长结点查询信息</li></ul></li><li>Gnutella模式<ul><li>全分布式，查询洪泛</li><li>没有中心服务器</li><li>开放文件共享协议</li><li>许多Gnutella客户端</li><li>实现了Gnutella协议</li><li>每次获取数据，向周边发出请求，周边结点如果没有数据则重复此操作</li></ul></li><li>BitTorrent模式<ul><li>tracker:跟踪torrent中参与节点</li><li>Torrent（洪流）: 节点的组，之间交换文件块<ul><li>文件被分为一个个块256KB</li><li>网络中的这些peers发送接收文件块，相互服务</li></ul></li></ul></li></ul><p><strong>结构化P2P模式</strong></p><ul><li>哈希表</li><li>DHT方案</li><li>环形DHT 以及覆盖网络</li><li>Peer波动</li></ul><h2 id="2-7-CDN"><a href="#2-7-CDN" class="headerlink" title="2.7  CDN"></a>2.7  CDN</h2><p><strong>CDN：</strong>Content distribution network</p><ul><li><p>在CDN节点中存储内容的多个拷贝 ，使视频内容靠近用户</p></li><li><p>用户从CDN中请求内容 </p><ul><li>重定向到最近的拷贝，请求内容 </li><li>如果网络路径拥塞，可能选择不同的拷贝</li></ul></li></ul><p><strong>多媒体流化服务</strong>：DASH（Dynamic, Adaptive Streaming over HTTP）</p><ul><li>服务器: <ul><li>将视频文件分割成多个块 </li><li>每个块独立存储，编码于不同码率（8-10种） </li><li>告示文件（manifest file）: 提供不同块的URL</li></ul></li><li>客户端: <ul><li>先获取告示文件 </li><li>周期性地测量服务器到客户端的带宽 </li><li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围</li><li>如果带宽足够，选择最大码率的视频块会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽) </li><li>根据所需要的视频格式和码率来根据告示文件来获取视频文件不同的块</li></ul></li></ul><h1 id="三、传输层"><a href="#三、传输层" class="headerlink" title="三、传输层"></a>三、传输层</h1><h2 id="3-1-概述和传输层服务"><a href="#3-1-概述和传输层服务" class="headerlink" title="3.1 概述和传输层服务"></a>3.1 概述和传输层服务</h2><p>UDP相对于IP而言都是提供尽力而为的服务，其中UDP通过使用端口号提供的是进程到进程的服务，IP提供的是主机到主机的服务，除此之外UDP并没有在IP服务至上提供更多的其他额外功能</p><h2 id="3-2-多路复用和解复用"><a href="#3-2-多路复用和解复用" class="headerlink" title="3.2  多路复用和解复用"></a>3.2  多路复用和解复用</h2><p>略</p><h2 id="3-3-无连接传输UDP"><a href="#3-3-无连接传输UDP" class="headerlink" title="3.3  无连接传输UDP"></a>3.3  无连接传输UDP</h2><p>使用UDP还是TCP取决于要强调这两种协议的哪方面优点，并且如果想要使用UDP的同时保证其安全性，可以使用UDP进行通信然后再在应用层实现安全性的保障等</p><h2 id="3-4-可靠数据传输的原理（RDT-Reliable-Data-Transfer-protocol）"><a href="#3-4-可靠数据传输的原理（RDT-Reliable-Data-Transfer-protocol）" class="headerlink" title="3.4  可靠数据传输的原理（RDT  Reliable Data Transfer protocol）"></a>3.4  可靠数据传输的原理（RDT  Reliable Data Transfer protocol）</h2><p>可靠数据传递的实现可以在应用层、传输层和数据链路层，但一般是在传输层使用TCP完成可靠数据传递</p><p>FSM(Finite State Machine)：有限状态机</p><p><strong>RDT2.0</strong></p><ul><li>确认(ACK)：发生下一个数据报</li><li>否定确认( NAK):发送上一次没有发送成功的数据</li><li>存在的问题：返回的确认信息确认(ACK)或者否定确认( NAK)可能出错</li></ul><p>RDT2.1</p><ul><li>由于两个状态之间的判断只需要使用0、1 区分即可，所以可以相邻的两个状态使用01划分而不是使用序列号划分</li><li>没有所谓的确认的确认，接受方通过检查发送方传递的数据的序号（01）来判断是否接受到</li></ul><p>RDT2.2：无NAK的协议</p><ul><li>对当前分组的反向确认可以使用上一组的正向确认来替代</li></ul><p>RDT3.0：</p><ul><li>假设存在比特差错和分组丢失的信道<ul><li>由于存在分组丢失的可能性，导致接收方和发送方都在保持等待对方的消息从而产生死锁</li></ul></li><li>解决死锁问题引入超时重传的机制，一般这个超时重传的时间设置为比正常时间稍长，一旦超过这个时间没有收到消息则重新发送数据，无论是传输过去的数据没有传递成功还是传输过来的数据没有传输成功都会导致超时，即都会进行适应设置超时重传<ul><li>超时重传机制可以保证接受方通过01数字来判断出数据包是否重复</li><li>链路层的timeout时间确定的</li><li>传输层timeout时间是适应式的</li></ul></li><li>rdt3.0可以工作，但链路容量比较大的情况下，性能很差<ul><li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li><li>瓶颈在于：网络协议限制了物理资源的利用</li></ul></li></ul><h2 id="3-5-面向连接的传输TCP-待看"><a href="#3-5-面向连接的传输TCP-待看" class="headerlink" title="3.5  面向连接的传输TCP  待看"></a>3.5  面向连接的传输TCP  待看</h2><h2 id="3-6-拥塞控制原理-待看"><a href="#3-6-拥塞控制原理-待看" class="headerlink" title="3.6 拥塞控制原理 待看"></a>3.6 拥塞控制原理 待看</h2><h2 id="3-7-TCP拥堵-待看"><a href="#3-7-TCP拥堵-待看" class="headerlink" title="3.7 TCP拥堵 待看"></a>3.7 TCP拥堵 待看</h2><h1 id="四、网络层：数据平面"><a href="#四、网络层：数据平面" class="headerlink" title="四、网络层：数据平面"></a>四、网络层：数据平面</h1><h2 id="4-1-导论"><a href="#4-1-导论" class="headerlink" title="4.1 导论"></a>4.1 导论</h2><p>路由和转发的辨析：</p><ul><li>路由：从源到目标的规划路径称之为路由</li><li>转发：每一个局部结点从哪个ip和端口进，以及从哪个ip和端口出称之为转发</li></ul><p>路由表是根据路由器信息等计算得到的？？？</p><p>路由表是控制平面和数据平面的交互桥梁，由控制平面的控制功能计算得到路由表，然后将路由表传递给IP协议，IP协议根据路由表对到来的分组进行局部转发实现数据平面的功能</p><p>ATM有许多模式，可以运转在多种不同模式之上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Kafka/"/>
    <url>/2023/03/06/Kafka/</url>
    
    <content type="html"><![CDATA[<p><strong>kafka的目录结构：</strong></p><ul><li>bin：kafka功能对应的脚本</li><li>conf：功能对应的各个配置信息</li></ul><p><strong>server对应需要配置的配置信息：</strong></p><ul><li>broker.id：每个不同的kafka对应的唯一标识id</li><li>log.dirs：存储数据的位置，需要修改不能放到对应的tmp中</li></ul><p>对应的分区只能增加不能减少</p><p>如果没有对分区进行设置，则会使用默认的分区DefaultPartitioner</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Nginx/"/>
    <url>/2023/03/06/Nginx/</url>
    
    <content type="html"><![CDATA[<p><strong>Nginx的目录结构：</strong></p><ul><li>conf：配置文件</li><li>html：存放的静态页面</li><li>log：存放的日志信息</li></ul><p><strong>Nginx使用多进程的解决方案：</strong></p><ul><li>master：用于协调其他子进程之间的关系</li><li>worker：存在多个，用于处理不同的业务需求</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>内部设置bean相当于内部类的实例化，外部设置bean相当于在外面进行实例化然后再进行导入</p><p>配置bean相当于创建一个对象类</p><p>使用bean进行设置时要注意需要对使用xml进行设置的属性配置对应的get和set方法</p><p>当配置后置处理器后，对于当前在xml文件中的所有bean都会进行添加后置处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">开启组件扫描，扫描全类名以com.atguigu开头的所有文件下的注释 </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span> = <span class="hljs-string">&quot;com.atguigu&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">通过自定义设置来选择扫描的内容</span><br><span class="hljs-comment"> use-default-filters=&quot;false&quot;  表示不使用默认的扫描格式而使用自定义的filter</span><br><span class="hljs-comment">    context:include-filter type 设置要扫描的内容</span><br><span class="hljs-comment">以下这种方式表示的是扫描以base-package = &quot;com.atguigu&quot;为开头的所有controller注释</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span> = <span class="hljs-string">&quot;com.atguigu&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">expression</span> = <span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注意上面的格式相区分</span><br><span class="hljs-comment">使用这种格式表示的正好和上面的相反，表明除了所有controller注释都扫描</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span> = <span class="hljs-string">&quot;com.atguigu&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">expression</span> = <span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">@Qualifier是根据名称进行注入</span><br><span class="hljs-comment">--&gt;</span><br>@Qualifier  <span class="hljs-comment">&lt;!--表示使用默认值，即待注入值的首字母小写为名的数据 --&gt;</span><br>@Qualifier(value = &quot;abc&quot;)<span class="hljs-comment">&lt;!--表示使用指定的数据进行注入 --&gt;</span><br></code></pre></td></tr></table></figure><p>包名为javax表示的是java原生拓展包</p><p>使用newInstance( )类似的方法后往往需要对获得的实例进行强转后再进行赋值</p><p>关于IOC的相关解析：<a href="https://blog.csdn.net/ivan820819/article/details/79744797">浅谈IOC</a>      &amp;      <a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fr=aladdin">控制反转</a>        &amp;      <a href="https://www.zhihu.com/question/335362570"> IOC是什么意思？</a></p><p>关于依赖注入的相关解析：<a href="https://www.zhihu.com/question/32108444">如何用最简单的方式解释依赖注入？</a></p><p>关于AOP的相关解析：<a href="https://baike.baidu.com/item/AOP/1332219?fr=aladdin">AOP  面向切面编程</a>  &amp;   <a href="https://blog.csdn.net/q982151756/article/details/80513340">AOP详解</a></p><p><strong>控制反转</strong>的定义意思为，现存在A对象，A对象在运行期间发现需要使用B对象，故A对象会<strong>“主动”</strong>创建一个B对象并进行控制，而在引入IOC以后，当A对象需要使用B对象的时候，由IOC进行创建一个B对象然后将这个B对象注入给A对象，此时A对象对于B对象的获取变成了<strong>“被动”</strong>获取，即控制反转的本质是：<strong>获得依赖对象的过程被反转</strong></p><p><strong>xmlns</strong>（XML Namespaces的缩写）是一个属性，是XML（标准通用标记语言的子集）命名空间。作用是赋予命名空间一个唯一的名称</p><p><a href="https://www.runoob.com/xml/xml-namespaces.html">XML 命名空间 </a></p><p><a href="https://blog.csdn.net/chenchunlin526/article/details/69939337">什么是JavaBean、bean? 什么是POJO、PO、DTO、VO、BO ? 什么是EJB、EntityBean？</a></p><p><strong>WEB-INF</strong>是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问</p><p><a href="https://www.cnblogs.com/shenxiaoquan/p/5819359.html">Web项目的WEB-INF目录使用说明以及重定向与转发 </a></p><p>**DAO(Data Access Object)**：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储</p><p><a href="https://www.runoob.com/design-pattern/data-access-object-pattern.html">数据访问对象模式</a></p><p><a href="https://www.thymeleaf.org/">Thymeleaf</a>官方网站</p><p><a href="https://www.runoob.com/servlet/servlet-intro.html">Servlet 简介 | 菜鸟教程 (runoob.com)</a></p><p>当指定的HTML文件使用了thymeleaf对应的命名空间，就可以在该HTML文件中使用thymeleaf对应的语法规则</p><p>在thymeleaf中，使用${ }所包裹的路径会自动添加上下文路径</p><p>在HTML的属性前面添加th:前缀表示的是这个属性要被thymeleaf所解析并设置</p><p>如果能使用springMVC本身提供的方法，就不要使用原生的API</p><p>name属性是为了区分不同的控件，而value是控件具体的值</p><p><a href="https://blog.csdn.net/ailunlee/article/details/90600174">HTTP请求的完全过程_</a></p><p><a href="https://blog.csdn.net/qq_37211608/article/details/81363121?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&utm_relevant_index=1">JavaWeb三大组件（Servlet、Filter、Listener）</a></p><p><a href="https://www.cnblogs.com/hjwublog/p/5051732.html">Thymeleaf 常用属性 )</a></p><p><a href="https://blog.csdn.net/qq_40845373/article/details/82015691"> Servlet三大域对象，Jsp四大域对象</a></p><p><a href="https://blog.csdn.net/codejas/article/details/79041006">Session 的钝化与活化</a></p><p><a href="https://baike.baidu.com/item/JAR/919533?fr=aladdin">JAR百度百科</a></p><p><a href="https://www.cnblogs.com/kingofjava/p/10761679.html">转发和重定向区别</a></p><p><strong>JAR包和WAR包的区别：</strong></p><p><strong>1.jar包的介绍</strong></p><p>JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。<strong>JavaSE程序可以打包成Jar包</strong>(J其实可以理解为Java了)。</p><p>JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装<strong>库</strong>、<strong>组件</strong>和<strong>插件程序</strong>，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。</p><p>简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。</p><p><strong>2.war包的介绍</strong></p><p>war是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\webapps\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。</p><p>war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。</p><p>简单来说，<strong>war包是JavaWeb程序打的包</strong>，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。</p><p><strong>3.区别：</strong>（<strong>WAR文件代表了一个Web应用程序，JAR是类的归档文件。</strong>）</p><p>如果一个Web应用程序的目录和文件非常多，那么将这个Web应用程序部署到另一台机器上，就不是很方便了，这时可以将Web应用程序打包成Web 归档（WAR）文件，这个过程和把Java类文件打包成JAR文件的过程类似。利用WAR文件，可以把Servlet类文件和相关的资源集中在一起进行发布。在这个过程中，Web应用程序就不是按照目录层次结构来进行部署了，而是把WAR文件作为部署单元来使用。</p><p>一个WAR文件就是一个Web应用程序，建立WAR文件，就是把整个Web应用程序（不包括Web应用程序层次结构的根目录）压缩起来，指定一个.war扩展名。</p><p>要注意的是，虽然WAR文件和JAR文件的文件格式是一样的，并且都是使用jar命令来创建，但就其应用来说，WAR文件和JAR文件是有根本区别的。JAR文件的目的是把<strong>类和相关的资源</strong>封装到压缩的<strong>归档文件</strong>中，而对于WAR文件来说，一个WAR文件代表了一个<strong>Web应用程序</strong>，它可以包含 Servlet、HTML页面、Java类、图像文件，以及组成Web应用程序的其他资源，而不仅仅是类的归档文件。</p><p>那么什么时候应该使用WAR文件呢？在开发阶段不适合使用WAR文件，因为在开发阶段，经常需要添加或删除Web应用程序的内容，更新 Servlet类文件，而每一次改动后，重新建立WAR文件将是一件浪费时间的事情。<strong>在产品发布阶段，使用WAR文件是比较合适的</strong>，因为在这个时候，几乎不需要再做什么改动了。</p><p>在开发阶段，我们通常将Servlet源文件放到Web应用程序目录的src子目录下，以便和Web资源文件区分。在建立WAR文件时，只需要将src目录从Web应用程序目录中移走，就可以打包了。</p><p><strong>4.部署war包到Tomcat</strong></p><p>1）. 我这里工作中一般是开发打war包给测试，比如说现在测试拿到一个war包，名字叫test.war。</p><p>2）. 打开Tomcat的安装路径 ，假设是“D:\Tomcat\apache-tomcat-7.0.68”，然后进入到 webapps文件夹中，把 test.war放到 webapps文件夹。</p><p>3）. 启动Tomcat。</p><p>如果不需要更改配置文件：到这一步就可以了。</p><p>在浏览器输入“http:localhost:tomcat_port&#x2F;test即可打开test项目的 index.jsp页面（port是自己的端口号）。如果test项目没有index.jsp页面，那就需要打开其他相应的页面。</p><p>如果需要更改配置文件：</p><p>4）. 关闭 Tomcat。</p><p>5）. 删除 test.war文件（如果在tomcat启动的状态下删去war包，解压好的文件夹也会被一并删除，所以需要在解压后停止tomcat， 然后删掉war包，这时再启动。这时项目文件夹就会被认为不是war解压而来。）。</p><p>6）. 由于刚刚启动过Tomcat，Tomcat会自动解压缩test.war为 test文件夹。所以我们在webapps下面可以看到test文件夹。打开test文件夹更改配置文件即可。</p><p>7）. 更新完配置之后，启动Tomcat。</p><p>8）. 浏览器打开即可</p><p><strong>设置Classpath的目的：</strong>告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包，事实上JDK 5.0默认就会到当前工作目录(上面的.设置)，以及JDK的lib目录(这里假设是C:\Program Files\Java\jdk1.5.0_06\lib)中寻找Java程序。所以如果Java程序是在这两个目录中，则不必设置Classpath变量也可以找得到，将来如果Java程序不是放置在这两个目录时，则可以按上述设置Classpath</p><h4 id="servlet相关："><a href="#servlet相关：" class="headerlink" title="servlet相关："></a>servlet相关：</h4><p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，不用对 service() 方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可</p><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单（默认请求由doGet() 方法处理）</p><p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法</p><p><a href="https://www.cnblogs.com/Jeely/p/11284005.html">servlet和servlet-mapping的作用 </a></p><p>servlet和servlet-mapping都含有<servlet-name></servlet-name><br>主要原因是想通过servlet-name作为纽带，将servlet-class和url-pattern构成联系，从而使URL映射到类servlet-class所指定的类中</p><p>Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的 Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在构造函数自动装配模式下，spring容器通过最高参数化的构造函数注入依赖项--&gt;</span><br><span class="hljs-comment">&lt;!--如果一个类中的3个构造函数，零参数，一个参数和两个参数，然后通过调用两个参数构造函数执行注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.sssit.B&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.sssit.A&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;constructor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/item/cookie/1119?fr=aladdin">cookie</a></p><p><a href="https://www.jianshu.com/p/896f1c47e34d">Session的销毁方式到底有哪些？</a></p><p><a href="https://blog.csdn.net/weixin_44502804/article/details/93139550">拦截器与过滤器的区别_</a></p><p><a href="https://www.cnblogs.com/zhangguangju/p/7027904.html">Idea–Tomcate配置中的On Upate Action 与 On Frame Deactivation </a></p><p><a href="https://blog.csdn.net/linghuainian/article/details/82226416"> idea 中Update resources和Update classes and resources、Redeploy的区别和应用场景_</a></p><p><a href="https://blog.csdn.net/qzw752890913/article/details/121777958"> 拦截器的配置_</a></p><p><a href="https://blog.csdn.net/kelly921011/article/details/86558335"> Web项目的WEB-INF目录使用说明_</a></p><p>springboot可以利用相关类的配置完成热部署，控制加载那些有变化的类来实现热部署</p><p>对jsp的相关解析<a href="https://zhuanlan.zhihu.com/p/42343690">浅谈JSP</a></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">在yaml中<br><span class="hljs-meta">#  单引号会将 \n作为字符串输出   双引号会将\n 作为换行输出</span><br><span class="hljs-meta">#  双引号不会转义，单引号会转义</span><br></code></pre></td></tr></table></figure><p><strong>Classpath</strong>：设置的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包</p><p><strong>@ComponentScan</strong>：主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中。</p><p><strong>@Controller和@RestController的区别：</strong></p><ul><li>@RestController修饰的类会将 return后面的内容字符串的形式返回到@Requestmapping的页面</li><li>@Controller修饰的类会将return的字符串配合视图解析器InternalResourceViewResolver添加上前缀和后缀。跳转到对应的html页面</li><li>@Controller和@ResponseBody配合作用和@RestController一样</li></ul><p>springboot实现了一套默认的配置，用户在不进行设定的前提下就默认使用这一配置，如果用户想要修改对应配置，只需要进行创建对应properties文件即可</p><p><strong>前端无法直接访问到后端的文件所以使用静态资源映射来使得其能够访问到后台数据</strong></p><ul><li><pre><code class="java">@Slf4j@Configurationpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;    /**     * 设置静态资源映射     * 为了使得resources下的文件能够直接被访问到故创建一个配置类来指定对应的静态资源映射     */    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        log.info(&quot;开始进行静态资源映射...&quot;);        // 将前面这个路径映射为后面的路径查询资源        registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:/backend/&quot;);        registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:/front/&quot;);    &#125;</code></pre></li></ul><p><strong>句柄：</strong></p><ul><li><p>句柄是Windows系统中对象或实例的标识，这些对象包括模块、应用程序实例、窗口、控制、位图、GDI对象、资源、文件等</p></li><li><p>从数据类型上来看，它只是一个16位的无符号整数。应用程序总是通过调用Windows API获得一个句柄，之后其他 Windows函数就可以使用该句柄，以引用和操作相应的内核对象。句柄可以像指针那样置空，那样句柄就没有任何意义，不代表任何内核对象</p></li><li><p>句柄在 Windows编程中是一个很重要的概念，在 Windows程序中并不是用物理地址来标识一个内存块、文件、任务或动态装入模块的。相反地，Windows API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作 </p></li><li><p>句柄是一个标识符，是用来标识对象或者项目的。从数据类型上来看它只是一个16位的无符号整数。应用程序几乎总是通过调用一个Windows函数来获得一个句柄，之后其他的Windows函数就可以使用该句柄，以引用相应的对象。在 Windows编程中会用到大量的句柄</p></li><li><p>使用句柄的好处</p><ul><li>我们可以在实现中用尺寸大小固定的（constant-sized）对象来表示尺寸大小不定的（variable-sized）值</li><li>我们可以在实现中用运行时绑定（run-time bounding）而不是编译时（compile-timebounding）绑定的方式来处理对象 </li><li>对于实现的改变通常只会引起一次重新链接，而不是重新编译 </li><li>我们可以对他人隐藏对象的实现</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/06/Docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker安装Redis流程："><a href="#Docker安装Redis流程：" class="headerlink" title="Docker安装Redis流程："></a>Docker安装Redis流程：</h2><ul><li><p>创建Redis镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name myredis -p 6379:6379 -d redis redis-server --appendonly yes<br></code></pre></td></tr></table></figure></li><li><p>进入Redis容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it myredis bash <br>redis-cli 进入对应的客户端<br>docker exec -it myredis  redis-cli 也可以直接使用这种方式进入Redis容器的客户端<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>构建RESTful API与单元测试：</strong></p><ul><li><p><code>@Controller</code>：修饰class，用来创建处理http请求的对象</p></li><li><p><code>@RestController</code>：Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式</p></li><li><p><code>@RequestMapping</code>：配置url映射。现在更多的也会直接用以Http Method直接关联的映射注解来定义，比如：<code>GetMapping</code>、<code>PostMapping</code>、<code>DeleteMapping</code>、<code>PutMapping</code>等</p></li><li><p>使用<code>@Data</code>注解可以实现在编译器自动添加set和get函数的效果，该注释由lombok提供</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@PathVariable可以用来映射URL中的占位符到目标方法的参数中</span><br><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;testPathVariable:&quot;</span>+id);<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br> <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>        <span class="hljs-comment">// 可以进行绑定，只要重名即可</span><br>        <span class="hljs-comment">// url中的id可通过@PathVariable绑定到函数的参数中</span><br>        <span class="hljs-keyword">return</span> users.get(id);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>REST风格:</strong></p><ul><li>REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用</li><li>资源（<strong>Resources</strong>）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 <strong>URI</strong> 。要获取这个资源，访问它的URI就可以，因此 <strong>URI</strong> 即为每一个资源的独一无二的识别符。</li><li>表现层（<strong>Representation</strong>）：把资源具体呈现出来的形式，叫做它的表现层（<strong>Representation</strong>）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</li><li>状态转化（<strong>State Transfer</strong>）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生<strong>“</strong>状态转化<strong>”</strong>（<strong>State Transfer</strong>）。而这种转化是建立在表现层之上的，所以就是 <strong>“</strong>表现层状态转化<strong>”</strong>。具体说，就是 <strong>HTTP</strong> 协议里面，四个表示操作方式的动词：<strong>GET</strong>、<strong>POST</strong>、<strong>PUT</strong>、<strong>DELETE</strong>。它们分别对应四种基本操作：<strong>GET</strong> 用来获取资源，<strong>POST</strong> 用来新建资源，<strong>PUT</strong> 用来更新资源，<strong>DELETE</strong> 用来删除资源。</li></ul><p><strong>连接数据库：</strong></p><ul><li><p>以MySQL数据库为例，先引入MySQL连接的依赖包，在<code>pom.xml</code>中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>src/main/resources/application.properties</code>中配置数据源信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">dbuser</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">dbpass</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment">#因为Spring Boot 2.1.x默认使用了MySQL 8.0的驱动，所以这里采用com.mysql.cj.jdbc.Driver，而不是老的com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>在数据库连接的基础上还要使用数据源的原因：</strong></p><ul><li>封装关于数据库访问的各种参数，实现统一管理</li><li>通过对数据库的连接池管理，节省开销并提高效率</li></ul><p><strong>原生组件的导入：</strong></p><ul><li><p>Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/my&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;66666&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)</span> <span class="hljs-comment">//my</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        log.info(<span class="hljs-string">&quot;MyFilter初始化完成&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        log.info(<span class="hljs-string">&quot;MyFilter工作&quot;</span>);<br>        chain.doFilter(request,response);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;MyFilter销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Listener</p></li><li><p>使用配置类RegistrationBean进行配置</p></li></ul><p>切换服务器：</p><ul><li><p>在默认的场景中排除原来的服务器启动器</p></li><li><p>新增新的服务器启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>修改版本号可以直接在项目的pom.xml的上面集中修改版本号</p><p>可以将简单的sql语句写在注释版本上，而复杂的查询语句存放在对应的配置文件中</p><p><strong>@RunWith的作用：</strong></p><p>@RunWith就是一个运行器</p><p>@RunWith(JUnit4.class)就是指用JUnit4来运行</p><p>@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境</p><p>@RunWith(Suite.class)的话就是一套测试集合，</p><p> @RunWith(SpringJUnit4ClassRunner.class)使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。其他的想创建spring容器的话，就得子啊web.xml配置classloder。 注解了@RunWith就可以直接使用spring容器，直接使用@Test注解，不用启动spring容器</p><p><a href="https://blog.csdn.net/qq_42383787/article/details/87938070"> 对于常用@RequestParam等注解的使用</a></p><p><a href="https://blog.csdn.net/zhoucheng05_13/article/details/54603985"> Spring表达式基础   Spring Expression Language</a></p><p><strong>@Autowired的使用：</strong></p><ul><li><p>使用在字段上表示这个字段被自动装填</p></li><li><p>使用在方法上表示这个方法的参数被自动装填</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Autowired默认使用byType进行装配</span><br><span class="hljs-comment">//如果想按照byName则需要使用@Qualifier注解</span><br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;user1&quot;)</span><br><span class="hljs-keyword">private</span> IUser user;<br></code></pre></td></tr></table></figure></li></ul><p><strong>@Slf4j的使用：</strong></p><p>@Slf4j是用作日志输出的，一般会在项目每个类的开头加入该注解，该注解相当于在对应类中添加下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(当前类名.class);<br></code></pre></td></tr></table></figure><p>添加了该注释之后，就可以在代码中直接饮用log.info( ) 打印日志了</p><p><strong>MyBatis的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以将对应的自定义的Mapper继承BaseMapper来获得最基本的CRUD功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br><br>&#125;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;user_tbl&quot;)</span><span class="hljs-comment">//通过这个属性来将实体类和对应的数据库表对应</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有属性都应该在数据库中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(exist = false)</span>  <span class="hljs-comment">//标注当前属性表中不存在</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br><br>    <span class="hljs-comment">//以下是数据库字段</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>springboot+MyBatis整合开发：</strong></p><p>使用maven导入不成功注意使用install命令进行处理</p><p>使用mybatis-Plus可以直接通过继承BaseMapper，IService，ServiceImpl等现成的类来实现简化开发的作用</p><p>前端编写的console.log()是在前端浏览器的控制台输出的</p><p>MybatisPlus可以对公共字段进行自动填充，即在插入或者更新的过程中为指定的字段赋予指定的值，使用其的好处在于能够统一的对这些字段进行处理，避免了重复代码操作，下面是具体的实现步骤</p><ul><li>首先在实体类的属性上增加@TableField注解，指定自动填充的策略</li><li>按照框架要求编写元数据的对象处理器，在此类中统一为公共字段进行赋值，此类需要实现MetaObjectHandler接口</li></ul><p>当需要进行测试的时候可以在test下进行创建代码进行测试</p><p><a href="https://blog.csdn.net/fangaoxin/article/details/6952954?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-6952954-blog-92760353.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-6952954-blog-92760353.pc_relevant_default&utm_relevant_index=2">超级详细的！ Cookie&#x2F;Session机制详解_</a></p><p><strong>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong></p><p><strong>Cookie</strong></p><ul><li><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容</p></li><li><p>不同的浏览器采用不同的方式保存Cookie，并且不同的服务器端会对其进行加密操作</p></li><li><p>Java中把Cookie封装成了javax.servlet.http.Cookie类。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。通过request.getCookie()获取客户端提交的所有Cookie（以Cookie[]数组形式返回），通过response.addCookie(Cookiecookie)向客户端设置Cookie</p></li><li><p>Cookie对象使用key-value属性对的形式保存用户状态，一个Cookie对象保存一个属性对，一个request或者response同时使用多个Cookie</p></li><li><p>Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p><p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p><p>需要注意的是，虽然网站images.google.com与网站<a href="http://www.google.com同属于google,但是域名不一样,二者同样不能互相操作彼此的cookie./">www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。</a></p><p>注意：用户登录网站<a href="http://www.google.com之后会发现访问images.google.com时登录信息仍然有效,而普通的cookie是做不到的.这是因为google做了特殊处理.本章后面也会对cookie做类似的处理/">www.google.com之后会发现访问images.google.com时登录信息仍然有效，而普通的Cookie是做不到的。这是因为Google做了特殊处理。本章后面也会对Cookie做类似的处理</a></p></li><li><p>Cookie不仅可以使用ASCII字符与Unicode字符，还可以使用二进制数据。例如在Cookie中使用数字证书，提供安全度</p></li><li><p>Cookie实现自动登录</p><ul><li><p>如果用户是在自己家的电脑上上网，登录时就可以记住他的登录信息，下次访问时不需要再次登录，直接访问即可。实现方法是把登录信息如账号、密码等保存在Cookie中，并控制Cookie的有效期，下次访问时再验证Cookie中的登录信息即可。</p><p>保存登录信息有多种方案。最直接的是把用户名与密码都保持到Cookie中，下次访问时检查Cookie中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到Cookie中。</p><p>还有一种方案是把密码加密后保存到Cookie中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到Cookie与数据库中，到时只验证用户名与登录时间戳就可以了。</p><p>这几种方案验证账号时都要查询数据库。</p><p>本例将采用另一种方案，只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。实现方式是把账号按照一定的规则加密后，连同账号一块保存到Cookie中。下次访问时只需要判断账号的加密规则是否正确即可。本例把账号保存到名为account的Cookie中，把账号连同密钥用MD1算法加密后保存到名为ssid的Cookie中。验证时验证Cookie中的账号与密钥加密后是否与Cookie中的ssid相等</p></li></ul></li><li></li></ul><p><strong>Session：</strong></p><ul><li><p>Session即用于记录一系列状态</p></li><li><p>Session对应的类为javax.servlet.http.HttpSession类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象里。Session对象是在客户端第一次请求服务器的时候创建的。Session也是一种key-value的属性对</p></li><li><p>Session与cookie功能效果相同，Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端，即Cookie通过在客户端记录信息确定用户身份<strong>，</strong>Session通过在服务器端记录信息确定用户身份</p></li><li><p>Session的创建，当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session</p></li><li><p>Session的意义在于，HTTP协议是无状态性的，取完当前浏览器的内容，然后关闭浏览器后，链接就断开了，而没有任何机制去记录取出后的信息。而当需要访问同一个网站的另外一个页面时(就好比如在第一个页面选择购买的商品后，跳转到第二个页面去进行付款)这个时候取出来的信息，就读不出来了。所以必须要有一种机制让页面知道原来页面的session内容</p></li><li><p>如何知道浏览器和这个服务器中的session是一一对应的呢？又如何保证不会去访问其它的session呢？</p><ul><li>原理解答：就是当访问一个页面的时候给浏览器创建一个独一无二的号码，也给同时创建的session赋予同样的号码。这样就可以在打开同一个网站的第二个页面时获取到第一个页面中session保留下来的对应信息（理解：当访问第二个页面时将号码同时传递到第二个页面。找到对应的session。）。这个号码也叫sessionID，session的ID号码，session的独一无二号码</li></ul></li><li><p>session的两种实现方式（也就是传递方式）：1、通过cookies实现  2、通过URL重写来实现</p><ul><li>第一种方式：就是把session的id 放在cookie里面（为什么是使用cookies存放呢，因为cookie有临时的，也有定时的，临时的就是当前浏览器什么时候关掉即消失，也就是说session本来就是当浏览器关闭即消失的，所以可以用临时的cookie存放。保存再cookie里的sessionID一定不会重复，因为是独一无二的。），当允许浏览器使用cookie的时候，session就会依赖于cookies，当浏览器不支持cookie后，则通过第二种方式获取session内存中的数据资源</li><li>第二种方式的理解：在客户端不支持cookie的情况下使用。为了以防万一，也可以同时使用<ul><li>如果不支持cookie，必须自己编程使用URL重写的方式实现</li><li>重写URL：通过response.encodeURL()方法</li></ul></li></ul></li><li><p>encodeURL()的两个作用</p><ul><li>第一个作用：转码（说明：转中文的编码，或者一些其他特殊的编码。就好比如网页的链接中存在中文字符，就会转换成为一些百分号或者其他的符号代替。）</li><li>第二个作用：URL后面加入sessionID，当不支持cookie的时候，可以使用encodeURL()方法，encodeUTL()后面跟上sessionID，这样的话，在禁用cookie的浏览器中同时也可以使用session了。但是需要自己编程，只要链接支持，想用session就必须加上encodeURL()</li><li>提示：若想程序中永远支持session，那就必须加上encodeURL()，当别人禁用了cookie，一样可以使用session</li></ul></li><li><p>session有期限：</p><ul><li>当一个网站的第一个窗口关掉了，而没有继续接着访问第二个页面，就没有使用到session。那么session会在中断程序后立刻关闭session吗？这个时候session就需要给它保留的时间，当最近一次访问的时候开始计时，每刷新一次重写开始计时。当隔了这么久的时间，没有访问这个session后，对不起，要关闭这个session了。session有过期时间，session什么时候过期，要看配置，</li></ul></li><li><p>session能干什么：</p><ul><li>session就是服务器里面的一块内存，内存里面能放任何东西，只要是名值对就可以了</li><li>session里面的名字永远都是String类型</li></ul></li><li><p>当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。</p><p>提示：Session的使用比Cookie方便，但是过多的Session存储在服务器内存中，会对服务器造成压力</p></li><li><p>Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</p><p>Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session</p><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次</p><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了</p></li><li><p>虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。</p><p>该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p><p>因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的Cookie，因此会共享一个Session。</p><p>注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。</p><p>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写</p></li></ul><p><strong>Maven常见操作：</strong></p><p>1.clean (清理)</p><p>用于清除之前构建生成的所有文件</p><p>其中具体为清除了Target目录中的所有文件，包括该目录</p><p>i.e：删除了install生成的所有文件</p><p>2.validate(验证)</p><p>用于验证项目是否正确，并且其中有必要信息是否都可用</p><p>3.compile(编译源代码)</p><p>编译项目的源代码，主要是java文件</p><p>一般是编译scr&#x2F;main&#x2F;java或是scr&#x2F;test&#x2F;java里面的文件</p><p>4.test (运行测试)</p><p>用合适的测试框架来进行测试，测试compile中编译出来的代码</p><p>测试的东西一般不加包和部署</p><p>5.package(打包)</p><p>(生成target目录，编译、测试代码，生成测试报告，生成jar&#x2F;war文件<br>获取compile中编译好的代码并将其打包成可分类的格式，i.e:jar包或者 war包</p><p>6.vertify(验证)</p><p>这步是用来验证test</p><p>检查test的结果是否满足标准</p><p>7.install(安装至本地仓库)(在本地Repository中安装jar)</p><p>将软件包安装到本地存储库中</p><p>确保本地其他项目可能需要使用他（eg:装了core才能用oms）</p><p>8.site</p><p>生成项目的站点文档</p><p>9.deploy (复制到远程仓库)(上传到私服)</p><p>复制最终的包至远程仓库<br>共享给其它开发人员和项目</p><p><strong>axios的使用：</strong></p><ul><li><p>axios是目前最流行的ajax封装库之一，用于很方便地实现ajax请求的发送</p></li><li><p>axios支持的功能：</p><ul><li>从浏览器发出 XMLHttpRequests请求。</li><li>从 node.js 发出 http 请求。</li><li>支持 Promise API。</li><li>能拦截请求和响应。</li><li>能转换请求和响应数据。</li><li>取消请求。</li><li>实现JSON数据的自动转换。</li><li>客户端支持防止 XSRF攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//配置对象常用的配置项：</span><br><br>&#123;<br>  <span class="hljs-comment">// 路径url</span><br>  url: <span class="hljs-string">&#x27;/user&#x27;</span>,<br><br>  <span class="hljs-comment">// 请求方法，默认get</span><br>  method: <span class="hljs-string">&#x27;get&#x27;</span>, <br><br>  <span class="hljs-comment">//基础url，最终请求的url是 baseURL+url拼接，所以再全局设置默认，可以使得发送请求时的url变得简洁</span><br>  baseURL: <span class="hljs-string">&#x27;https://some-domain.com/api/&#x27;</span>,<br><br>  <span class="hljs-comment">//设置请求头</span><br>  headers: &#123;<span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>&#125;,<br><br>  <span class="hljs-comment">//设置请求url的query参数，可以使得url简洁。</span><br>  <span class="hljs-comment">//比如url是https://some-domain.com/api/user  然后params如下设置，那么最终的url是：</span><br>  <span class="hljs-comment">//https://some-domain.com/api/user?ID=12345&amp;name=Jack</span><br>  params: &#123;<br>    ID: <span class="hljs-number">12345</span>,<br>    name:<span class="hljs-string">&quot;Jack&quot;</span><br>  &#125;,<br><br><br> <span class="hljs-comment">//设置请求体</span><br>  data: &#123;<br>    firstName: <span class="hljs-string">&#x27;Fred&#x27;</span><br>  &#125;,<br>  <br>  <span class="hljs-comment">//设置请求的另外一种格式，不过这个是直接设置字符串的</span><br>  data: <span class="hljs-string">&#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;</span>,<br><br> <span class="hljs-comment">//请求超时，单位毫秒，默认0，不超时。</span><br>  timeout: <span class="hljs-number">1000</span>,<br><br>  <span class="hljs-comment">//响应数据类型，默认json</span><br>  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <br><br>  <span class="hljs-comment">//响应数据的编码规则，默认utf-8</span><br>  responseEncoding: <span class="hljs-string">&#x27;utf8&#x27;</span>,<br><br><br><span class="hljs-comment">//响应体的最大长度 </span><br>  maxContentLength: <span class="hljs-number">2000</span>,<br><br>  <span class="hljs-comment">// 请求体的最大长度</span><br>  maxBodyLength: <span class="hljs-number">2000</span>,<br><br>  <span class="hljs-comment">//设置响应状态码为多少时是成功，调用resolve，否则调用reject失败</span><br>  <span class="hljs-comment">//默认是大于等于200，小于300</span><br>  validateStatus: function (status) &#123;<br>    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <br>  &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--可以设置全局默认配置，是为了避免多种重复配置在不同请求中重复，比如baseURL、timeout等，这里设置baseURL--&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>默认配置<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span>=<span class="hljs-string">&quot;http://localhost:3000&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//因为上面配置了baseURL，所以我们之后的请求只需要配置url不用像之前那样的全路径</span></span><br><span class="language-javascript">        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/posts/1&quot;</span>)</span><br><span class="language-javascript">       .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;</span><br><span class="language-javascript">           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);</span><br><span class="language-javascript">       &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html">请求拦截器：用于拦截请求，自定义做一个逻辑后再把请求发送，可以用于配置公用的逻辑，就不用每个请求都配一遍。<br>响应拦截器：用于拦截响应，做一些处理后再出发响应回调。<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>axios拦截器<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//这个是设置请求拦截器的api，传入两个回调，第一个成功回调，第二个失败回调。</span></span><br><span class="language-javascript">        axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器1调用成功&quot;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> config;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器1调用失败&quot;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        )</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//这个是设置响应拦截器的api，第一个成功回调，第二个失败回调</span></span><br><span class="language-javascript">        axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应拦截器1调用成功&quot;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> response;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应拦截器1调用失败&quot;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        )</span><br><span class="language-javascript"></span><br><span class="language-javascript">        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3000/posts/1&quot;</span>)</span><br><span class="language-javascript">        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求回调成功&quot;</span>);</span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求回调失败&quot;</span>);</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>注意idea在调试过程中对于数据库的改变是实时的</p><p>idea还可以先让其在调试模式下运行然后再增加断点</p><p>注意java有时忘了是大小写可能会写错</p><p>利用增强版的for循环遍历对象数组时，对象数组中的对象也会发生改变</p><p>springboot本身是支持put 和 delete 请求的，有时候抱不支持这类方法的错实际上需要添加注解参数</p><p>Win+R调出cmd，输入netstat -na，即可得到对应端口号信息</p><p><strong>cmd和PowerShell的区别：</strong></p><ul><li>PowerShell是跨平台的，cmd是Windows专用的</li><li>cmd是进入dos系统的命令，输入cmd进入的是dos系统，可以进行命令提示符操作</li><li>命令提示符窗口（cmd.exe）是Windows的“标配”组件，它可以实现用户与操作系统的直接交流，并负责用户输入的所有命令的解释和支持</li><li>powershell是系统工具，是对cmd（命令提示符）的扩展，其中多了很多操作，比如管道操作</li><li>PowerShell可以看作是cmd的升级版、补充版，但其背后的实现方式却有很大的不同，PowerShell基于面向对象的，更为易用</li><li>PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境PowerShell需要.NET环境的支持</li><li>PowerShell从Windows7开始已经内置于Windows操作系统</li><li>PowerShell有面向对象的管道</li><li>PowerShell能够调用.NET的很多功能</li></ul></li></ul><p><a href="https://blog.csdn.net/xinzhifu1/article/details/106356958/">过滤器 和 拦截器的 6个区别，</a></p><p><strong>Mybatis-plus可以通过setSql来设置相关的sql语句：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>        .update();<br></code></pre></td></tr></table></figure><p>系统变量和用户变量的区别：</p><ul><li>系统变量是针对于该电脑的所有用户适用的</li><li>用户变量是针对当前用户所使用的</li></ul><p><a href="https://www.zhihu.com/question/39356740/answer/1907479772">@Autowired和@Resource的区别是什么？</a></p><p>用户上传的图片可以放在专用的文件服务器上，也可以直接上传到前端服务器Nginx上</p><p>当使用Redis控制台进行添加数据时，记得控制语句结尾需要多一个空格来保证语句的执行</p><p><a href="https://blog.csdn.net/qq_42914528/article/details/123540207">分析 RestController 与 Controller 的区别</a></p><p><a href="https://blog.csdn.net/jiangyu1013/article/details/84397366"> @Transactional 详解</a></p><p><strong>@RequestBody和@RequestParam</strong></p><ul><li><p>@RequestBody</p><ul><li><p>注解@RequestBody接收的参数是来自requestBody中，即请求体</p></li><li><p>一个请求只能有一个@RequestBody</p></li><li><p>@RequestBody接受的参数是来自request body中也就是请求体</p></li><li><p>RequestBody也可以传递List&lt;&gt;类型的值，只要传递的对应json数据是合法的即可</p></li></ul></li><li><p>@RequestParam</p><ul><li>注解@RequestParam接收的参数是来自requestHeader中，即请求头  通常用于GET请求</li><li>不加@RequestParam前端的参数名需要和后端控制器的变量名保持一致才能生效，即不加该注解也能生效，只是参数和传递的值必须相同，但是使用@RequestParam可以自定义参数<ul><li>不加@RequestParam参数为非必传，加@RequestParam写法参数为必传。但@RequestParam可以通过@RequestParam(required &#x3D; false)设置为非必传</li><li>@RequestParam可以通过@RequestParam(“userId”)或者@RequestParam(value &#x3D; “userId”)指定传入的参数名</li></ul></li><li>语法：@RequestParam(value&#x3D;”参数名”,required&#x3D;”true&#x2F;false”,defaultValue&#x3D;” ”)<ul><li>value：参数名</li><li>required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错，反之改为false即不会报错</li><li>defaultValue：默认参数值，如果设置了该值，required&#x3D;true将失效，自动为false,如果没有传该参数，就使用默认值</li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_43842189/article/details/112386012">mybatisplus wrapper 详细使用</a></p><p>requirepass abc1234</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>凤凰架构理解：</strong></p><ul><li>生命系统之所以可靠的本质，恰是因为它可以使用不可靠的部件来完成遗传迭代。这其中的关键点便是承认细胞等这些零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中一定会有其后代的出现，重新代替该零部件的作用，以维持系统的整体稳定。在这个微生态里，每一个部件都可以看作一只不死鸟（Phoenix），它会老迈，而之后又能涅槃重生</li><li>流水不腐，有老朽，有消亡，有重生，有更迭才是生态运行的合理规律。请设想一下，如果你的系统中每个部件都符合“Phoenix”的特性，哪怕其中某些部件采用了由极不靠谱的人员所开发的极不靠谱程序代码，哪怕存有严重的内存泄漏问题，最多只能服务三分钟就一定会崩溃。而即便这样，只要在整体架构设计有恰当的、自动化的错误熔断、服务淘汰和重建的机制，在系统外部来观察，整体上仍然有可能表现出稳定和健壮的服务能力</li></ul><p><strong>C&#x2F;S，B&#x2F;S，MVC概念解析：</strong></p><ul><li>cs是传统的客户端&#x2F;服务器模式，本地一个客户端软件+服务器，不同的服务提供商需要提供一个客户端如啊你就按，需要安装后才能使用</li><li>bs是浏览器&#x2F;服务器模式，这时用网页来展示服务器的数据，客户端使用浏览器作为数据的载体，变得更加轻量和通用</li><li>mvc是视图与数据分离，这个是数据流渲染的概念，与其相似的数据流渲染概念还有mvvm等</li></ul><p><strong>微服务的框架种类：</strong></p><ul><li>服务间远程调用问题：RMI（Sun&#x2F;Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST等</li><li>服务发现问题：Eureka（Netflix）、Consul（HashiCorp）、Nacos（阿里巴巴）、ZooKeeper（Apache）、Etcd（CoreOS）、CoreDNS（CNCF）等</li></ul><p><strong>微服务出现的问题实际上都在硬件方面有相应的解决方式：</strong></p><ul><li>系统需要伸缩扩容：通常会购买新的服务器，部署若干副本实例来分担压力；</li><li>系统需要解决负载均衡问题：通常会布置负载均衡器，选择恰当的均衡算法来分流</li><li>需要解决传输安全问题：通常会布置 TLS 传输链路，配置好 CA 证书以保证通信不被窃听篡改；</li><li>需要解决服务发现问题：通常会设置 DNS 服务器，让服务访问依赖稳定的记录名而不是易变的 IP 地址，等等</li></ul><p><strong>未来发展方向：</strong></p><p>笔者相信，未来 Kubernetes 将会成为服务器端标准的运行环境，如同现在 Linux 系统；服务网格将会成为微服务之间通信交互的主流模式，把“选择什么通信协议”、“怎样调度流量”、“如何认证授权”之类的技术问题隔离于程序代码之外，取代今天 Spring Cloud 全家桶中大部分组件的功能，微服务只需要考虑业务本身的逻辑，这才是最理想的Smart Endpoints解决方案</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/springCloud/"/>
    <url>/2023/03/06/springCloud/</url>
    
    <content type="html"><![CDATA[<p><strong>单体架构：</strong>将业务的所有功能都集中在一个项目中开发，打包成一个包部署</p><ul><li>优点：架构简单，部署成本低</li><li>缺点：耦合度高</li></ul><p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称之为一个服务</p><ul><li>优点：降低服务耦合，</li></ul><p>springCloud的服务远程调用使用的协议是基于http协议的Feign，其进行了一定封装</p><p>spring充分利用了springboot的自动装配功能将许多的微服务进行自动装配，所以注意springcloud需要和对应的springboot版本匹配</p><p>服务的提供者和消费者是相对于请求服务而言的，对于链条状的服务请求链的跨模块分析是没有意义的</p><p>配置Eureka对应的客户端和用户端只要在对应的pom.xml文件中增加对应依赖启动器即可</p><p>查看原码不理解某个类时可以先观察其父类，因为子类一定是父类的增强，所以只要理解父类，就能理解其一部分</p><p>具体使用的负载均衡策略和使用的对应服务器可以在日志中查看</p><p><strong>修改服务器查询规则：</strong></p><ul><li>在对应Application.java中添加对应返回为IRule类的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#相对于在对应Application.java中添加对应返回为IRule类的方法，配置文件能够更好的适配粒度更小的划分</span><br><span class="hljs-attr">userservice:</span>  <br>     <span class="hljs-attr">ribbon:</span>   <br>       <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span>   <span class="hljs-comment">#负载均衡规则 </span><br></code></pre></td></tr></table></figure><p>由于Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长，故可以在配置文件中设置饥饿加载</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>   <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment"># 开启饥饿加载 </span><br>     <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 指定对userservice这个服务饥饿加载</span><br></code></pre></td></tr></table></figure><p>在文件夹中打开控制台窗口只需要在对应的地址栏中输入cmd即可</p><p>在nacos对应的属性中增加cluster-name: localname 即可将对应的服务或用户添加到名为localname 的集群中</p><p><strong>nacos的访问特点：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span>  <br>     <span class="hljs-attr">ribbon:</span>   <br>       <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <br>       <span class="hljs-comment"># NacosRule特点在于优先使用集群中的服务，在对应集群中的服务中在使用随机选取</span><br>       <span class="hljs-comment"># 如果当前集群内没有能够使用的服务，就进行跨集群调用服务</span><br></code></pre></td></tr></table></figure><p>可以在nacos的浏览器端通过设置对应的权重来修改访问的可能性</p><p><strong>nacos的临时实例和非临时实例：</strong></p><ul><li>临时实例采用心跳检测，当其服务不正常后，注册中心会直接将其去除</li><li>非临时实例采用nacos注册中心主动询问，并且如果不能使用也不会将其去除，但是注意nacos注册中心主动询问会对服务器造成压力，所以建议使用临时实例</li></ul><p><strong>Feign进行性能优化：</strong></p><ul><li>使用连接池代替默认的URLConnection</li><li>设置日志级别最好使用basic或none来减少损耗</li></ul><p><strong>Feign的两种实现方式：</strong></p><ul><li>方式一（继承）：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。<ul><li>缺点在于：1、服务紧耦合 2、父接口参数列表中的映射不会被继承</li></ul></li><li>方式二（抽取）：将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用<ul><li>缺点在于：feign-api提供了现成的UserClient来供服务调用，并且提供了默认的配置等信息，但是有时服务只需要使用很小的一部分信息，而传递了过多的数据量造成了浪费</li></ul></li></ul><p>有时spring在编译时没有报错，但是在运行后显示没有对应的类可供注入，在这种情况下，可能是有对应的类，但是没有开启spring扫描组件，spring容器中没有对应的实体类，导致无法完成注入</p><p><strong>Gateway路由断言工厂：</strong></p><ul><li>PredicateFactory作用：读取用户所配置的断言规则，然后将其解析为对应的判断条件，当用户发送请求时对请求进行判断</li><li>Path&#x3D;&#x2F;user&#x2F;**：表示路径为&#x2F;user开头的就是符合条件的请求</li></ul><p><strong>GatewayFilter：</strong></p><ul><li>Spring提供了31种不同的路由过滤器工厂GatewayFilterFactory</li><li>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理（请求和响应都能处理）</li><li>如果想要对所有路由统一进行操作只需要配置默认过滤器default-filters即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id,</span><br><span class="hljs-params">                      <span class="hljs-meta">@RequestHeader(value = &quot;Truth&quot;, required = false)</span> String truth)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;truth: &quot;</span> + truth);<br>    <span class="hljs-keyword">return</span> userService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>会自动从下面的配置文件中获取对应的Truth数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos:8848</span> <span class="hljs-comment"># nacos地址</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由标示，必须唯一</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址1</span><br>        <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，判断请求是否符合规则</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 路径断言，判断路径是否是以/user开头，如果是则符合</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://orderservice</span><br>        <span class="hljs-attr">predicates:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br>      <span class="hljs-comment">#     filters:</span><br>      <span class="hljs-comment">#   - AddRequestHeader=Truth,Itcast is freaking awesome! # 这样的设置是对满足断言条件的路由请求生效</span><br>    <span class="hljs-attr">default-filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 这样的设置是对所有的路由请求都生效</span><br>      <br></code></pre></td></tr></table></figure><p><strong>对权限登录的过滤器配置示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        MultiValueMap&lt;String, String&gt; params = request.getQueryParams();<br>        <span class="hljs-comment">// 2.获取参数中的 authorization 参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.判断参数值是否等于 admin</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 4.是，放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange); <span class="hljs-comment">//继续调用过滤器链</span><br>        &#125;<br>       <br>        <span class="hljs-comment">// 5.否，拦截</span><br>        <span class="hljs-comment">// 5.1.设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>        <span class="hljs-comment">//这里的HttpStatus.UNAUTHORIZED是枚举类型，返回为401(即未登录时对应的状态码)</span><br>  <br>        <br>        <span class="hljs-comment">// 5.2.拦截请求</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚拟机快照备份：</strong></p><ul><li>磁盘快照的基本概念与磁带备份等机制有非常大的不同。在建立磁盘快照时，并不需要复制数据本身，它所作的只是通知LX Series NAS服务器将有数据的磁盘区块全部保留起来，不被覆写。这个通知动作只需花费极短的时间。接下来的档案修改或任何新增、删除动作，均不会覆写原本数据所在的磁盘区块，而是将修改部分写入其它可用的磁盘区块中。所以可以说，数据复制，或者说数据备份，是在平常档案存取时就做好了，而且对效能影响极低。LX Series NAS档案系统内部会建立一份数据结构，纪录磁盘快照备份及作用中档案系统所使用到的磁盘区块及指针，让使用者可以同时存取到主要档案系统及过去的磁盘快照版本</li></ul><p><strong>微服务之间的依赖关系：</strong></p><ul><li>如果两个微服务都需要依赖同一个包，则可以将这两个微服务所共同依赖的代码写到对应父工程中的pom.xml文件中，而不需要再次写到对应微服务各自的pom.xml中</li></ul><p><strong>域名相关知识：</strong></p><p>域名cn和com与org最大区别是，在我国，cn和com均可以申请备案，而org无法申请域名备案</p><p>域名cn，国家顶级域名，表示中国国家域名，是国别域名</p><p>域名com，源自英文单词“commercial”，是全球最热门的域名后缀，是通用顶级域名后缀</p><p>域名org，为organization（组织）缩写，与com、net等一样，是通用顶级域名后缀</p><p><strong>aptitude：</strong></p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具，与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净</p><p><strong>Bootstrap：</strong></p><p>Bootstrap是美国 Twitter 公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成</p><p><strong>过滤器链的产生：</strong></p><ul><li>在形成过滤器链之前，由于不同的过滤器的类型不同，但是由于框架提供了GatewayFilterAdapter类，该类通过传递的参数GlobalFilter将其转换为GatewayFilter类</li><li>通过GatewayFilterAdapter类，可以将所有的GlobalFilter都适配成GatewayFilter类</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul><p><strong>Redis的使用：</strong></p><ul><li>Redis是一个基于内存的key-value结构数据库其特点为<ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品，资讯，新闻）</li><li>企业应用广泛</li></ul></li></ul><p><strong>Docker的使用：</strong></p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像，由于其将所有的配置都打包在了一起，所以在函数调用或者读取配置时只需要读取自身所在容器中的数据即可，甚至连系统级的函数调用也进行了封装，所以docker打包的镜像可以在任意Linux内核的系统中运行</li><li>Docker中的镜像的读写数据是存储在对应容器中的，然后通过拷贝复制到对应Docker运行的操作系统上</li><li>docker 调用run命令后返回的是唯一的指定容器的ID</li><li>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li>docker容器中的文件管理结构时类似于Linux的，但是docker容器中的函数文件等是按需加载的，只会将调用相关的函数文件等打包放入容器中，按需进行存储</li><li>exec命令可以进入容器修改文件，但是在容器内修改文件是不推荐的，原因如下<ul><li>由于容器只会存储调用所需的文件，所以常用的修改文件命令是无法使用或者不便使用的</li><li>对容器的修改不便于记录，容易对容器本身产生影响</li></ul></li><li>数据卷用于控制容器中的数据和宿主机上的数据的中间的桥梁，保证两者其中只要有一者修改，另一方随之进行改变</li><li>在DockerCompose底层进行了一系列配置，使得能够在底层通过调用名进行配置</li><li>在出现错误时，注意使用 docker logs 容器名 来查看日志进行检查</li><li>解压后对应的tar包和镜像之间是不关联的，所以删除对应的tar包对其镜像本身不影响</li></ul><p><strong>Git的使用：</strong></p><ul><li><p>在idea使用git的本质实际上还是在使用原本的git软件</p></li><li><p>由于在使用git时，并不是所有程序文件都需要纳入版本控制，比如idea自带的.idea和对应产生的target文件夹，所以要使用.gitignore来标注不需要进入版本控制的文件</p></li><li><p>idea对版本控制做了进一步简化，在commit的同时就已经将文件存放到了暂存区</p></li><li><p>在idea中使用文件的颜色对文件的状态进行管理</p><ul><li>黑色：表示没有发生改变，已经纳入了版本控制</li><li>红色：未加入版本控制</li><li>绿色：已经加入版本控制暂未提交</li><li>蓝色：加入，已提交，有改动</li><li>灰色：版本控制已忽略文件</li></ul></li></ul><p><strong>RabbitMQ使用：</strong></p><ul><li>RabbitMQ在设置过程中5672是消息传送的端口号，而15672是查看界面的UI端口号，注意进行区分</li></ul><p><strong>Elasticsearch的使用：</strong></p><ul><li><p>ESL语句实际就是根据RESTful风格发送到ES当中</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elm">&#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;weight&quot;</span>: <span class="hljs-number">52.1</span>,<br>    <span class="hljs-string">&quot;isMarried&quot;</span>: false,<br>    <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;黑马程序员Java讲师&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;zy@itcast.cn&quot;</span>,<br>    <span class="hljs-string">&quot;score&quot;</span>: [<span class="hljs-number">99.1</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">98.9</span>],  //<span class="hljs-string">&quot;在ES中不能使用数组，但是可以给一个数值定义多个值&quot;</span><br>    <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;云&quot;</span>,<br>        <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;赵&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在ES中不允许进行修改，可以先删除索引，再增加索引</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>首次适应和临近适应由于不需要对空闲区进行排序，所以就不需要进行排序所导致的算法开销</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/AJAX%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/AJAX%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>HTML是预定义语言，而xml的标签名全部都是自定义的</p><p>曾经往往使用xml进行数据传输，但是现在多使用json进行传送数据</p><p>ajax可以理解成是懒加载的一种实现</p><p>XHR即XMLHTTPRequest</p><p>使用url进行传参首先使用？打头，输入对应键值对，不同的属性键值对使用&amp;分隔</p><p>可以通过调用abort()来手动控制请求的取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>             <span class="hljs-comment">//发送的请求</span><br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;workbench/activity/saveCreateActivity.do&#x27;</span>,<br>             <br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-comment">//注意属性名要和实体类中对应的属性名保持一致</span><br><span class="hljs-attr">owner</span>:owner,<br><span class="hljs-attr">name</span>:name,<br><span class="hljs-attr">startDate</span>:startDate,<br><span class="hljs-attr">endDate</span>:endDate,<br><span class="hljs-attr">cost</span>:cost,<br><span class="hljs-attr">description</span>:description<br>&#125;,<br><span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;post&#x27;</span>,<br>             <span class="hljs-comment">//对响应体的设置</span><br><span class="hljs-attr">dataType</span>:<span class="hljs-string">&#x27;json&#x27;</span>,<br>             <span class="hljs-comment">//成功的回调函数</span><br><span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br><span class="hljs-comment">//根据是否成功添加决定对应操作</span><br><span class="hljs-keyword">if</span>(data.<span class="hljs-property">code</span>==<span class="hljs-string">&quot;1&quot;</span>)&#123;<br><span class="hljs-comment">//关闭模态窗口</span><br>$(<span class="hljs-string">&quot;#createActivityModal&quot;</span>).<span class="hljs-title function_">modal</span>(<span class="hljs-string">&quot;hide&quot;</span>);<br><span class="hljs-comment">//刷新市场活动列，显示第一页数据，保持每页显示条数不变</span><br><span class="hljs-title function_">queryActivityByConditionForPage</span>(<span class="hljs-number">1</span>,$(<span class="hljs-string">&quot;#demo_pag1&quot;</span>).<span class="hljs-title function_">bs_pagination</span>(<span class="hljs-string">&#x27;getOption&#x27;</span>, <span class="hljs-string">&#x27;rowsPerPage&#x27;</span>));<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//提示信息</span><br><span class="hljs-title function_">alert</span>(data.<span class="hljs-property">message</span>);<br><span class="hljs-comment">//模态窗口不关闭</span><br>$(<span class="hljs-string">&quot;#createActivityModal&quot;</span>).<span class="hljs-title function_">modal</span>(<span class="hljs-string">&quot;show&quot;</span>);<span class="hljs-comment">//可以不写。</span><br>&#125; <br>&#125;<br>                 <span class="hljs-comment">//对超时时间的设定 （单位为毫秒） </span><br>             timeout = <span class="hljs-number">2000</span>;<br>             <span class="hljs-comment">//当失败时对应的函数</span><br>             error：<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>             <br>         &#125;<br><span class="hljs-comment">//对请求头信息进行设置</span><br><span class="hljs-attr">headers</span>:&#123;<br>                     <span class="hljs-attr">c</span>:<span class="hljs-number">300</span>;<br>                     <span class="hljs-attr">d</span>:<span class="hljs-number">400</span><br>                 &#125;<br>             <br>&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>同源策略指的是协议、域名、端口号必须完全相同这是浏览器的一种安全策略，如果违背同源策略则称之为跨域，ajax默认要满足同源策略</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/CustomerManage/"/>
    <url>/2023/03/06/CustomerManage/</url>
    
    <content type="html"><![CDATA[<p>mybatis对jdbc进行封装，将繁琐的步骤进行封装，程序员只需要编写SQL语句即可</p><p>spring所谓的容器实际上就是整合了工厂类，维护类资源，维护数据库资源</p><p>spring全家桶相当于做到即插即用</p><p>往往使用自己编写的id，因为这样的id运行效率高</p><p>多对多的关系可以使用中间表进行处理</p><p>在最后进行打包的过程中，所有的编译结果和资源都会存放在webApp中</p><p>webApp根目录下的数据是不安全的，外界可以使用URL直接进行访问，所以实际上在实际开发中都会将页面存放在web-inf下，该目录下的文件不能直接访问，外界通过使用指定的URL通过访问控制器跳转到对应页面</p><p>依赖和插件的区别：依赖是jar包，只能用别的程序调用，插件是独立的程序，可以单独运行</p><p>使用Mybatis逆向工程进行创建时，注意每次只创建需要使用的类，因为如果重复创建会导致原先编写好的对应类，被逆向工程重新创建的新的类给覆盖掉了</p><p><a href="https://blog.csdn.net/aiming66/article/details/79046432">submit和button的区别_</a></p><p>在调试的过程中可以通过在浏览器手动编写对应URL来进行测试</p><p>避免重复编写代码，相同逻辑的代码进行封装成一个专门的类或者一个专门的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><br>$&#123;loginAct.value&#125;表示从四大作用域中依次寻找loginAct的值，如果没有则赋空值<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loginAct&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;loginAct.value&#125;&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span>&gt;</span><br><br>$&#123;cookie.loginAct.value&#125;表示从cookie中获取loginAct的值，如果没有找到不返回空值<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loginAct&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;cookie.loginAct.value&#125;&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>区分是使用请求转发还是使用重定向，根据是否需要修改对应的URL进行判断，如果需要修改对应URL则进行重定向</p><p>拦截器是不同的框架对于过滤器的进一步封装，使得过滤器的性能更加强大，而一般不使用过滤器，因为其功能简单不足以满足需求</p><p>session在半个小时之内会被保存，超过半个小时之后会进行删除session</p><p>在一个窗口上可以使用页面切割技术将一个页面显示两个网页</p><p>注意在页面设计过程中还有z轴的数据进行设定，有时候对应的数据并不是没有只是设置的z轴数据过低导致其被覆盖</p><p>js是弱类型的语言，形参不需要标明对应的数据类型，传进的数据类型根据传入的参数决定</p><p>注意设置表与表之间的数据的排序编码集要相同，否则查询不到<a href="https://blog.csdn.net/asanscape/article/details/107658748">(31条消息) MySQL错误Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT)解决方法_晨山往事的博客-CSDN博客_illegal mix of</a></p><p>调试代码可以通过使用alert进行输出来判断</p><p>如果想要点击按钮的时候获取到对应的值，那么就将对应的值绑定在对应的按钮上，使得点击按钮时获取对应的数据</p><p>当使用表单组件标签时建议使用value属性进行赋值，但是当使用的不是表单组件标签时，建议不使用value属性进行赋值，因为value会使得浏览器默认认为其为表单组件</p><p>对于是否要使用一个新的controller来进行控制跳转取决于该数据返回的页面位置，如果返回的页面在同一个文件夹下则不需要重新创建controller，如果这个controller过于复杂则可以选择使用新创建一个controller</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>从二叉树寻找父节点开始将代码逐渐转移到笔记中深化理解（难理解的贴代码，没那么难理解的还是在idea中看吧）</p><p>异或可以理解为无进位相加，或者相同则0，不相同则1</p><p>子问题是等量规模的则均可以使用master公式进行求解，即使子问题的求解规模有重复的部分，但只要子问题是等量的均可以使用master公式求解时间复杂度，只要确定了对应的a,b,d三者的值，进行比较就可以直接推导出对应时间复杂度</p><p>例如在合并排序中，merge方法即为子问题求解外的时间复杂度，其中由于其遍历了所有的数组，故将数组元素转到help数组的时间复杂度是$O(n)$，将help数组再次转换回原数组时间复杂度为$O(n)$</p><p>时间复杂度为$O(n^2)$的排序算法效率差的原因是进行了过多的重复比较，浪费了比较行为，结合小和问题总结，即减少重复的比较次数，提高对已知结果的利用率</p><p>如果不对自定义类进行重写比较方法却强行调用sort()，则系统会根据内存地址进行排序，得到的排序结果无意义</p><p>想要自定义排序时，只需要重写对应比较器，然后在调用sort函数的第二个参数传入对应比较器即可</p><p>在实际解决问题的过程中，可能会根据样本量的大小或其他角度来使用不同的排序算法</p><p>实际上任何递归函数都可以转换成非递归函数，递归本身即系统对函数进行压栈，手动控制压栈即可以实现非递归改写</p><ul><li>输入规模角度：数据量大时使用快速排序进行分组，当组内数据量减少到一定量时不使用快排而是使用插入排序，避免进一步递归操作（在时间复杂度角度来看快排仍然占优势，但由于数据量减少到一定量时，不得不考虑时间复杂度的常数项系数的值，而插入排序的常数项系数值极低，效率更高）</li><li>稳定性角度：当输入的数据属于不需要考虑稳定性时使用快速排序，而需要稳定性时使用归并排序</li><li>实际上在各种语言的系统库中的排序函数都是很复杂的处理，兼容各种排序算法的优缺点进行操作</li></ul><p>当问题中出现元素<strong>独一无二</strong>的要求限定时，注意使用哈希表的特性来实现</p><h4 id="奇偶分侧问题："><a href="#奇偶分侧问题：" class="headerlink" title="奇偶分侧问题："></a><strong>奇偶分侧问题：</strong></h4><p>问题描述：将待操作数组中的奇数放在数组左边，偶数放在数组右边，并且要求原始的相对次序不变</p><ul><li>实际上可以将问题简化成01分侧问题，即将问题转化为实现快排的稳定性问题，即““01 stable sort”问题，可以实现但实际上很难，属于学术性问题</li></ul><h4 id="小和问题："><a href="#小和问题：" class="headerlink" title="小和问题："></a><strong>小和问题：</strong></h4><p>问题描述：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和求一个数组的小和 </p><p>例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 边比4小的数1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、2; 所以小和为1+1+3+1+1+3+4+2&#x3D;16</p><ul><li>和merge操作不同在于，小和问题在遇到左右两数组数据相同时，首先拷贝<strong>右组</strong>数据，以此来保证能通过数组下标进行获取有几个比该数大的数字（注意由于其限定先拷贝右组数据，导致其丧失排序结果的稳定性）</li></ul><h4 id="荷兰国旗问题："><a href="#荷兰国旗问题：" class="headerlink" title="荷兰国旗问题："></a><strong>荷兰国旗问题</strong>：</h4><p>i为遍历的量，小于区域标志 p , 大于区域标志 q （快排思想）</p><ul><li>若a[i]≤num，则将a[i]和小于等于区域边界下一个数交换，p++,i++</li><li>若a[i]&#x3D;num，则仅执行  i++</li><li>若a[i]≥num，则将a[i]和大于等于区域边界上一个数交换，q–，i不变（因为新换过来的是没比较的）</li><li>当i&#x3D;q时，终止运算（此时已经遍历完所有待比较的数据）</li></ul><h4 id="快排问题："><a href="#快排问题：" class="headerlink" title="快排问题："></a><strong>快排问题：</strong></h4><ul><li>快排1.0：选取最后数组最后一个数num作为分隔，将之前的数据分为小于,大于两部分，最后将大于区域的第一个数和num进行交换，递归操作，最坏时间复杂度$O(n^2)$</li><li>快排2.0：选取最后数组最后一个数num作为分隔，将之前的数据分为小于,等于,大于三部分，最后将大于区域的第一个数和num进行交换，递归操作（优化在于，当存在重复数据时将重复数据提出到中间部分，避免其又混入到递归层次中），最坏时间复杂度$O(n^2)$<ul><li>前两种快排最坏时间复杂度原因是因为每次选取最后面的值作为分隔，可能每次操作都是逆序的，导致减少的规模过少</li></ul></li><li>快排3.0：分隔数据选择随机一个数进行划分，然后和数组最后一个数交换，其余同上一种方法，时间复杂度为$O(N*logN)$，空间复杂度为$O(logN)$（注意即使使用非递归方式实现快排，空间复杂度还是无法省略）<ul><li>与前面两种的区别在于避免了出现顺序的数组导致快排效率低，而是每次都进行随机化，从概率上避免最差情况（最后一个数实际上也是理论上随机的选取的，但是实际中往往由于顺序的，故容易出现最差的情况）</li></ul></li></ul><p><strong>大根堆：</strong>整棵树以及每一棵子树都是以根结点为最大值，而左右子树的大小关系不确定，小根堆同理</p><h4 id="堆操作："><a href="#堆操作：" class="headerlink" title="堆操作："></a><strong>堆操作：</strong></h4><ul><li>堆的高度：$O(logN)$</li></ul><p>​                 结点数：    1 2 3 4 5 6 7 ……</p><p>​                 对应高度：1 2 2 3 3 3 3 ……</p><ul><li><p>结点插入（heapInsert）：添加到堆的末尾，不断和其父节点进行比较，满足条件则进行交换，heapsize++，对应时间复杂度为$O(logN)$</p></li><li><p>堆顶弹出（heapify）：弹出堆顶数据，将堆末尾的数据和堆顶数据交换，heapsize–，从新产生的堆顶不断向下进行比较，满足条件则进行交换（原堆末尾的数据是否擦除无影响，因为heapsize–已经将这个数据排除在堆限定范围内）对应时间复杂度为$O(logN)$</p></li><li><p>修改堆中的任意结点的值：根据变大还是变小选择使用结点插入（heapInsert）或  堆顶弹出（heapify）</p></li><li><p>堆排序：将堆顶数据弹出后进行heapify，再弹出，再heapify，重复操作</p><ul><li>时间复杂度$O(N*logN)$</li><li>空间复杂度$O(1)$</li></ul></li><li><p>普通树的堆化：从最后一个结点开始不断使用heapify，但实际上由于叶子结点本身没有子节点所以heapify叶子结点没有效果，故实际上是从第一个非叶子结点进行heapify，时间复杂度使用错位相减易得其时间复杂度为$O(n)$</p></li><li><p>注意堆结构即优先队列</p></li><li><p>实际上可以调用系统提供的heap类，只需要添加和弹出即可</p></li><li><p>中位数问题：</p><ul><li><p>问题描述：维持一个结构，在数据流中快速获取中位数</p></li><li><p>利用大根堆和小根堆来解决问题，通过以下步骤实现中位数</p><ul><li>遍历到的结点判断和是否小于当前大根堆的堆顶，如果小于则添加到大根堆中，如果大于则添加到小根堆中</li><li>当大根堆和小根堆数量相差超过1时，将数量较大的堆弹出一个数据到另一个堆中</li><li>重复上述操作，当所有数据都添加后两个堆的堆顶就是中位数</li></ul><p><img src="C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220417183034.png" alt="微信图片_20220417183034"></p></li></ul></li></ul><h4 id="基本有序问题（堆结构思想）："><a href="#基本有序问题（堆结构思想）：" class="headerlink" title="基本有序问题（堆结构思想）："></a><strong>基本有序问题（堆结构思想）：</strong></h4><p>题目简介：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小  请选择一个合适的排序算法针对这个数据进行排序</p><ul><li>读取原数组的前k个数据构建小根堆</li><li>弹出小根堆堆顶，再从原数组中heapInsert一个结点</li><li>重复上一步操作，直至读取所有数据，弹出所有小根堆的数据</li><li>时间复杂度为$O(N*logk)$，当k很小时，时间复杂度趋向于$O(N)$</li></ul><h4 id="桶排序："><a href="#桶排序：" class="headerlink" title="桶排序："></a><strong>桶排序：</strong></h4><ul><li>桶排序不是基于比较的算法</li><li>桶排序入桶和出桶的次数取决于待排序数据的最高位数</li><li>可以对桶排序进行优化，不使用桶，而是使用词频表进行记录（详见视频）（其使用逆序遍历的方法模拟了出入桶后进先出的特性）</li></ul><h4 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a><strong>哈希表：</strong></h4><ul><li>哈希表的寻址是常数级别，但是属于是较大的常数</li><li>当值是值类型时复制对应数据到哈希表中，当值是引用类型时，则存放的是8个字节的一个对应对象的地址</li></ul><h4 id="链表："><a href="#链表：" class="headerlink" title="链表："></a><strong>链表：</strong></h4><ul><li>快慢指针：都从头开始，快指针一步走两下，慢指针一步走一下，使得当快指针遍历结束后，慢指针正好在中间（具体实现注意练习，可能在奇偶的情况下需要进行微调）</li><li>判断回文序列并且要求时间复杂度达到$O(N)$，额外空间复杂度达到$O(1)$<ul><li>依旧使用快慢指针的方法，只是当获取到中点的指针后，慢指针指向的结点的后序结点指向空，快指针指向的结点开始逆向指向其父节点，直至指到中间结点（一根面条从中间拉起）</li></ul></li><li>链表版荷兰旗问题：<ul><li>暴力算法：将结点依次存放在对应node数组中，利用快排解决荷兰旗问题，但消耗了过多额外空间</li><li>六变量算法：使用六个变量分别限定小于区域，等于区域，大于区域的头结点和尾节点，初始值均为null，从待解决链表的头结点依次遍历，将对应符合条件的结点放在对应的链表体系中，每次添加注意修改尾节点的指向，最终将形成的三条链表依次首尾相连</li></ul></li><li>random结点链表问题：<ul><li>问题描述：链表中的每一个结点都额外多一个名为rand的指针，随机指向该链表的任意位置（包含null），现要求完全复制一个新的链表和该链表相同（rand指向的结点也得相同）</li><li>使用额外空间：使用哈希表进行对结点进行唯一化</li><li>不使用额外空间：将原结点和新节点一次串起（1–&gt;1*–&gt;2–&gt;2*–&gt;3–&gt;3*–&gt;null），其中原结点的rand指针依旧指向其原本指向的结点，由于新旧结点成对出现，原结点的后一个结点一定是对应的新节点，成对处理，进行配置后删除原结点即可（相较于哈希表，通过成对出现的结构绑定了单独的映射关系）</li></ul></li><li>双链表相交问题：<ul><li>给定两个可能有环也可能无环的单链表，头节点head1和head2请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 并要求如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</li><li>使用额外空间：使用哈希表进行唯一性确定</li><li>不使用额外空间：注意这还是个基本的链表结构，其结点只有一个next，所以实际上不存在中间打结的那种环，解决方法使用快慢指针，当快指针读取到null时，说明该链表中一定没有环，如果链表中有环，那么快指针和慢指针肯定会重合，因为两个指针终归会在一个环中绕圈圈，当快指针和慢指针重合时，快指针返回起点，慢指针不动，然后两个指针都一次走一步，最终二者重合的结点就是第一个入环的结点处（证明待查）</li></ul></li></ul><h4 id="图："><a href="#图：" class="headerlink" title="图："></a><strong>图：</strong></h4><ul><li><p>图的BFS算法：</p><ul><li>&#96;&#96;&#96;java<br>public static void bfs(Node node) {<br>   if (node &#x3D;&#x3D; null) {<br>  return;<br>   }<br>   Queue<Node> queue &#x3D; new LinkedList&lt;&gt;();<br>   HashSet<Node> map &#x3D; new HashSet&lt;&gt;();<br>   queue.add(node);<br>   map.add(node);<br>   while (!queue.isEmpty()) {<br>  Node cur &#x3D; queue.poll();<br>  System.out.println(cur.value);<br>  for (Node next : cur.nexts) {<br>     if (!map.contains(next)) {<br>        map.add(next);<br>        queue.add(next);<br>     }<br>  }<br>   }<br>}<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>+ 图的DFS算法：<br><br>  + ```<span class="hljs-function">java</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (node == null) &#123;<br>          <span class="hljs-keyword">return</span>;<br>       &#125;<br>       Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       HashSet&lt;Node&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>       stack.<span class="hljs-built_in">add</span>(node);<br>       set.<span class="hljs-built_in">add</span>(node);<br>       System.out.<span class="hljs-built_in">println</span>(node.value);<br>       <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>          Node cur = stack.<span class="hljs-built_in">pop</span>();<br>          <span class="hljs-keyword">for</span> (Node next : cur.nexts) &#123;<br>             <span class="hljs-keyword">if</span> (!set.<span class="hljs-built_in">contains</span>(next)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                stack.<span class="hljs-built_in">push</span>(next);<br>                set.<span class="hljs-built_in">add</span>(next);<br>                System.out.<span class="hljs-built_in">println</span>(next.value);<br>                <span class="hljs-keyword">break</span>;<br>             &#125;<br>          &#125;<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>图的拓扑排序：</p><ul><li>&#96;&#96;&#96;java<br>public static List<Node> sortedTopology(Graph graph) {<br>   HashMap&lt;Node, Integer&gt; inMap &#x3D; new HashMap&lt;&gt;();<br>   Queue<Node> zeroInQueue &#x3D; new LinkedList&lt;&gt;();<br>   for (Node node : graph.nodes.values()) {<br>  inMap.put(node, node.in);<br>  if (node.in &#x3D;&#x3D; 0) {<br>     zeroInQueue.add(node);<br>  }<br>   }<br>   List<Node> result &#x3D; new ArrayList&lt;&gt;();<br>   while (!zeroInQueue.isEmpty()) {<br>  Node cur &#x3D; zeroInQueue.poll();<br>  result.add(cur);<br>  for (Node next : cur.nexts) {<br>     inMap.put(next, inMap.get(next) - 1);<br>     if (inMap.get(next) &#x3D;&#x3D; 0) {<br>        zeroInQueue.add(next);<br>     }<br>  }<br>   }<br>   return result;<br>}<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">+</span> 图的最小生成树：<br><br><span class="hljs-bullet">  +</span> K算法：从最小的边进行遍历，依次添加，如果添加后不产生环就添加，否则就不添加，至于判断是否有环是使用集合的进行操作，如果两个元素在同一个集合当中，就说明这两个元素添加边后产生回路<br><span class="hljs-bullet">  +</span> P算法（要求是无向图）：现在原本图中添加一个结点，并且将添加的结点所连接的边放入待添加范围内，每添加一个结点就将其相关联的边一并添加，并从待选择范围中选择最小的边进行添加（边使用最小堆进行存储，便于输出最小的边）<br><br><span class="hljs-bullet">+</span> 图的最短路径：<br><br><span class="hljs-bullet">  +</span> 迪杰特斯拉算法：不断判断是否随着过程推进，在原来的基础上是否产生了距离更短的，有则进行更新，注意其可以有负权值的边，但是不能有结果为负值的环<br><br><span class="hljs-section">#### <span class="hljs-strong">**前缀树：**</span></span><br><br>![<span class="hljs-string">微信图片_20220417152951</span>](<span class="hljs-link">C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220417152951.png</span>)<br><br><span class="hljs-bullet">+</span> 前缀树元素说明：<br><span class="hljs-bullet">  +</span> 一般前缀树的值是存放在边上的，但为了提高前缀树的效率，可以在其结点上增加部分数据<br><span class="hljs-bullet">  +</span> P即pass，表示的是有多少次数据经过该节点（通过该数据可以知道以某个字符串为前缀的字符串有多少个）<br><span class="hljs-bullet">  +</span> E即end ，表示的是有多少次字符串以该节点进行结尾（通过该数据可以知道某一种特定字符串是否进行了添加，并且添加了多少次）<br><span class="hljs-bullet">+</span> 注意删除一个字符串和添加一个字符串是对应的，沿途p--，最后e--，并且在删除过程中只要有一个结点p--后p为0，则说明该节点以下的所有节点都需要删除，只需要将这个p值为0的结点设置为null即可，jvm会自动进行释放下面没有引用的元素<br><br><span class="hljs-section">#### <span class="hljs-strong">**贪心算法：**</span></span><br><br><span class="hljs-bullet">+</span> 贪心算法就是使用局部最优解来推得全局最优解<br><br><span class="hljs-bullet">+</span> 贪心算法面试技巧：<br><br><span class="hljs-bullet">  +</span> 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试 <br><span class="hljs-bullet">  +</span> 然后脑补出贪心策略A、贪心策略B、贪心策略C... <br><span class="hljs-bullet">  +</span> 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确 <br><span class="hljs-bullet">  +</span> 不要去纠结贪心策略的证明<br><span class="hljs-bullet">  +</span> [<span class="hljs-string">对数器的相关解析</span>](<span class="hljs-link">https://blog.csdn.net/weixin_39953502/article/details/79504879</span>)<br><br><span class="hljs-bullet">+</span> 会议室问题：<br><br><span class="hljs-bullet">  +</span> 问题描述：一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲  给你每一个项目开始的时间和结束的时间(给你一个数 组，里面是一个个具体 的项目)，你来安排宣讲日程，要求会议室进行的宣讲的场次最多  返回这个最多的宣讲场次<br><span class="hljs-bullet">  +</span> 利用贪心算法思想，在每一次添加会议的选择范围内调用结束时间最早的会议<br><br><span class="hljs-bullet">+</span> 字符串字典序排序问题：<br><br><span class="hljs-bullet">  +</span> 问题描述：给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最小的字典序<br><span class="hljs-bullet">  +</span> 字典序：就是字典中的排序方法，首先比较第一个字母（如果两个字符串的长度不同，则将短的字符串扩充成长字符串位数），如果第一个字母相同则顺次重复比较<br><span class="hljs-bullet">  +</span> 贪心策略A:根据字符串本身的字典序进行拼接，该种方式错误  eg:  &quot; b &quot;  ,  &quot; ba &quot; 进行拼接<br><span class="hljs-bullet">  +</span> 贪心策略B:将整个字符串进行&quot;排序&quot;，排序的规则是根据两个待比较的字符串尝试各自放在前面拼接，取拼接后字典序较小的放在前面（正确,但严格证明需要证明其传递性）<br><br><span class="hljs-bullet">+</span> 切金条问题：<br><br><span class="hljs-bullet">  +</span> 问题描述：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金 条，不管切成长度多大的两半，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? 例如,给定数组&#123;10,20,30&#125;，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10,20,30三个部分。 如果先把长度60的金条分成10和50，花费60； 再把长度50的金条分成20和30，花费50；一共花费110铜板。 但是如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20， 花费30；一共花费90铜板。 输入一个数组，返回分割的最小代价<br><span class="hljs-bullet">  +</span> 实际上就是使用哈夫曼树进行处理<br><br><span class="hljs-bullet">+</span> 项目利益最大化问题：<br><br>  ![<span class="hljs-string">微信图片_20220417174545</span>](<span class="hljs-link">C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220417174545.png</span>)<br><br><span class="hljs-bullet">+</span> 1<br><br><span class="hljs-bullet">+</span> 1<br><br><span class="hljs-bullet">+</span> <br><br><span class="hljs-section">#### <span class="hljs-strong">**二叉树：**</span></span><br><br><span class="hljs-bullet">+</span> 利用递归序列，简便递归输出（贪多嚼不烂啊，不能浮躁好不好，到时候再把二叉树重看一遍）<br><br>  ![<span class="hljs-string">微信图片_20220416151819</span>](<span class="hljs-link">C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220416151819.png</span>)<br><br>  先序遍历：第一次遇到这个数字的时候进行打印<br><br>​  中序遍历：第二次遇到这个数字的时候进行打印<br><br>  后序遍历：第三次遇到这个数字的时候进行打印<br><br><span class="hljs-bullet">+</span> 非递归的遍历输出：利用栈进行模拟，从而实现二叉树的输出<br><br><span class="hljs-bullet">+</span> 特殊结点的定义：<br><br><span class="hljs-bullet">  +</span> 后继结点：中序遍历后，位于该节点后面的结点称之为后继结点<br><span class="hljs-bullet">  +</span> 前驱结点：中序遍历后，位于该节点前面的结点称之为前驱结点 <br><br><span class="hljs-bullet">+</span> 二叉树的宽度遍历（待查）<br><br><span class="hljs-bullet">+</span> 纸条折痕问题：<br><br><span class="hljs-bullet">  +</span> 问题描述：一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开，此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向<br><br><span class="hljs-bullet">  +</span> 实际上打印折痕方向就是对对应构造出的二叉树进行中序遍历<br><br><span class="hljs-code">    ![微信图片_20220416192721](C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220416192721.png)</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">+</span> 求两个结点的最低公共父节点：<br><br><span class="hljs-bullet">  +</span> 基本方法：根据遍历依次进行查找<br><br><span class="hljs-bullet">    +</span> 遍历过程中使用哈希表记录所有节点的父节点<br><span class="hljs-bullet">    +</span> 根据对应哈希表获取A结点的所有父节点<br><span class="hljs-bullet">    +</span> 遍历获取B结点的父节点（每向上查找一次，就查询是否在A的父节点的集合中）<br><br><span class="hljs-bullet">  +</span> 升级方法：由于这两个结点只有两种情况，互相在彼此的父节点集合中或者为另外一个结点的子结点集中<br><br><span class="hljs-code">    ```java</span><br><span class="hljs-code">    //结合实际例子上进行分析</span><br><span class="hljs-code">    public static Node lowestAncestor(Node head, Node o1, Node o2) &#123;</span><br><span class="hljs-code">    if (head == null || head == o1 || head == o2) &#123;</span><br><span class="hljs-code">    return head;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    Node left = lowestAncestor(head.left, o1, o2);</span><br><span class="hljs-code">    Node right = lowestAncestor(head.right, o1, o2);</span><br><span class="hljs-code">    if (left != null &amp;&amp; right != null) &#123;</span><br><span class="hljs-code">    return head;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    return left != null ? left : right;</span><br><span class="hljs-code">    &#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>特殊后继结点查找：</p><ul><li><p>题目描述：现将原经典二叉树结点定义中增加一个数据parent用于指向其父节点</p></li><li><p>暴力解法：对所有节点进行中序遍历获取其后继结点，时间复杂度为$O(N)$</p></li><li><p>利用父节点的解法：实际上后继节点的关系只有两种</p><ul><li><p>情况1：该结点的右子树不为空，则该节点的后继结点是其右子树的最左边的结点</p></li><li><p>情况2：该结点的右子树为空，则从该结点开始不断向其父节点询问该结点是否为父节点的左子结点，如果条件满足则此时的父节点就是该节点的后继结点，如果条件不满足则将该节点的父节点重复向父节点的父节点进行询问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getSuccessorNode</span><span class="hljs-params">(Node node)</span> &#123;<br>   <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> node;<br>   &#125;<br>    <span class="hljs-comment">//情况1</span><br>   <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> getLeftMost(node.right);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> node.parent;<br>       <span class="hljs-comment">/*注意while的条件设置</span><br><span class="hljs-comment">       parent != null表示的是这个节点是整个二叉树中的最后一个结点，其对应的父节点就该是null，恰巧此时parent就   是null*/</span><br>      <span class="hljs-keyword">while</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left != node) &#123;<br>         node = parent;<br>         parent = node.parent;<br>      &#125;<br>      <span class="hljs-keyword">return</span> parent;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLeftMost</span><span class="hljs-params">(Node node)</span> &#123;<br>   <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> node;<br>   &#125;<br>   <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>      node = node.left;<br>   &#125;<br>   <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>二叉树的序列化和反序列化：</p><ul><li>对该二叉树进行先序遍历，如果有值则以其结点值，如果为空则加入#，并且注意在每一次添加结点值时都需要在其后边添加”_”作为分隔符(实际上可以使用不同的方式进行遍历，效果相同)</li><li><img src="C:\Users\小赵同学\Desktop\计算机笔记\算法图片\微信图片_20220416191202.png" alt="微信图片_20220416191202"></li></ul></li><li><p>二叉树类型的判断：</p><ul><li>判断是否为BST：BST即对于一棵树及其子树，其对应的左边的结点都比根结点小，右结点都比根结点大<ul><li>方法一：使用中序遍历进行判断，如果中序遍历产生的序列是升序的就是BST</li><li>方法二：使用递归的思想进行处理，使其对于任意结点均满足以下的条件<ul><li>左子树是BST</li><li>右子树是BST</li><li>左子树的最大值小于该结点</li><li>右子树的最小值大于该节点</li></ul></li></ul></li><li>判断是否为完全二叉树：对所有节点进行层序遍历，使其满足以下两个条件<ul><li>如果一个结点有右子结点，那么该结点必须要有左子节点</li><li>在上一个条件满足的情况下，当第一次遇见只有左节点的情况下，后序的所有节点必须都是叶子结点</li></ul></li><li>判断是否为满二叉树：<ul><li>获取该二叉树的最大深度和结点个数，根据其两者关系进行判断</li></ul></li><li>判断是否为平衡二叉树：使其满足条件<ul><li>左子树是平衡二叉树</li><li>右子树是平衡二叉树</li><li>左子树和右子树之间的高度差不超过1</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/thymeleaf%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/thymeleaf%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>thymeleaf取决于是否传递了对应的标签，如果传递了标签就会进行动态渲染，如果没有传递标签就会使用原来的默认数据</p><p>实际上thymeleaf就是使用动态渲染的方式来代替原本静态渲染的方式</p><p>使用${ }其中括号中的数据表示的是由java传递过来的数据</p><p>在使用${ }和| |时注意这两者实际上是结合使用的，当只使用${ }时，如果要进行字符串拼接的操作话则需要使用  +  以及  “ “  进行组合，但是如果将  | |  和  ${ }  相结合则不需要使用前面那种方法可以直接进行字符串拼接</p><p>${ }中需要进行传入对应的<strong>变量</strong>，只要传送进来的是个变量就需要使用${ }将其包裹起来</p><p>在thymeleaf中，只有使用  th:  标识前缀的属性才会被解析</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/JavaWeb%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>一般不要使用2000以内的端口号，因为这部分端口号已经被系统所占用了</p><p>由于servlet本身是线程不安全并且是单例的，所以一般不要在servlet中定义成员变量，如果不得已一定要定义成员变量，则不要使用该成员变量进行控制其行为</p><p>session保存作用域是和具体的某个session所对应的，不同的session不能相互访问数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Servlet从3.0版本开始支持使用注解的方式进行注册</span><br><span class="hljs-meta">@WebServlet(&quot;/index&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>Servlet</strong>：（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。</p><p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p><p>最早支持Servlet标准的是JavaSoft的Java Web Server，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet</p><p><a href="https://blog.csdn.net/weixin_30439031/article/details/97061933">服务器端组件相关知识</a></p><p><a href="https://www.cnblogs.com/whgk/p/7112560.html">maven相关概述</a></p><p>当在当前项目下复制包时，复制得到的项目还未加入当前项目，加入的项目显示为粗体，需要在“项目结构”中导入该包</p><p><strong>http协议的无状态</strong>：无状态协议指的是对于事物处理没有记忆能力，也就是说，当客户端第一次像服务器发送http请求完成之后，再一次像服务器发送http请求，服务器并不知道该客户端是一个老用户</p><p><strong>http协议无状态的处理方式</strong>：解决办法是携带Cookie,Cookie相当于是一个通行证，当客户端第一次像服务端发送http请求时，服务端向客户端返回一个cookie，当客户端再次发送http请求时携带该cookie，于是服务端便知道该客户端是一个老用户了</p><p><a href="https://blog.csdn.net/weixin_45622540/article/details/105026612">${ }解释</a>（其实就是相当于占位符用于将变量填入字符串中）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delFruit</span>(<span class="hljs-params">fid</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;是否确认进行删除？&#x27;</span>))&#123;<br>        windows.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&#x27;del.do?fid=&#x27;</span>+fid;<br>    <span class="hljs-comment">//windows  指的是当前窗口</span><br>    <span class="hljs-comment">//location 指的是地址栏</span><br>    <span class="hljs-comment">//href     指的是要跳转的页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要不是通过post传送过来的数据都是使用doget方法</p><p>通过js进行删除和根据Tomcat从服务器进行删除是两回事，前者是直接使用js对页面进行修改，并没有修改数据库的相关内容，后者是通过修改数据库中数据，并且由于页面本身的数据是从数据库中获取的所以导致了页面的修改</p><p>可以使用xml进行设置ID和class的关系，进一步通过操作流的形式，创建一个键为ID值为Class的哈希表，用于绑定id和class的关系（其中class的获取通过调用反射中的forname方法来创建一个Class数据）</p><p>在不同的表单对应的servlet上层编写一个中央处理程序，目的是通过反射和xml将id和Class相对应，避免每一个servlet程序中均需要通过反射来获取相应的Class属性</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/JDBC%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/JDBC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/minose/article/details/85040646">preparedstatement和statement的区别</a></p><p>预编译即做些代码文本的替换工作，是整个编译过程的最先做的工作，是在编译之前所作的工作</p><p><strong>需要使用预编译的情况：</strong></p><ul><li>总是使用不经常改动的大型代码体</li><li>程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个“预编译头</li></ul><p>SQL注入：SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/JavaScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 是一种弱类型语言，所以函数对接收和输出的值都没有类型限制，JavaScript 也不会自动检测输入和输出值的类型，故对应的返回值是根据传入的参数决定的，所以在函数定义时也没有标注具体返回值类型</p><p>使用外链式js代码，不需要进行任何依赖行为，打开页面就会执行使用script标签的src属性进行引入指定js文件</p><p>var表示的是设置了一个容器</p><p>在js当中不区分单引号和双引号，只要前后字符串的符号相匹配即可</p><p>布尔类型只有true和fulse两种</p><p>空类型有两种，null表示的有值，有的是一个空值，而undefined表示的是没有值，即未被定义</p><p>parseInt是将一个字符串的数据转为整形，并且相比于number（），从最前面一位，一步步往后面找到非数字的位</p><p>只要符号旁边有字符串类型，最后的结果就是字符串类型</p><p>&#x3D;&#x3D;只需要判断值是不是相等，不考虑数据类型</p><p>&#x3D;&#x3D;&#x3D;要求不仅值需要相等，并且数据类型也要相等</p><p>switch的穿透效果，是根据第一个相匹配的内容之后进行穿透</p><p>在js中函数也被视为是一种数据类型</p><p>在js中只有全局作用域和私有作用域，其中全局作用域就是指的是页面的范围，而私有作用域只有函数能产生私有作用域</p><p>变量定义在哪里，其作用域就是哪里</p><p>在变量使用的时候，注意自己有就使用自己的，如果自己没有就逐层向上进行查找，如果全局都没有，则报错</p><p>对象即为多个键值对的组合</p><p>数组即多个数据的顺序存储</p><p>字符串和数组的相关方法都是不影响原字符串或者数组</p><p>设置的时候是不能设置星期的，因为在设置年月日的时候就已经自动匹配到了一个星期</p><p>获取元素的返回值必然是一个伪数组，如果有标签名对应的元素，有多少就获取多少，如果没有标签名对应的元素，则返回值为空的伪数组</p><p>如果是获取一个元素的情况，如果没有对应的元素，则返回值是null</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>汇编语言的主体是汇编指令，汇编指令是机器指令的助记符</p><p>寄存器是CPU中存储数据的器件，一个CPU中有多个寄存器</p><p>汇编语言组成部分：汇编指令（机器码的助记符），伪指令（由编译器处理），其他字符（由编译器处理）</p><p>汇编语言的核心是汇编指令，它决定了汇编语言的特性</p><p>磁盘不同于内存，磁盘中的数据或程序如果不读到内存中，就无法被CPU所使用</p><p>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息，同一条信息可以被两种解释</p><p>存储器被划分为若干个存储单元</p><p>CPU想要对数据进行读写，必须和外部器件（标准的说法是芯片），进行三种信息的交互：</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul><p>连接CPU和其他芯片的导线称之为总线，逻辑上分为：地址总线，控制总线，数据总线</p><p>64位指的是：CPU，操作系统，软件，均为64位</p><p>一个CPU有N条地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存地址</p><p>数据总线的宽度决定了CPU和外界的数据传送速度</p><p>从低到高索引：10010，低位为0，高位为1</p><p>CPU对外部的控制是通过控制总线进行的，控制总线是一些不同控制线的集合，有多少根控制总线，就意味着CPU对外部器件有多少种控制，所以控制总线的宽度决定了CPU对外部器件的控制能力</p><p>读和写操作实际上是有几根控制线综合发出的</p><p>每一种CPU都有自己的汇编指令集</p><p>CPU可以直接使用的信息在存储器中存放</p><p>一个存储单元可以存储8个bit，即8个二进制数</p><p>地址总线的宽度决定了cpu的寻址能力</p><p>数据总线的宽度决定了CPU和其他器件的数据传输一次的传输数据量</p><p>一个CPU的地址线宽度为10即表明其可以寻址1024个内存单元，这1024个可寻的内存单元就构成这个CPU的内存地址空间</p><p>在每一台pc中，都有一个主板，上面有核心器件和一些主要器件，这些器件通过总线（地址总线，数据总线，控制总线）相连</p><p>CPU对外部设备不能进行直接控制，直接控制这些设备进行工作的是插在扩展插槽上的接口卡</p><p>BIOS是由主板和各类接口卡（显卡，网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出，在主板和某些接口卡上插有存储相应BIOS的ROM</p><p>从读写属性上存储器芯片分为两类：</p><ul><li>随机存储器（RAM）</li><li>只读存储器（ROM）</li></ul><p>从功能和连接上进行分类：</p><ul><li>随机存储器RAM</li><li>装有BIOS（basic input output system基本输入输出系统）的ROM</li><li>接口卡上面的RAM</li></ul><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\1636943426.png" alt="1636943426" style="zoom: 80%;" /><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\1636944068(1).png" alt="1636944068(1)"></p><p>不同存储器的相同点：</p><ul><li>都和CPU的总线相连</li><li>CPU对他们进行读写操作的时候都通过控制线发出内存读写命令</li></ul><p>逻辑存储器：</p><ul><li>所有的物理存储器被看作是一个由若干个存储单元所组成的逻辑存储器，即各类存储器看做是一个逻辑存储器</li><li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间</li><li>CPU就是在这段地址空间上进行读写数据，实际上就是在相对应的物理存储器中读写数据</li></ul><p>不同的CPU对于内存地址空间的分类不同</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\1636944110(1).png" alt="1636944110(1)"></p><p>一个典型的CPU是由运算器、控制器、寄存器等器件组成，这些器件靠内部总线进行相连</p><ul><li>内部总线用于实现CPU内部的各个器件之间的联系</li><li>外部总线实现CPU和主板上其他器件的联系</li></ul><p>8086CPU中有14个寄存器，各有不同的命名AX，BX等</p><p>8086CPU所有的寄存器都是16位的，可以用于存放两个字节</p><p>AX，BX，CX，DX通常用于存放一般性的数据，故被称之为通用寄存器</p><p>数据在寄存器中的存储高位进行补0</p><p>16位寄存器最多可以存放2的16次方减一（从0开始计数）</p><p>由于8086上一代CPU中的寄存器都是8位的，为了保证兼容性，这四个寄存器都可以分成两个独立的8位寄存器使用</p><p>AX可以左右分成低位存储器AL，高位存储器AH</p><p>16位称之为一个字，一个字自然可以存放在一个16位寄存器中，这个字的高位字节和低位字节自然就存放在这个寄存器的高8位寄存器和低8位寄存器中</p><p>16进制的一位对应2进制的四位，同理8进制的一位对应2进制的三位</p><p>汇编指令不区分大小写</p><p>数字后面标注H表示的是：该数是一个16进制数</p><p>由于寄存器只能存放16位数字，故超过16位的数字的高位部分会被放入进制位中，但是寄存器中存储的只能是低位的16位部分，例10023H会被抛弃成0023H</p><p>16位结构描述的是一个CPU具有以下几个方面的特征：</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路是16位的</li></ul><p>8086CPU有20位地址总线，可以传送20位的地址，寻址能力为1M，而8086内部为16位结构，它只能传送16位的地址，表现出来的寻址能力只有64k</p><p>8086CPU在读写内存时，相关操作如下</p><ul><li>CPU中的相关部件提供两个16位的地址，其中一个称之为段地址，另一个称之为偏移地址</li><li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li><li>地址加法器将两个16位的地址合并成一个20位的地址</li></ul><p>地址加法器合成物理地址的方法：</p><p><strong>物理地址 &#x3D; 段地址 X 16 + 偏移地址</strong></p><p>不要理解错段地址的概念，内存并没有被划分成一个一个的段，每一个段都有一个段地址，内存中段的划分来自于CPU，由于8086采取如上图的方式给出内存单元的物理地址，使得我们能够以分段的方式进行管理内存</p><p>由于存在段的概念，故可以在根据需要的情况下将若干个地址连续的内存单元看成是一个段，用段地址 X 16定位段的起始地址（基础地址），而用偏移地址定位段中的内存单元</p><ul><li>段地址 X 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数</li><li>偏移地址为16位，并且16位的寻址能力为64k，所以一个段的长度最大为64k</li><li>CPU访问内存单元时，必须向内存提供内存单元的物理地址</li><li>8086CPU在内部使用段地址和偏移地址移位相加的方法最终形成物理地址</li><li>由于物理地址是有段地址和偏移地址共同形成的，所以CPU可以使用不同的段地址和偏移地址进而形成同一个物理地址</li></ul><p>“数据在21F60H内存单元中”，该表示对于8086的两种描述</p><ul><li>数据存储在内存为2000:1F60中</li><li>数据存在内存2000段中的1F60H单元中</li></ul><p>可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段</p><p>由于偏移地址为16位，变化范围为0~FFFFH，仅使用偏移地址来寻址最多可寻找到64K个内存单元</p><p>比如给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H ~1FFFFH</p><p>段寄存器是用于提供段地址的，其中在8086CPU中有4个段寄存器</p><p>当8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址</p><p>CS是代码段寄存器，IP是指针指令寄存器，这两个寄存器是CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址</p><p>在8086CPU加电启动或者复位后（即当CPU刚刚开始工作时）CS和IP被设置为CS&#x3D;FFFFH，IP &#x3D; 0000H，即在PC机刚启动时，CPU会从内存FFFFH中读取指令执行，在FFFF0H内存单元中的指令是开机时执行的第一条指令</p><p>在任何时候，CPU将CS、IP中的内容当做是指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码并执行</p><p>如果内存中的一段信息曾经被CPU执行过，那么他所在的内存单元必定被CS:IP所指定过</p><p>由于在CPU操作过程中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改版寄存器中的内容完成对CPU的控制</p><p>CPU从何处执行指令是由CS、IP中的内容所决定的，程序员通过改变CS、IP中的内容来控制CPU执行目标指令</p><p>使用jmp同时修改CS和IP的值： jmp  段地址 ： 偏移地址   jmp 2AE3:3<img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211204134028.jpg" alt="微信图片_20211204134028"></p><p>段寄存器就是用于提供段地址的，8086CPU有四个段寄存器CS、DS,SS,ES</p><p>当8086CPU要访问内存时，就从这四个段寄存器中提供内存单元的段地址</p><p>8086CPU工作过程简述：</p><ul><li>从CS：IP指向内存读取指令，读取到的指令进入指令缓冲器</li><li>IP &#x3D; IP  +  所读取的指令的长度，从而指向下一条指令</li><li>执行指令，并且重复步骤1和2</li></ul><p>可以仅修改IP的内容：  jmp 某一合法的寄存器  jmp ax ，其作用为：用寄存器中的值修改IP的值</p><p>我们将一段内存当做代码段，仅仅是我们在编程过程中的一种安排，CPU并不会由于这种安排就自动将我们定义的代码块中的指令当做指令来执行，CPU只会将CS：IP所指向的内存单元中的内容看作为指令，所有要将CS：IP指向所定义代码块中的第一条指令的首地址</p><p>CS存放的是指令的段地址</p><p>IP存放的是指令的偏移地址</p><p>两个十六进制位是一个字节</p><p>字型数据是指占有两个字节的数据，并且注意起始位置存储的是数据的低位数据，而第二位存储的才是数据的高位数据</p><p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址</p><p>在8086内存地址是由段地址和偏移地址所组成的</p><p>8086CPU中有一个DS寄存器，通常用于存放要访问的数据的段地址</p><p>寄存器能够完成的作用：</p><ul><li>将数据直接传送入寄存器</li><li>将一个寄存器中的内容传送到另一个寄存器中</li><li>将一个内存单元中的内容送入一个寄存器（mov al,[0]）表示将偏移地址为0的数据传送到al中</li></ul><p>例如：以下程序段用于将10000H(1000:0)中的数据读取到al中，并且将ax中的数据传送给10000H(1000:0)的内存单元中，其中偏移地址是[ ]中的数据，而段地址是默认ds，并且不能对ds（段寄存器）进行赋值，必须借用通用寄存器进行赋值，但是段寄存器可以对通用寄存器进行赋值</p><p>mov bx ,1000H</p><p>mov ds , bx</p><p>mov al , [0]  &#x2F;&#x2F;传送的是8位数据</p><p>mov [0] ,ax  &#x2F;&#x2F;传送的是16位数据</p><p>由于8086是16位结构，有16根数据线，所以能够一次性传送16位的数据，即一次性传送一个字</p><p>输入默认是16进制，但是书上可能后边标有H的是十六进制，而没有标h的则为十进制</p><p>[1]表示的是偏移地址是8位</p><p>注意SS:SP指向的是栈空间最高地址单元的下一个单元，即栈底的下一个单元</p><p>pop后，原栈中的元素并不是被移动 ，而是被复制，原来栈空间中仍然存放着该元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">assume cs:code,ds:data，ss:<span class="hljs-built_in">stack</span><br>data segment<br><br>        db <span class="hljs-string">&#x27;ibm             &#x27;</span> <br>        db <span class="hljs-string">&#x27;dec             &#x27;</span><br>        db <span class="hljs-string">&#x27;dos             &#x27;</span><br>        db <span class="hljs-string">&#x27;vax             &#x27;</span><br><br>data ends<br><span class="hljs-built_in">stack</span> segment<br><br>    dw <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>      ;定义一个段，用来做栈段，容量为<span class="hljs-number">16</span>个字节   <br><br><span class="hljs-built_in">stack</span> ends<br><br><br>code segment<br><br>start:  mov ax,<span class="hljs-built_in">stack</span><br>        mov ss,ax<br>        mov sp,<span class="hljs-number">16</span>         ;设置栈顶ss:sp指向<span class="hljs-built_in">stack</span>:<span class="hljs-number">16</span>  堆栈使用的时候要指向栈顶<br><br>        mov ax,data       <br>        mov ds,ax        ;数据的ds数据段指向上面定义的数据段<br>        mov bx,<span class="hljs-number">0</span><br><br>        mov cx,<span class="hljs-number">4</span><br><br>    s0: push cx     ;将外层循环的cx压栈<br>        mov si,<span class="hljs-number">0</span><br><br>        mov cx,<span class="hljs-number">3</span>    ;将cx设置成内层循环的次数<br><br>    s:  mov al,[bx+si]<br>        and al,<span class="hljs-number">11011111b</span><br>        mov [bx+si],al<br>        inc si<br>        loop s<br><br>        add bx,<span class="hljs-number">16</span><br>        pop cx       ;从栈顶将cx的值进行恢复<br>        loop s0      ;外层循环的loop指令将cx中的计数值cx中的计数值减<span class="hljs-number">1</span><br>            <span class="hljs-comment">//注意在外层循环中先将cx中标记的值减一，然后又压到栈中避免被覆盖</span><br>        ;执行过程   loop是先将 cx减<span class="hljs-number">1</span>   再判断  cx是否为<span class="hljs-number">0</span>  若不为<span class="hljs-number">0</span>则进行循环直到cx为零的时候为止<br><br>        mov ax, <span class="hljs-number">4</span>c00H<br>        <span class="hljs-type">int</span> <span class="hljs-number">21</span>H<br>code ends<br>end start<br><span class="hljs-comment">//注意观察双重循环的循环变量的使用</span><br></code></pre></td></tr></table></figure><p>在运行当前指令之前，IP就已经先向下进行移动的，故为先移动IP再执行代码</p><p>MOVSB（MOVe String Byte）：即字符串传送指令，这条指令按字节传送数据（MOVSW为以字为单位传送字符串）。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变</p><p>而REP（REPeat）指令就是“重复”的意思，术语叫做“重复前缀指令”。既然是传递字符串，如果程序设计者写成一个字（节）一个字（节）地传送，会显得相当繁琐。因此有必要用一个寄存器来控制串长度，用少量的代码达到一次性传送的目的。这个寄存器就是CX，指令每次执行前都会判断CX的值是否为0（为0结束重复，不为0，CX的值减1），以此来设定重复执行的次数。因此设置好CX的值之后就可以用REP MOVSB了</p><p>CLD（CLear Direction flag）则是清方向标志位，也就是使DF的值为0，在执行串操作时，使地址按递增的方式变化，调整当前指针的执行方向。这条指令与STD（SeT Direction flag）的执行结果相反（指针方向递减），即置DF的值为1</p><h4 id="ADD和ADC的区别："><a href="#ADD和ADC的区别：" class="headerlink" title="ADD和ADC的区别："></a>ADD和ADC的区别：</h4><p>ADD是普通的加法指令，ADC是带进位的加法指令</p><p>两者的格式都为：ADD&#x2F;ADC source，destination<br>将源操作数的值与目标操作数的值相加，并将运算结果放在目标操作数指示的位置。并根据相加结果设置标志寄存器CF,PF,AF,ZF,SF,OF<br>唯一的不同是，ADC执行加法运算时，会将CF位的值一起加到目标操作数中。所以ADC常用于处理以下情况：<br>如果必须处理非常大的、不能存放到双字数据长度（ADD可以使用的最大长度）中的整数，可以把值分割为多个双字数据元素，并且对每个元素执行独立的加法操作。<br>为了正确完成这个操作，必须检测每个加法操作的进位标志，如果进位标志被设置为1，就必须进位到下一对相加的数据元素。<br>ADC指令执行两个无符号或者带符号整数值的加法，并且把前一个ADD指令产生的进位标志的值包含在其中。ADC指令也按照操作结果正确地设置进位和溢出标志</p><p>8086CPU不保证对栈的操作不会越界，需要用户自己管理</p><p>操作数的偏移地址存放在寄存器当中，并且只有SI,DI,BX,BP可作为间接寻址寄存器</p><p>8086CPU对于段使用的默认约定：</p><ul><li>取指令时只能使用CS段</li><li>压栈和出栈只能使用SS段</li><li><strong>串操作中的目的串只能使用ES段</strong></li><li>只要有BP寄存器出现，操作室就在当前的堆栈段，使用堆栈段寄存器SS</li><li>只要有BS，SI，DI，操作数就在当前数据段，使用数据段寄存器DS</li></ul><p>包含在两个单引号之间的一连串ASCII字符即为字符串常量</p><p>使用add等运算指令会影响标志位，但是使用算术运算符不会影响标志位</p><p>逻辑运算符和逻辑指令助记符形式相同但是表达的含义不相同</p><p>注意看PPT中的运算符各种优先级</p><p>注意定义变量时，变量的存储实际长度要和定义的长度保持一致</p><p>如果字符串的长度超过两个字符，那么数据定义的伪指令只能使用DB</p><p>地址变量定义伪指令只能使用DW和DD</p><p>data segement use16这句指的是，数据段采取16位来存取数据段中的数据。如果use32则是指用32位来存取数据段中的数据。具体的16还是32，根据你编程面向的cpu类型是16位的还是32位的</p><p>如果两个数据的类型不匹配，则需要使用PTR进行强制转换</p><p>在8086中除了寄存器以外，存储器操作数（等价为存储器地址（存储单元地址））指的是，相关的存储单元没有名称，只有相应地址</p><p>目的操作数和源操作数不能同时是存储器操作数</p><p>立即数不能用于乘法指令</p><p>一个存储单元是一个字节</p><p>数码0～9：30H～39H</p><p>大写字母A～Z：41H～5AH</p><p>小写字母a～z：61H～7AH</p><p>ASCII码为0dh、0ah分别对应回车和换行控制字符</p><p>在8086处理器中，对应每个物理存储单元都有一个唯一的20位编号，就是物理地址，从00000H～FFFFFH</p><p>在8086内部和用户编程时，采用的（段基地址 : 段内偏移地址）的形式称为逻辑地址</p><p>代码段CS（Code Segment）用来存放程序的指令序列。处理器利用CS : IP取得下一条要执行的指令。</p><p>堆栈段SS（Stack Segment）确定堆栈所在的主存区域。处理器利用SS : SP操作堆栈中的数据。</p><p>数据段DS（Data Segment）存放当前运行程序所用的数据。处理器利用DS : EA存取数据段中的数据。</p><p>附加段ES（Extra Segment）是附加的数据段，也用于数据的保存。处理器利用ES : EA存取数据段中的数据</p><p>数据的默认段是安排在数据段，也经常安排在附加段，尤其是串操作的目的区必须是附加段，允许其它段存放数据，数据的存放比较灵活的，实际上可以存放在任何一种逻辑段中，这时，只要明确指明是哪个逻辑段就可以了</p><p>操作码说明计算机要执行哪种操作，它是指令中不可缺少的组成部分，操作数是指令执行的参与者，也是各种操作的对象，我们把寻找数的方式叫做操作数的寻址方式</p><p>DS存放数据段的段地址，存储器中操作数的偏移地址则由各种主存方式得到，称之为有效地址EA。8086的操作数如果在主存中，可以存取它的寻址方式有直接寻址方式、寄存器间接寻址方式、寄存器相对寻址方式、基址变址寻址方式、相对基址变址寻址方式</p><h4 id="常见错误总结："><a href="#常见错误总结：" class="headerlink" title="常见错误总结："></a>常见错误总结：</h4><p>两操作数类型不匹配，cx是字，dl是字节</p><p>IP指令指针禁止用户访问</p><p>立即数不允许传给段寄存器，只能先把立即数传给通用寄存器AX，AX再传给段寄存器</p><p>段寄存器之间不允许传送，即段存储器之间不能相互赋值，只能通过通用寄存器AX中转传送</p><p>两操作数类型不匹配，300是十进制数，转成二进制是字</p><p>目的操作数应为[ SI ]，sp只能配合SS使用，不能作偏移地址指示  mov [sp], ax(7) </p><p>源操作数应为 [BX+DI]  mov ax, bx+di 单纯给出地址值不是具体的数</p><p>立即数不能作目的操作数</p><p>xchg的操作数不能是立即数，其能进行的操作格式为如下</p><p>XCHG CH,AL寄存器之间相互交换，字节操作</p><p>XCHG BX,SI寄存器之间相互交换，字操作</p><p>XCHG [SI],CX 寄存器与寄存器之间交换，字操作 （两个存储单元之间不能进行操作，但是一个存储单元和一个寄存器是可以进行交换的）</p><p>两个操作数不能都是存储单元     SUB  [SI], [DI]</p><p>堆栈的操作数不能是字节量 堆栈的pop或者push量只能是字型数据</p><p>adc的操作数不能是段寄存器   ADC AX, DS（但是ADD AX, DS 是正确的 ）</p><p>DS不能参与算术（+ - 等）运算</p><p>段寄存器之间不能进行运算</p><p>没有确定是字节还是字操作   ADD [SI], 80H</p><p>没有确定是字节还是字操作, 正确形式为SHL BYTE PTR [SI], 1或SHL WORD PTR [SI], 1</p><p>SHL [SI], 1是错误的形式</p><p>当移位位数大于1时，则用CL寄存器值表示</p><p>溢出的判断：正数+正数&#x3D;负数  负数+负数&#x3D;正数</p><ul><li>在不使用段超越前缀的情况下</li></ul><ol><li>如果有效地址中含有BP，则其缺省的段寄存器为SS</li><li>如果有效地址中不含有BP，则其缺省的段寄存器为DS</li></ol><p>短转移：指段内－128～127之间的转移，位移量用一个字节表示</p><p>近转移：指段内±32K之间的转移，位移量用一个字表示</p><p>远转移：指段间1MB范围的转移</p><p>段内转移：指在同一个代码段内的转移，可以是短转移或者近转移</p><p>段间转移：指转移到另外一个代码段，就是远转移</p><p>8086&#x2F;8088CPU的JMP、CALL和INT n指令可以实现段间转移</p><p>寄存器中存放的数据是01序列，不存在电脑自身知道其为无符号数还是有符号数，取决于人为如何规定</p><p>一条指令的源操作数和目的操作数不能同时使用存储器方式进行表示，即源操作数和目的操作数不能都是内存中的数据  易错：ADD [ SI ]  COUNT ，也相当于是两个存储器表示，标号实际上也是在两个存储器中进行操作  标号实际上的存储也是存储器中存储的</p><p>一般不会在[ ] 中存放段名或者变量的方式</p><p>  <img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106153320.png" alt="微信截图_20220106153320"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106153849.png" alt="微信截图_20220106153849"></p><p>注释：以上图片表明，给出的地址值只是给出了数据的最低位的数据所在的地址值，而具体要往高位延续多少取决于该数据的类型</p><p>正数的补码是其本身，负数的补码：先求其绝对值，然后对该绝对值数的二进制进行逐位求反，最后加一</p><p>8位补码能表示的范围是（-128,127）  16位补码能表示的范围是（-32768,32767）</p><p>有符号数（补码形式）的大小比较，注意8000H是分界线，小于该分界线都是正数，大于该分界线的都是负数，正数一定大于负数，正数和正数正常比较，负数和负数可以将负数看成是正数进行比较</p><p>计算机的存储器是以字节为单位的，每个字节能够存储8位的二进制数据</p><p>整数的存储方式为：整数的低位字节存储在存储器的低地址处，高位字节存储在存储器的高地址处</p><p>用于保存CPU状态信息的寄存器称之为标志寄存器</p><p>16位CPU中的标志寄存器是16位，称FLAGS；</p><p>32位CPU中的标志寄存器是32位，称EFLAGS； </p><p>32位的EFLAGS包含了16位FLAGS的全部标志位且向下兼容</p><p>在汇编中可以这样定义变量所指向的地址的内容是另外一个变量所指向的地址</p><p>补码的意义在于有符号数，如果是无符号数的话，即使是正数，其求补码得到的依旧是其本身</p><p>操作数可以存放在：1、CPU内的寄存器 2、主寄存器 3、 IO设备端口</p><p>寻找操作数存放地址的方式称之为寻址方式</p><p>用户不能直接访问IP</p><p>在8086CPU 加电启动或复位后（即 CPU刚开始工作时）CS和IP被设置为CS&#x3D;FFFFH，IP&#x3D;0000H</p><p>即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令<img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106161056.png" alt="微信截图_20220106161056"></p><p>堆栈只能操作字型数据或者双字型数据</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106161351.png" alt="微信截图_20220106161351"></p><p>注意PUSH先改变SP的值，而POP是后改变POP的值</p><p>当使用栈对寄存器的值进行存储时，注意存储的顺序和取出的顺序相反</p><p>寄存器寻址是执行速度最快的寻址方式</p><p>段超越即显式的指出要使用的段寄存器</p><p>寄存器的相对寻址中寄存器的位移量需要是8或16位的位移量</p><p>寄存器相对寻址可以进行段超越</p><p><strong>由基址寄存器(BX或BP)给出</strong> <strong>——</strong> <strong>基址寻址方式</strong></p><p><strong>由变址寄存器(SI或DI)给出</strong> <strong>——</strong> <strong>变址寻址方式</strong></p><p><strong>MOV AX, [BX] [SI]</strong></p><p><strong>MOV AX, [BX+SI]</strong></p><p><strong>MOV AX,</strong> <strong>DS</strong>: <strong>[BP] [DI]</strong></p><p><strong>错误例：[BX+BP]或[SI+DI]是非法搭配</strong></p><p><strong>×</strong> <strong>MOV AX, [BX] [BP]</strong></p><p><strong>×</strong> <strong>MOV AX, [DI] [SI]</strong></p><p>相加后求补码和先求补码后再相加两者的结果一致</p><p>宏的定义是独立的，应当写在所有段的外面</p><p>当指示的地址类型不明确时需要使用ptr进行指定，若存在寄存器等包含了隐含数据类型的就不需要指定，但如立即数存储到主存中就需要指明具体类型</p><p>小段方式：低存低，高存高</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106170519.png" alt="微信截图_20220106170519"></p><p>源操作数和目的操作数不能同时是存储器方式表示</p><p>立即数是没有类型的，不含变量的存储器方式所表示的操作数类型是不明确的，必须用属性定义算法PTR指明操作数的类型</p><p><strong>8086CPU****对段使用的默认约定</strong></p><p><strong>– 取指令时只能用</strong>*CS段</p><p>– <strong>压栈和出栈只能使用SS段</strong>*</p><p>– <strong>串操作中的目的串只能用</strong>ES段</p><p>– <strong>只要有</strong>BP寄存器出现，操作数就在当前的堆栈段使用堆栈段寄存器**SS；</p><p>– <strong>只要有</strong><em>BS,SI,DI</em>，操作数在当前数据段，使用数据段寄存器DS</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106171822.png" alt="微信截图_20220106171822"><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106171707.png" alt="微信截图_20220106171707"></p><p>GT&#x3D;Great Than             &gt;<br>EQ&#x3D;Equal                      &#x3D;<br>GE&#x3D;Great and Equal    &gt;&#x3D;<br>NE&#x3D;Not Equal               ≠<img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106172219.png" alt="微信截图_20220106172219"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106172229.png" alt="微信截图_20220106172229"></p><p>使用？进行定义变量时，虽然没有赋初值，但是仍分配了存储单元</p><p>定义变量时，存储的单元可以比待存储值要大，但是不能比待存储值小</p><p>如果字符串的长度超过了两个字符，那么数据定义只能使用DB（即DW只能用于定义两个字符大小的数据，如’12’）</p><p>地址变量定义只能使用DW 或者  DD</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106190529.png" alt="微信截图_20220106190529"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106190928.png" alt="微信截图_20220106190928"></p><p>有符号数的指令前面往往要加  I</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106192002.png" alt="微信截图_20220106192002"></p><p>一般数据传送指令是不会影响标志位的，除了SAHF，POPF，POPFD这些专门修改标志位的指令</p><p>立即数不能送段寄存器，并且不能用MOV指令改变CS<img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106192645.png" alt="微信截图_20220106192636"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106192636.png" alt="微信截图_20220106192636"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106194041.png" alt="微信截图_20220106194041"><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106193813.png" alt="微信截图_20220106193813"></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信截图_20220106194123.png" alt="微信截图_20220106194123"></p><p>DEC和INC不影响CF的数值</p><p>乘法指令只有单操作数的时候，该操作数不能是立即数</p><p>异或操作：相同就是0，不相同就是1</p><p>在8086处理器中，当使用移位指令时，移位个数只能是1，大部分移位个数超过1时使用CL</p><p>注意在初始化栈的时候要进行初始化栈底</p><p>注意汇编也是从0开始计数</p><p>寄存器的大小不能进行强转</p><p>‘123456’存储的是每一个字符值对应的ASCII值</p><p>短转移：指段内－128～127之间的转移，位移量用一个字节表示</p><p>近转移：指段内±32K之间的转移，位移量用一个字表示</p><p>远转移：指段间1MB范围的转移</p><p>段内转移：指在同一个代码段内的转移，可以是短转移或者近转移</p><p>段间转移：指转移到另外一个代码段，就是远转移</p><p>8086&#x2F;8088CPU的JMP、CALL和INT n指令可以实现段间转移</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="输出参数的方式："><a href="#输出参数的方式：" class="headerlink" title="输出参数的方式："></a>输出参数的方式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;你还有&quot;</span>+(<span class="hljs-number">4</span>-i)+<span class="hljs-string">&quot;次机会输入密码&quot;</span>);<br><span class="hljs-comment">//通过“+”进行连接</span><br>System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, data);<br><span class="hljs-comment">//通过占位符进行连接</span><br></code></pre></td></tr></table></figure><p>在Java中，如果对象没有对应的引用，就会被Java的垃圾回收机制清除</p><p>逆波兰表达式即为后缀表达式，波兰表达式即为前缀表达式</p><p>Java中的方法调用直接或者间接地通过类进行调用，所以方法必须要写在类中</p><p>数组是预先分配空间的，数组的大小不能动态的增长</p><p>前序遍历中序遍历后序遍历取决于父节点遍历的时候</p><p>注意在不同类中写的同名方法，通过对象调用不同的方法</p><h4 id="for循环的判断顺序和特殊形式"><a href="#for循环的判断顺序和特殊形式" class="headerlink" title="for循环的判断顺序和特殊形式"></a>for循环的判断顺序和特殊形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(A;B;C)&#123;   <span class="hljs-comment">//每次循环开始是 A -&gt; B</span><br>    D;        <span class="hljs-comment">//循环过程中则是 D -&gt; C -&gt; B</span><br>&#125;<br><span class="hljs-comment">/*for循环的特殊形式 */</span><br><span class="hljs-comment">/*for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体*/</span><br> <span class="hljs-type">int</span>[] integers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : integers) &#123;<br>     System.out.println(i);<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="Java中处理多位数的方法"><a href="#Java中处理多位数的方法" class="headerlink" title="Java中处理多位数的方法"></a>Java中处理多位数的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">keepNum</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">//keepNum本身是一个字符串</span><br>keepNum = keepNum + ch;  <span class="hljs-comment">//将字符串和后续的字符粘合</span><br><span class="hljs-keyword">if</span> (index == expression.length() - <span class="hljs-number">1</span>)<br>&#123;<br>    numStack.push(Integer.parseInt(keepNum));<br>    <span class="hljs-comment">//通过Integer本身自带的parseInt方法将字符串转化为int类型</span><br> &#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operStack.isOper(expression.substring(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span>).charAt(<span class="hljs-number">0</span>)))<br>&#123;<br> numStack.push(Integer.parseInt(keepNum));<br> keepNum = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">//若所给的字符串本身带有空格的话则可以通过分割直接获得相应的数字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getListString</span><span class="hljs-params">(String suffixExpression)</span><br>&#123;<br>    String[ ] split = suffixExpression.split(<span class="hljs-string">&quot; &quot;</span>);<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-keyword">for</span>(String ele : split)<br>    &#123;<br>    list.add(ele);<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><ul><li>src里边存的是源文件（.java），即人能看懂的文件</li><li>bin里边存的是字节码文件（.class），就是编译后的文件</li></ul><h4 id="方法参数是引用类型和基本类型的区别"><a href="#方法参数是引用类型和基本类型的区别" class="headerlink" title="方法参数是引用类型和基本类型的区别"></a>方法参数是引用类型和基本类型的区别</h4><ul><li>方法参数是基本类型时，传递的是值。 </li><li>方法参数是引用类型时，传递的是内存地址值</li></ul><h4 id="常见编码集的使用知识-编码集—解码和编码"><a href="#常见编码集的使用知识-编码集—解码和编码" class="headerlink" title="常见编码集的使用知识[编码集—解码和编码]"></a>常见编码集的使用知识[<a href="https://blog.csdn.net/u010359398/article/details/81045531">编码集—解码和编码</a>]</h4><h4 id="单向链表和环形链表的注意事项"><a href="#单向链表和环形链表的注意事项" class="headerlink" title="单向链表和环形链表的注意事项"></a>单向链表和环形链表的注意事项</h4><p>​                 <strong>front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变</strong></p><p><img src="C:\Users\小赵同学\AppData\Roaming\Typora\typora-user-images\image-20210804172421026.png" alt="image-20210804172421026"></p><ul><li><p>单向链表中判断队列为空的条件是：front &#x3D;&#x3D; rear</p></li><li><p>单向链表中判断队列为满的条件是：rear  &#x3D;&#x3D; maxSize - 1 (单向队列中的只能使用一次)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//环形链表中的判断是否为空和是否为满</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">// 表示数组的最大容量</span><br><span class="hljs-comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span><br><span class="hljs-comment">//front 的初始值 = 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front; <br><span class="hljs-comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span><br><span class="hljs-comment">//rear 的初始值 = 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear; <span class="hljs-comment">// 队列尾</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr; <span class="hljs-comment">// 该数据用于存放数据, 模拟队列</span><br><br><span class="hljs-comment">// 判断队列是否满</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> (rear  + <span class="hljs-number">1</span>) % maxSize == front;<br>&#125;<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> rear == front;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="排序方法稳定性的解释"><a href="#排序方法稳定性的解释" class="headerlink" title="排序方法稳定性的解释"></a>排序方法稳定性的解释</h4><ul><li>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的，否则称为不稳定的</li></ul><p>有时为了调用方便，可能重新写一个重载（同名）方法，减少所需要的参数，达到简便的目的</p><p>删除排序二叉树的左枝和右枝均可</p><p>通过左右单旋转以及双旋转将非平衡二叉树转化成平衡二叉树（AVL树）</p><p>树的度是其中结点的度数的最大值</p><p>2-3树中只有两个数据的结点能有三个子结点，同理2-3-4树中只有三个数据的结点才能有四个子结点</p><p>注意深度优先遍历和广度优先遍历都是目的是为了遍历图，所以只要将图中的所有节点遍历一遍即可</p><p>往往关键词被横线划掉表示过时的用法</p><p>可变长参数实际上传入的是一个数组</p><p>队列是先进先出，栈是先进后出</p><p>环形队列只能使用最大长度减一的容量，因为要使用一个多余的位置来保证当front &#x3D;&#x3D; rear时仍表示的是队列为空</p><p>线性表要存放相同的数据类型</p><p>C语言中需要手动调用free( )方法来进行释放内存，回收数据对象</p><p>数组本身不能完成插入的操作，实际上数组的插入和删除需要手动编写代买来使得其余元素后移或前移</p><p>线性表物理结构分类：1、顺序存储结构  2、链式存储结构</p><p>栈的主要实现关键是用top指针来标记栈顶，压入数据和弹出数据都通过top实现</p><p>多层循环之间的时间复杂度是相乘的关系，并且所谓对数阶指数阶的形成在于对循环变化条件的控制，若对于变量每次都是乘二倍，则所需要循环的次数即为对数阶</p><p><strong>线性表长度和数组长度区别：</strong></p><ul><li>数组的长度是存放线性表的存储空间的长度</li><li>线性表的长度是线性表中数据元素的个数</li><li>在任意时刻，线性表的长度应该小于等于数组的长度</li></ul><h4 id="获取线性表第n个元素的方法是LOC-a-n-c"><a href="#获取线性表第n个元素的方法是LOC-a-n-c" class="headerlink" title="获取线性表第n个元素的方法是LOC(a)+n*c"></a>获取线性表第n个元素的方法是LOC(a)+n*c</h4><ul><li>通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是使用相同的时间。那么我们对每个线性表位置的存入或者取出数据都是相同的时间，即为一个常数，用算法复杂度的概念而言，它的存取时间性能是O(1)。我们通常把具有这一特点的存储结构称之为随机存取结构</li></ul><h3 id="线性表的优缺点："><a href="#线性表的优缺点：" class="headerlink" title="线性表的优缺点："></a>线性表的优缺点：</h3><p><strong>优点：</strong>无需为表示表中元素之间的逻辑关系而增加额外的存储空间；可以快速的存取表中任意位置的元素。</p><p><strong>缺点：</strong>插入和删除操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；会造成存储空间的“碎片”</p><h2 id="链表的使用："><a href="#链表的使用：" class="headerlink" title="链表的使用："></a>链表的使用：</h2><ul><li>存储数据元素的信息称之为数据域</li><li>存储直接后继位置的域称之为指针域</li><li>指针域中存储的信息称之为指针或者链</li><li>数据域和指针域构成数据元素的存储映像，称为结点</li></ul><p>每个结点中只包含一个指针域，称之为<strong>单链表</strong>，链表中第一个结点的存储位置称之为头指针，有时为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称之为头结点。头结点的数据域可以不存储任何信息，但也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针；</p><p><strong>C语言：</strong>具有指针，可以很容易的操作内存中的地址和数据，这比其他高级语言更为灵活方便</p><p>**Java、C#:**不使用指针，但是启用了对象引用机制，从某种角度上也间接实现了指针的某些作用</p><p><a href="https://blog.csdn.net/qq_41028985/article/details/82859199">头插法和尾插法详解</a>  插入节点中没有实际分配内存的都可以看做是一个标记，看做是一个指针标记</p><p><strong>递归调用规则：</strong></p><ul><li>当程序执行到一个方法时，就会开辟一个独立的空间(栈)，在栈区不断向上叠加</li><li>每个空间的数据(局部变量)，是独立的.</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，即出现死递归</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ul><p><strong>度量一个程序(算法)执行时间的两种方法：</strong></p><ul><li>事后统计的方法：这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</li><li>事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优</li></ul><h4 id="树、数组、链表分析："><a href="#树、数组、链表分析：" class="headerlink" title="树、数组、链表分析："></a>树、数组、链表分析：</h4><p><strong>数组存储方式的分析：</strong></p><p>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度</p><p>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 </p><p><strong>链式存储方式的分析：</strong></p><p>优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)</p><p>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) </p><p><strong>树存储方式的分析：</strong></p><p>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度</p><h4 id="二叉树的分类："><a href="#二叉树的分类：" class="headerlink" title="二叉树的分类："></a>二叉树的分类：</h4><p><strong>满二叉树：</strong>如果该二叉树的所有叶子节点都在最后一层，并且结点总数&#x3D; 2^n -1 , n 为层数，则我们称为满二叉树</p><p><strong>完全二叉树：</strong>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</p><p><strong>二叉树的所谓前序后序中序遍历</strong>是相对于父节点的遍历时间而言的的</p><p><strong>单向链表和二叉树的特点：</strong>由于其二者的链表指针都是只能指向后继结点而不能指向前驱结点，所以当进行删除结点的操作时，都需要找到待删除结点的上一个结点而不是直接让指针指向待删除结点</p><p><strong>顺序存储二叉树的特点:</strong> </p><ul><li>顺序二叉树通常只考虑完全二叉树 </li><li>第 n 个元素的左子节点为 2 * n + 1</li><li>第 n 个元素的右子节点为 2 * n + 2</li><li>第 n 个元素的父节点为 (n-1) &#x2F; 2</li><li>n : 表示二叉树中的第几个元素</li></ul><p><strong>大顶堆：</strong>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆</p><p><strong>小顶堆</strong>：每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p><p><strong>注意 :</strong> 没有要求结点的左孩子的值和右孩子的值的大小关系，一般升序采用大顶堆，降序采用小顶堆</p><p><strong>赫夫曼树(Huffman Tree)：</strong></p><ul><li><p>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度</strong>(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树、霍夫曼树 </p></li><li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</p></li><li><p><strong>路径和路径长度：</strong>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 </p></li><li><p><strong>结点的权及带权路径长度：</strong>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权</p></li><li><p><strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积 </p></li><li><p><strong>树的带权路径长度：</strong>树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树WPL 最小的就是赫夫曼树 </p></li><li><p>注意赫夫曼树只有叶子结点才是原来数组中存放的真实数据，其余非叶子结点均为叶子结点求和得到的“副产物”</p></li></ul><h4 id="赫夫曼编码："><a href="#赫夫曼编码：" class="headerlink" title="赫夫曼编码："></a>赫夫曼编码：</h4><ul><li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)是一种编码方式, 属于一种程序算法 </li><li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 </li><li>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li><li>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码（赫夫曼编码满足前缀编码）</li><li>（受相同权值的树放置位置前后不同）赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的</li></ul><h4 id="赫夫曼编码压缩文件的注意事项："><a href="#赫夫曼编码压缩文件的注意事项：" class="headerlink" title="赫夫曼编码压缩文件的注意事项："></a>赫夫曼编码压缩文件的注意事项：</h4><ul><li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt </li><li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)</li><li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.</li></ul><p><strong>二叉排序树：</strong>BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><p>所谓的前序中序后序线索化二叉树实际上其对应的前驱结点和后继结点是根据前序中序后序遍历后所得到的数组来确定</p><p>由于使用了线索化二叉树的方式，导致正常的遍历二叉树的方法不适用于线索化二叉树，而且前序线索化二叉树要用前序二叉树的方法去遍历，中序线索化二叉树要用中序二叉树的遍历方法</p><p><strong>斐波那契查找的优势：</strong>斐波那契查找的时间复杂度还是O(log 2 n )，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定</p><p>对数组进行扩容，如果相邻的内存中没有位置了，则重新找到另一块完整大小的数组位置</p><p>大O计数法实际上是指的是最糟糕情况下的速度</p><p>D&amp;C指的是分而治之的思想算法</p><p>函数调用也需要分配内存，并且调用另一个函数时，当前函数暂停并处于未完成状态</p><p>栈包含未完成的函数调用，每个函数调用都包含还未检查完的数据，递归保存了这些未完成的函数调用的状态数据</p><p>设计递归：1、找出简单的基线条件  2、确定如何缩小问题的规模，使其符合基线条件</p><p>c是算法所需的固定时间量，被称为常量，在查找大量数据时，即使简单查找的常量小，二分查找的速度还是快得多，常量根本没有什么影响 但有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此速查找的常量比合并查找小，因此如果它们的运行时间都为O(nlog n)，快速查找的速度将更快。实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多</p><p>关于递归函数调用的时间复杂度，需要考虑递归的函数层数，即调用的栈的高度，以及每层需要的时间，二者相乘所得到的时间复杂度即为对应的时间复杂度</p><p>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中</p><p>散列表适合的情况：仿真映射关系；防止重复；缓存&#x2F;记住数据，以免服务器再通过处理来生成它们</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20210926202341.png" alt="微信图片_20210926202341"></p><p><strong>散列表避免最糟糕情况需要的条件：</strong>较低的填装因子（散列表包含的元素数除以位置总数）；良好的散列函数</p><p>装填因子越低，发生冲突的可能性越小，散列表的性能越高  一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度（调整长度的开销很大，要避免这样的操作）</p><p>你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现，并且散列表非常适合用于防止重复</p><p>广度优先搜索适用的范围：</p><ul><li>从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）</li><li>从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）</li></ul><p>广度优先的查找方法时注意查找过的元素注意标注为已查找（例如只有你和Bob两个人，在查找朋友的时候你们两个会来回查找，最后导致循环死循环）</p><p>如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。这被称为<strong>拓扑排序</strong></p><p><strong>狄克斯特拉算法步骤：</strong></p><ul><li>找出最便宜的节点，即可在最短时间内前往的节点</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销</li><li>重复这个过程，直到对图中的每个节点都这样做了</li><li>计算最终路径</li></ul><p><strong>狄克斯特拉算法注意：</strong></p><ul><li>如果有负权边，就不能使用狄克斯特拉算法</li><li>狄克斯特拉算法只适用于有向无环图</li></ul><p><strong>贪婪算法：</strong>每步都采取最优的做法，即每步都选择局部最优解，最终得到的就是全局最优解 。显然，贪婪算法并非在任何情况下都行之有效，但它易于实现，当只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近</p><p><strong>NP问题的特点：</strong>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢</p><ul><li>涉及“所有组合”的问题通常是NP完全问题</li><li>不能将问题分成小问题，必须考虑各种可能的情况 这可能是NP完全问题</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题</li></ul><p>背包（动态规划）问题的刻度取决于物体所占据的最小“重量”</p><p>注意，虽然动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题但<strong>仅当每个子问题都是离散的</strong>，即不依赖于其他子问题时，动态规划才适用</p><p>动态规划问题所计算得到的最优解可能会使得背包的容量没有完全用完（有个3.5磅的超大钻石，背包4磅，其余最小的物体也得1磅）</p><p>在C语言中数组必须静态分布，在创建的时候就要给定长度，java是定义数组的时候不能声明其大小，但是在使用new关键词的时候需要指明大小（确定开辟的内存大小）java当中不允许下标越界，否则会抛出下标越界异常</p><p><strong>波兰表达式和逆波兰表达式有个好处，就算将圆括号去掉也没有歧义</strong></p><p><strong>中缀表达式转后缀表达式：</strong>如果遇到数字就直接输出，如果遇到符号就判断其和栈顶符号的优先级，是右括号或者优先级不高于栈顶符号，则栈顶符号依次出栈并输出，<strong>然后将当前符号进栈</strong>，直到最终完全输出后缀表达式为止</p><p>由于链表无法使用二分查找来找到待插入元素的所在位置，所以使用<strong>跳跃表</strong>（<a href="https://blog.csdn.net/qpzkobe/article/details/80056807">跳跃表的原理及实现</a>）的形式来代替</p><p>子串是必须连续的字符串，子序列是可以不连续的字符串</p><p><strong>动态规划的特点：</strong></p><ul><li>需要在给定约束条件下优化某种指标时，动态规划很有用</li><li>问题可分解为离散子问题时，可使用动态规划来解决</li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ul><p><strong>OCR</strong>指的是<strong>光学字符识别</strong>（optical character recognition）</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211013185646.png" alt="微信图片_20211013185646"></p><p>SHA是<strong>局部不敏感的</strong>，如果你修改其中的一个字符，再计算其散列值，结果将截然不同，有时候，你希望结果相反，即希望散列函数是局部敏感的。在这种情况下，可使用<strong>Simhash</strong>。如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的<strong>相似程度</strong>，这很有用！</p><p>只有一个节点的树高度为1<br>后序遍历的遍历结果可以从叶子节点开始<br>先序遍历和后序遍历任意一个结合中序遍历即可还原出二叉树，而先序遍历和后序遍历</p><p>虽然在<strong>单旋转</strong>过程中没有修改父节点的子节点，但是在<strong>双旋转</strong>的函数中修改了对应的子节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//单旋转过程中没有修改父节点的子节点</span><br>node* <span class="hljs-title function_">LL</span><span class="hljs-params">(node *root )</span>&#123;<br>    node *tmp;<br>    tmp = root -&gt; left;<br>    root -&gt; left = tmp -&gt; right;<br>    tmp -&gt; right = root;<br>    <span class="hljs-keyword">return</span>   tmp;  <br>&#125;<br><span class="hljs-comment">//双旋转的函数中修改了对应父节点的子节点</span><br>node* <span class="hljs-title function_">LR</span><span class="hljs-params">(node *root )</span>&#123;<br>    root -&gt; left = RR(root -&gt; left);<br>    <span class="hljs-keyword">return</span> LL(root);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>B树和B+树的区别：</strong><a href="https://blog.csdn.net/z_ryan/article/details/79685072">点击！</a></p><p>Advantages of B+ trees:</p><ul><li>Because B+ trees don’t have data associated with interior nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node.</li><li>The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves.</li></ul><p>Advantage of B trees:</p><ul><li>Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly.</li></ul><p>设计递归相关算法的时候首先写出递归出口的情况</p><p><strong>AVL树的旋转分类：</strong></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\v2-58c02894bce9e580481c075efc35f226_r.jpg" alt="v2-58c02894bce9e580481c075efc35f226_r"></p><p>LL型：之所以叫LL型即在出现高度问题的最低结点(n)左节点的左子树上出现了高度差距</p><p>处理方式：对节点 <strong>n</strong> 右旋一次即可</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\v2-acc2de5f4d30d41a6b39b0c5a9b2dbbe_r.jpg" alt="v2-acc2de5f4d30d41a6b39b0c5a9b2dbbe_r"></p><p>LR型：之所以叫LR型即在出现高度问题的最低结点(n)左节点的右子树上出现了高度差距</p><p>处理方式：先对 <strong>i</strong> 进行一次左旋再对 <strong>n</strong> 进行一次右旋</p><p><strong>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义</strong></p><p>大O表示法：算法的时间复杂度通常用大O符号表述，定义为 **T[n] &#x3D; O(f(n)) **。称函数T(n)以f(n)为界或者称T(n)受限于f(n)</p><p>如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”</p><p><strong>递归相关的时间复杂度计算：</strong>如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归的函数中，时间复杂度为T；<strong>则总体的时间复杂度为O(T * depth)</strong></p><p><strong>平均情况时间复杂度计算：</strong>可以理解为求加权时间复杂度，然后化简求和式子即可</p><p>均摊复杂度分析：例如对于容量为 n 的动态数组，前面添加元素需要消耗了 1 * n 的时间，扩容操作消耗  n 时间 ，总共就是 2 * n 的时间，因此均摊时间复杂度为 O(2n &#x2F; n) &#x3D; O(2)，也就是 O(1) 级别了  可得到结论：<strong>一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的</strong></p><p>DAG：有向无环图</p><ul><li>拓扑排序产生一个DAG的节点排序，满足以上条件：如果存在u到v的路径，u应先访问</li><li>有圈图的拓扑排序无定义</li><li>DAG满足条件的拓扑排序不是唯一的</li></ul><p>根据front,rear,maxlength 求队列的长度：**(Q.rear-Q.front+maxlength)%maxlength**</p><p>朴素算法中，当主串和模式串不匹配的时候，主串的 i &#x3D; i - j + 2（加2是因为不仅要回去上一次比较的位置，而且要重新开始比较，故应当往后移动一位）</p><p>利用已经部分匹配的结果加快模式串的滑动速度</p><p>结点的度：结点的子树数目</p><p>树的度：树中各节点的度的最大值</p><p>n度树：树中各节点的度的最大值</p><p>满二叉树：字面意思</p><p>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边</p><p>java中的对象数组实际上可以用C语言中的结构体指针数组来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">arr</span>[<span class="hljs-title">Length</span>]</span><br></code></pre></td></tr></table></figure><p>构造二叉树时，都是通过二叉树的前序遍历或者后序遍历来判断谁是根结点，再结合中序遍历判断结点的左右关系</p><p>由于单纯给出先序遍历创建出来的二叉树不是唯一的，所以需要用分隔符等来标记其空节点的位置来保证生成的二叉树是唯一的</p><p>线索化二叉树分为先序线索化 中序线索化 后序线索化，所谓的前驱或者后继，是对应相关线索化后的前驱和后继，具体实现要取决于其遍历的方式</p><p>为了避免两端的结点由于没有前驱结点和后继结点而导致的线索化二叉树过程中的空指向，增加一个头结点，用于接收多余的两个指针</p><p>线索化二叉树时，对应的遍历方式并没有给出，是在线索化二叉树的过程中不断改变得到的</p><p>在非完全二叉树的情况下，由于下标的数字关系不符合，故结点在存放数据以外还要存放其父节点</p><p>在结点数目相同的二叉树中，完全二叉树是路径长度最短的树，但是注意相同结点路径长度最短的树不一定是完全二叉树（左边的结点移动到右边保持仍为路径长度最短）</p><p>哈夫曼树即带权路径长度最短的树</p><p>满二叉树不一定是哈夫曼树</p><p>带权结点权值越大的离根结点的位置越近</p><p>具有相同带权结点的哈夫曼树不唯一</p><p>利用贪心算法：构造哈夫曼树时优先选择权值较小的叶子结点</p><p>每一次构造结点的时候，把之前的两个最小结点生成的“和结点”也纳入考虑的范畴</p><p>为什么哈夫曼编码能够保证是前缀无重复的编码？由于哈夫曼树中的对应符号都是叶子结点，故没有任意一个结点是另外一个结点的祖先，所以每个叶子结点的编码也就不可能是其它叶子结点编码的前缀</p><p>网：边上有权值的图</p><p>子图：结点是原图结点的子集，边也是原图边的子集则称之为子图</p><p>强连通图是相对于有向图而言的</p><p>有回路的有向图不存在拓扑排序</p><p>非连通图，对每个连通分量依次遍历即可</p><p>广度优先，每新增一个结点，就先把这个节点的所有邻接结点全部遍历完成</p><p>利用队列和辅助数组存放是否访问过进行判断</p><p>最短路径和最小生成树不同，最短路径上不一定包含n个顶点，也不一定包含n-1个边</p><p>将无序二叉树转化为堆的方法：由于所有的叶子结点都已经可以看成是堆了，所以只需要从最后一个非叶子结点不断进行调整，依次向前进行调整即可（又由于完全二叉树的性质，最后一个叶子结点恰为n&#x2F;2）</p><p>快速排序的最好情况是每一次分割都使得原数组分成左右两份</p><p>算法知道的信息多，算法越高效，约束越大，适用范围也越有限，通用性越差</p><p>外部排序和内存访问的特性差别极大：常量内存的直接寻址代价和代价极大的外存随机访问</p><p>只有一个结点的二叉树高度为0</p><p>建堆即对所有的非叶子结点依次进行下滤</p><p>有圈图的拓扑排序无定义</p><p>有向无环图满足条件的拓扑排序不是唯一的</p><p>拓扑排序将有向无环图中的偏序关系转换为线性关系 </p><p>贪婪算法选择的是局部最优或者是局部次优的，并不能保证一定是全局最优的，贪婪算法希望通过局部最优能够产生全局最优</p><p>动态规划算法和贪婪算法常用于最优问题求解，当问题具有重叠子问题和最优子结构时可以采用</p><p>欧几里得算法又称之为辗转相除法：</p><p>求 10 ，25的最大公约数：<br>25 &#x2F; 10 &#x3D; 2 ······5<br>10 &#x2F; 5  &#x3D; 2 ······0<br>所以10，25的最大公约数为5</p><p>利用栈求表达式求值的关键：当某个运算符将要入栈时，若待入栈的运算符优先级小于当前栈顶的运算符，则先弹出栈顶中的符号计算后，<strong>再</strong>将待入栈的运算符入栈</p><p>中缀表达式转后缀表达式的求解和计算中缀表达式类似，但注意弹出符号栈运算符的条件是待入栈的运算符<strong>优先级小于或等于</strong>当前栈顶的运算符，而且只是弹运算符，并不涉及运算</p><p>开放定址法实际上就是先调用hash函数，如果该位置有冲突，就依次根据设定好的序列向后探测（注意增加的值是加到原数据上），并且查找也是同理，调用hash函数后未能找到就依次向后探测</p><p>再散列：当散列表太满，或者说如果装填因子为0.75（默认值），而表中超过75%的位置已经填入元素，就需要对散列表再散列，这个表就会用双倍的桶数自动地进行再散列。桶数是指用于收集具有相同散列值的桶的数目  </p><p>再散列含义之二：提供多个散列函数，当其中一个散列函数获得的地址产生冲突时，使用第二个散列函数来进行获取地址</p><p>公共溢出区：用于解决散列冲突的问题，当出现冲突时，将产生冲突的元素单独存放在公共溢出区中，查找同理，当查找不到时在公共溢出区中查找</p><p>中序遍历如果不采用递归形式进行实现，则需要借助栈来实现</p><p>由于包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生了n-1个结点，所以包含n个叶子结点的哈夫曼树中有2n-1个结点，并且哈夫曼树中的结点度数为0或2，没有度数为1的结点</p><p>强连通图的强连通分量是其自身，但是有向非连通图的强连通分量有多个</p><p>时间复杂度只和存储结构有关，和搜索方式无关</p><p>4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并   n并非越大越好</p><p>当给一棵本来就平衡的AVL树中插入一个新节点P的时候，从节点P到根节点的路径上，每个节点为根的子树的高度都可能增加1，即平衡因子发生改变，所以执行一次插入操作后，都需要沿路径向根节点回溯，修改各节点的平衡因子，而如果遇到了哪一个节点的bf变成2或-2的时候就要进行平衡化处理</p><p>外部排序由于读写操作比较耗时所以要尽量减少IO的次数</p><p>注意外部排序所需的最小IO树并不和哈夫曼树完全相同，最小IO树的分叉数量取决于多路合并的数量，如果是三路合并则分叉数量为3，产生的树即为最佳归并树</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Java编译特点：</p><ul><li>为了分布式系统而生：安全、重用、可移植</li><li>类似C语言的语法结构</li><li>纯面向对象</li><li>非常丰富的库函数</li><li>编译后由JVM解释执行（一处编译，处处执行）</li></ul><p>所有引用类型的默认值都是null</p><p>按位异或:不同就是1，相同就是0</p><p>内部类的权限修饰符？</p><p>匿名类的权限修饰符？</p><p>匿名内部类的权限修饰符？</p><p>成员变量即定义在类中，方法体之外的变量</p><p>每个类都有相应的构造方法，如果没有显式地为类定义构造方法，Java编译器会将自动为该类提供一个默认构造方法</p><p>一个源文件中只能有一个public类；</p><p>源文件的名称应该和public类的类名保持一致</p><p>如果一个类定义在某个包中则这个package语句应该放在源文件的首行</p><p>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</p><p>import语句就是用来提供一个合理的路径，使得编译器可以找到某个类，即帮助编译器找到对应的类所在的路径</p><p>import java.io.*; 含义：命令编译器载入java_installation&#x2F;java&#x2F;io路径下的所有类</p><p>定义新类时，可以用原来的类为基础，借助代码的重用，使得系统变得容易扩展</p><p>子类继承了父类中所有非private成员方法（除了构造方法）和所有非private的成员变量</p><p>如果在子类的构造方法中没有显式的调用父类的构造器，那么在编译过程中会自动调用父类的无参构造器，如果显式调用了构造器就会寻找对应的构造器而不会再调用空参构造器，注意此时如果父类没有空参构造器，那么子类会报错</p><p>重载的特点：1、方法名一致  2、参数不相同（参数个数，类型，顺序不相同均可）</p><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>方法能够在同一个类中或者在其子类中被重载；</li></ul><p>父类引用对象引用子类实例时可以操作被子类继承和重写的方法，但不能操作子类新增的成员变量和方法</p><p>抽象方法只有一个方法名而没有方法体，即方法后面直接跟着一个分号而不是大括号；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p><p>静态变量在程序初始化时被创建，可以被该类的所有实例使用和修改</p><p>只能访问静态变量的方法是静态方法，注意main()也是一个静态方法</p><p>抽象类可以继承接口，并且可以不完全实现接口中的所有抽象方法</p><p>接口的特点：</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字</li><li>接口中可以含有变量，变量会被隐式的指定为 public static final（用 private 修饰会报编译错误）</li><li>接口中的方法会被隐式的指定为 public abstract</li></ul><p><strong>接口与类相似点：</strong></p><ul><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名</li><li>接口的字节码文件保存在 .class 结尾的文件中</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象</li><li>接口没有构造方法接口中所有的方法必须是抽象方法</li><li>接口只能包含static final成员变量</li><li>接口不是被类继承了，而是要被类实现</li><li>接口支持多继承</li></ul><p>接口中也可以放入方法的实现，避免修改实现该接口的类的代码</p><p>接口中也可以放入静态方法，以增加一些帮助性质的工具函数</p><p>java.lang.Comparable, 可以通过Collections.sort或Arrays.sort进行自动排序</p><p>java.io.Serializable, 可以启用其序列化功能</p><p>ISP（Interface Segregation Principle）原则：</p><ul><li>它表明使用多个专门的接口比使用单一的总接口要好 </li><li>一个类对另外一个类的依赖性应当是建立在最小的接口上的</li><li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染</li></ul><p>创建一维数组的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">double</span>[] nums2 = &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>&#125;;<br></code></pre></td></tr></table></figure><p>创建二维数组的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br><span class="hljs-type">int</span>[][] mat = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p>当方法的返回值不为空时，必须使用return</p><p>重载和重写的区别？</p><p>UML会最基本的类图即可？</p><p>输入输出相关知识？</p><p>死锁问题？</p><p>字符串的相关操作方法？</p><p>String类有13个不同的构造函数，可以借助char数组和byte数组作为String对象构造器的参数进行初始化</p><p>String的null和空字符串（” “）是两种不同的字符串</p><p><strong>相等比较的判断：</strong></p><ul><li>&#x3D;&#x3D;比较的是引用而不是比较的值</li><li>equal（Object o）比较的是具体值</li><li>compareTo（）是比较从左往右比较值的大小</li></ul><p><strong>字符串和其他数据类型的转换：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符串转化为其他数据类型</span><br><span class="hljs-type">String</span> <span class="hljs-variable">strInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(“<span class="hljs-number">10</span>”);<br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> Integer.parseInt(strInteger);<br><span class="hljs-type">String</span> <span class="hljs-variable">strFloat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(“<span class="hljs-number">3.14</span>”);<br><span class="hljs-type">float</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Float.parseFloat(strFloat);<br><span class="hljs-comment">//其他数据类型转化为字符串</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14f</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> String.valueOf(num1);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> String.valueOf(num2)；<br></code></pre></td></tr></table></figure><p><strong>声明方法是泛型方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] Array)</span> &#123; &#125;<br><span class="hljs-comment">//放置一个 &lt;E&gt; 该类型参数声明部分在方法返回类型之前，权限修饰符之后</span><br></code></pre></td></tr></table></figure><p>泛型方法体的声明和其他方法一样，注意类型参数只能代表引用型类型，不能是基本类型</p><p>Java泛型的实现方法：擦拭法</p><ul><li>编译器将类型 <T> 视为 Object</li><li>编译器根据 <T> 实现安全的强制转型</li></ul><p>擦拭法实现的泛型特点为：</p><ul><li>不能是基本类型，例如 int</li><li>不能获取带泛型类型的 Class，例如 Pair<String>.class</li><li>不能判断带泛型类型的类型，例如 x instanceof Pair<String></li><li>不能实例化 T 类型，例如 new T( )</li><li>泛型方法要防止重复定义方法，例如 public boolean equals(T obj)</li></ul><p><strong>Java泛型类的继承规则：</strong> </p><p>一个类可以继承自一个泛型类。例如：父类的类型是 Pair<Integer>，子类的类型是 IntPair，可以这么继承：<br>      public class IntPair extends Pair<Integer> { … }</p><p>我们无法获取Pair<T>的 T 类型，即给定一个变量 Pair<Integer> p，无法从 p 中获取到 Integer 类型。</p><p>但在父类是泛型类型的情况下，编译器必须把类型 T（对于 IntPair，就是 Integer 类型）保存到子类的 class 文件中，不然编译器就不知道IntPair 只能存取 Integer 这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair 可以获取到父类的泛型类型 Integer。虽然代码有些复杂</p><p>Java使用通配符来解决泛型限定的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Canvas</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawAll</span><span class="hljs-params">(List&lt;? extends Shape&gt; shapes)</span> &#123;<br><span class="hljs-keyword">for</span>(Shape s: shapes)<br>s.draw(<span class="hljs-built_in">this</span>); <br>&#125;<br>&#125;<br><span class="hljs-comment">//以下两种称之为有界通配符</span><br><span class="hljs-comment">//&lt;? extends T&gt; 上界为T （？是T的子类）</span><br><span class="hljs-comment">//&lt;? super T&gt;   下界为T （？是T的父类）</span><br><br><span class="hljs-comment">//限定c只能是满足Collection的子类</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">printCollection</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123; <br><span class="hljs-keyword">for</span> (Object e : c) &#123; <br>System.out.println(e); <br>&#125; <br>&#125;<br>Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>c.add(“hello”);<br>printCollection(c);<br>Collection&lt;?&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>c.add(“hello”);<br>printCollection(c);<br><br><br></code></pre></td></tr></table></figure><p> 作为方法参数，&lt;? extends T&gt; 类型和 &lt;? super T&gt; 类型的区别在于：</p><ul><li><? extends T>允许调用读方法 T get() 获取 T 的引用，但不允许调用写方法set(T) 传入 T 的引用（传入 null 例外）</li><li><? super T>允许调用写方法 set(T) 传入 T 的引用，但不允许调用读方法 T get( ) 获取 T 的引用（获取 Object 例外）</li><li>一个是 允许读不允许写，另一个是 允许写不允许读。</li></ul><p> <strong>PECS（Producer Extends Consumer Super） 原则：</strong></p><ul><li>如果需要返回 T，它是生产者（Producer），要使用 extends 通配符；</li><li>如果需要写入 T，它是消费者（Consumer），要使用 super 通配符;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;<br>             ...<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; srcSize; i++)<br>                     dest.set(i, src.get(i));   <span class="hljs-comment">// src 是 producer，而 dest 是 consumer</span><br>             &#125;<br>             ...<br>        &#125;       <br><span class="hljs-comment">//需要返回 T 的 src 是生产者，因此声明为 List&lt;? extends T&gt;，需要写入 T 的 dest是消费者，因此声明为 List&lt;? super T&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用通配符解决问题的实例：</strong></p><p>可以使用 Pair&lt;? extends Number&gt; 使得方法接收所有泛型类型为 Number 或 Number 子类的 Pair 类型。当给方法传入 Pair<Integer> 类型时，它符合参数 Pair&lt;? extends Number&gt;类型。这种使用 &lt;? extends Number&gt; 的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型 T 的上界限定在Number 了。除了可以传入 Pair<Integer> 类型，还可以传入 Pair<Double>，Pair<BigDecimal> 等类型，因为 Double 和 BigDecimal 都是 Number 的子类。</p><p><strong>基础数组相对于集合的不足之处：</strong></p><ul><li>长度固定，使用不灵活</li><li>经常出现访问越界的问题ArrayIndexOutOfBounds</li><li>没有现成的接口，得自己实现各种算法</li><li>缺少对元素的访问控制</li></ul><p><strong>集合框架的特点：</strong></p><ul><li>接口和实现类相分离。例如有序表的接口是 List，具体的实现类有ArrayList，LinkedList 等；</li><li>支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：<br>List<String> list &#x3D; new ArrayList&lt;&gt;();     &#x2F;&#x2F; 只能放入 String 类型</li><li>Java 访问集合总是通过统一的方式——迭代器（Iterator）来实现，该做法最明显的好处就在于无需知道集合内部元素的存储方式。</li></ul><p><strong>List的情况分类：</strong></p><ul><li>如果需要进行排序：<ul><li>放入的元素必须正确覆写 equals 方法。例如 JDK 中的 String 和 Integer 等类都已经覆写了 equals 方法</li><li>编写 equals 方法时可以借助 Objects.equals 方法进行判断</li></ul></li><li>如果不需要进行排序：<ul><li>不必覆写 equals 方法</li></ul></li></ul><p><strong>增强for循环和foreach实际上是同一种循环方式</strong></p><ul><li><strong>对于数组</strong>，foreach 循环实际上还是用的普通的 for 循环</li><li><strong>对于集合</strong>，foreach 循环实际上是用的 iterator 迭代器迭代</li></ul><p><strong>集合遍历方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合的遍历方式：</span><br><span class="hljs-comment">//1、for循环  2、增强for循环  3、Iterator接口</span><br>Iterator&lt;String&gt; it=list.iterator(); <br><span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>System.out.println(it.next()); <br>&#125;<br><span class="hljs-comment">//Iterator接口中的方法：</span><br><span class="hljs-comment">//hasNext()  next()  remove(Object o)</span><br><br><span class="hljs-comment">//对于Map的遍历</span><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>map.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>      <br><span class="hljs-comment">//第一种：普遍使用，二次取值</span><br><span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>System.out.println(<span class="hljs-string">&quot;key= &quot;</span>+ key + <span class="hljs-string">&quot; and value= &quot;</span> + map.get(key));<br>&#125;<br><br><span class="hljs-comment">//第二种</span><br>Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>Map.Entry&lt;String, String&gt; entry = it.next();<br>System.out.println(<span class="hljs-string">&quot;key= &quot;</span>+entry.getKey()+<span class="hljs-string">&quot; and value= &quot;</span>+entry.getValue());<br>&#125;<br><br><span class="hljs-comment">//第三种</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;<br>System.out.println(<span class="hljs-string">&quot;key= &quot;</span>+entry.getKey()+<span class="hljs-string">&quot; and value= &quot;</span>+ entry.getValue());<br>&#125;<br>    <br><span class="hljs-comment">//第四种</span><br><span class="hljs-keyword">for</span> (String v : map.values()) &#123;<br>System.out.println(<span class="hljs-string">&quot;value= &quot;</span> + v);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用空参构造器构造出来的集合的初始size为0</p><p>对arraylist使用remove(0)不会使得后面的元素向前移动一位，其他元素所在位置的下角标不变</p><p>Hash集合有很好的存取和查找功能，向集合中加入对象时，会调用hashCode()方法获得哈希码，进而计算出对象在集合中的存放位置，Hash集合要求两个对象用equals()方法比较的结果为true时，它们的哈希码也相等</p><p>TreeSet 和 TreeMap 分别实现了 SortedSet 和 SortedMap 接口，能够对集合中的元素排序</p><ul><li>自然排序（实现Comparable的基础类）：如Integer，Double和String</li><li>自定义排序（实现Comparable或Comparator的自定义类）</li></ul><p><strong>排序方式的比较：</strong></p><p><strong>Comparable</strong>：由需要被排序的类实现，需要实现compareTo()方法</p><p>**Comparator<T>**：由排序器实现，需要实现compare(T x, T y)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Comparable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span>&#123;<br><span class="hljs-type">Customer</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Customer)o;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.name.compareTo(other.getName())&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.name.compareTo(other.getName())&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>&#123;…&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;…&#125;<br>&#125;<br><br><span class="hljs-comment">//Comparator&lt;T&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Customer&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Customer c1, Customer c2)</span>&#123;<br><span class="hljs-keyword">if</span>(c1.getName().compareTo(c2.getName())&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>Set&lt;Customer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Customer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerComparator</span>());<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(“Tom”,<span class="hljs-number">15</span>));<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(“Mike”,<span class="hljs-number">20</span>));<br><br><span class="hljs-keyword">for</span>(Customer c: set)<br>System.out.println(c.getName());<br><span class="hljs-comment">//后者更倾向于使用更加灵活的方式去进行排序和选择排序的方式</span><br></code></pre></td></tr></table></figure><p><strong>数组和集合互相转换：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(array);<br>Object[] array1 = list.toArray();<br>Integer[] array2 = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><strong>枚举类：</strong></p><ul><li>JDK 5 提供了抽象的 java.lang.Enum 枚举类；</li><li>用户自定义的枚举类只需继承 Enum 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Gender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender FEMALE;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender MALE;<br>    …<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;FEMALE, MALE&#125;<br><span class="hljs-comment">// 遍历Gender类的所有常量</span><br><span class="hljs-keyword">for</span>(Gender g: Gender.values())<br>System.out.println(g.ordinal()+” ”+g.name());<br><br><span class="hljs-comment">// 根据 g 的值选择</span><br><span class="hljs-type">Gender</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> Gender.FEMALE;<br><span class="hljs-keyword">switch</span>(g)&#123;<br><span class="hljs-keyword">case</span> FEMALE:<br>System.out.println(“girl”);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> MALE:<br>System.out.println(“boy”);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>System.out.println(“unknown”);<br>&#125;<br><br><span class="hljs-comment">//Java API 中有两个 Enum 类的适配器：</span><br><span class="hljs-comment">//   java.util.EnumSet</span><br><span class="hljs-comment">//   java.util.EnumMap</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;RED,GREEN,BLUE&#125;;<br><br><span class="hljs-comment">// Enum 转为 EnumSet</span><br>EnumSet&lt;Color&gt; colorSet = EnumSet.allOf(Color.class);<br><br><span class="hljs-comment">// Enum 转为 EnumMap</span><br>EnumMap&lt;Color,String&gt; colorMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;Color,String&gt;(Color.class);<br>colorMap.put(Color.RED,”红色”);<br>colorMap.put(Color.GREEN,”绿色”);<br>colorMap.put(Color.BLUE,”蓝色”);<br><br></code></pre></td></tr></table></figure><p><strong>使用集合的注意事项：</strong></p><ul><li>根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们不想重复，我们应该使用Set </li><li>HashSet 和 HashMap 具有较好的性能，是 Set 和 Map 的首选实现类，只有需要排序时才考虑 TreeSet 和 TreeMap。ArrayList 和 LinkedList 各有优缺点，应视情况选择</li><li>如果我们能够估计到存储元素的数量，需指定初始容量</li><li>多用接口声明集合变量，它允许我们轻易地替换具体实现类</li><li>使用泛型，避免在运行时出现ClassCastException</li><li>使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()</li><li>尽可能使用Collections实用类提供的方法，而非编写自己的实现</li></ul><p><strong>Java中的异常：</strong></p><p>Java 中的异常命名为 Exception，是 exceptional event 的缩写，指的是程序运行时发生的会中断程序正常流程的异常事件，例如无法打开文件，访问数组越界等等。异常是一种类（class），因此本身带有类型信息。异常可以在任何地方抛出，只需要在上层被捕获即可，这样就和方法调用分离了。</p><p>异常处理分离了一般代码和异常处理代码，更易阅读和维护；对异常的捕获和处理会增加程序的健壮性，使程序不因发生异常而终止。</p><p><strong>Java中异常的分类：</strong></p><ul><li>检查性异常（checked exceptions）：程序正确，由于外在环境条件不足引发。Java编译器强制要求处理这类异常<ul><li>又称非运行时异常（RuntimeException 以外的异常），属于 Exception 类及其子类。Java 编译器强制要求处理这类异常，如果不处理，程序就不能编译通过。如 IOException、SQLException等异常，一般情况下不自定义检查异常。</li></ul></li><li>运行时异常（runtime exception）：程序存在bug，需修改程序<ul><li>都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等，对于这些异常，程序中可以选择捕获处理，也可以不处理。这些异常通常由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。这种异常的特点: 1）方法定义中无需 throws 声明也可抛出此类异常，调用者也无需处理此异常；2）运行时期异常一旦发生，需要编程人员修改源代码。</li></ul></li><li>运行时错误（error）：极少见情况，非程序本身问题<ul><li>Error 指程序在运行期间发生了某种错误(XxxError)，对于 Error 通常没有具体的处理方式，其发生往往是系统级别的问题，它是由JVM产生和抛出的，例如：OutOfMemoryError（内存耗尽）、NoClassDefFoundError（无法加载某个类）、StackOverflowError（栈溢出）。此时 JVM 一般会选择线程终止，对此我们只能修正代码。</li></ul></li></ul><p><strong>异常的体系：</strong></p><p>Thorwable 类（表示可抛出）是所有异常和错误的超类，两个直接子类为 Error 和 Exception，分别表示错误和异常</p><p>其中异常类 Exception 又分为运行时异常(RuntimeException)和非运行时异常，这两种异常有很大的区别，前者是所谓的 “不检查异常 Unchecked Exception”，后者属于 “检查异常 Checked Exception”</p><p><img src="D:\img\图片1.png" alt="图片1"></p><p><strong>使用throw和throws关键词实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;要访问的arr数组不存在&quot;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);<br><span class="hljs-comment">//throws使用</span><br>修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>… &#123; &#125;<br><span class="hljs-comment">//用于标明该方法可能抛出的异常种类都有什么</span><br></code></pre></td></tr></table></figure><p><strong>会抛出某个异常的方法必须满足以下两条要求之一：</strong></p><ul><li>有一个 try 语句来捕获该异常</li><li>某个方法声明其抛出该异常</li></ul><p><strong>检查性异常必须被处理且处理方式有：</strong>1、可由产生异常的代码块自行处理  2、丢给别人处理</p><p><strong>捕获异常并处理的实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeList</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//不用使用throws?</span><br>    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;OutFile.txt&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>            out.println(<span class="hljs-string">&quot;Value at: &quot;</span> + i + <span class="hljs-string">&quot; = &quot;</span> + list.get(i));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) &#123;<br>        System.err.println(<span class="hljs-string">&quot;Caught IndexOutOfBoundsException: &quot;</span> +  e.getMessage());                      <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        System.err.println(<span class="hljs-string">&quot;Caught IOException: &quot;</span> +  e.getMessage());                        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Closing PrintWriter&quot;</span>);<br>            out.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;PrintWriter not open&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意可以编写多个catch来匹配不同的异常类型，并且不同的catch中不能使用相同的异常类型</span><br><span class="hljs-comment">//如果存在子父类关系的异常，子类异常需要优先处理</span><br><br><span class="hljs-comment">//JDK 7 之后，一个 catch 块可以处理多个类型的异常</span><br><span class="hljs-keyword">catch</span> (IOException | SQLException ex) &#123;<br>    logger.log(ex);<br>    <span class="hljs-keyword">throw</span> ex;<br>&#125;<br><br><span class="hljs-comment">//特殊的情况下没有catch语句，因为没有 catch，所以会被 JVM 抛出。异常没有被捕获处理的，但是功能所开启资源需要进行关闭，所以需要finally 关闭资源</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//释放资源</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//注意在这行代码中，array1是一维数组，array是二维数组</span><br><span class="hljs-type">byte</span>[] array1， array2[];<br></code></pre></td></tr></table></figure><p><strong>重载方法中的异常处理：</strong></p><ul><li>子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常，或者该异常的子类，或者不声明</li><li>父类方法声明多个异常时，子类覆盖时只能声明这些异常的子集</li><li>父类方法没有异常声明时，子类覆盖时无法声明异常，但是在这种情况下，在子类覆盖方法中仍然可能发生了异常。此时因为无法进行 throws 声明，只能用 catch 捕获异常。如果问题处理不了，则在 catch 中继续 throw 抛出，但是只能将异常转换成 RuntimeException 子类抛出</li></ul><p><strong>异常中的常用方法：</strong></p><ul><li>调用这些方法的对象都是异常类的实例<ul><li>getMessage 方法：返回该异常的详细信息字符串，即异常提示信息</li><li>toString 方法：返回该异常的名称与详细信息字符串</li><li>printStackTrace 方法：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置</li></ul></li></ul><p><strong>自定义异常类的注意事项：</strong></p><ul><li>可抛性——即可以被 throw 关键字操作；</li><li>每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，借助父类进行异常信息的封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参考 NullPointerException 异常类源代码(仍是Java中自带的异常类)：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullPointerException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NullPointerException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();  <span class="hljs-comment">// 调用父类构造方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NullPointerException</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-built_in">super</span>(s);  <span class="hljs-comment">// 调用父类具有异常信息的构造方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//自定义编写的异常类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FakeAgeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    FakeAgeException() &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    FakeAgeException(String message) &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    Person(String name,<span class="hljs-type">int</span> age) <span class="hljs-keyword">throws</span> FakeAgeException &#123;<br>        <span class="hljs-comment">//加入逻辑判断。</span><br>        <span class="hljs-keyword">if</span>(age&lt;<span class="hljs-number">0</span> || age&gt;<span class="hljs-number">200</span>)        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FakeAgeException</span>(age+<span class="hljs-string">&quot;,年龄数值非法&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//构造函数抛出的这个 FakeAgeException 为什么继承了 Exception呢？而不是继承了 RuntimeException 呢？</span><br><span class="hljs-comment">//之所以继承 Exception，因为我们希望使用 throws 声明（必须如此才能抛出异常），借助它告知调用者进行捕获，问题处理后该程序会继续执行。</span><br><br><span class="hljs-comment">//如果继承 RuntimeExcpetion，则不需要 throws 声明，因为这时根本就不知道有问题（程序运行时才知道）。一旦发生这类异常，整个程序会停掉，并由 JVM 将信息显示到屏幕，让调用者看到问题，修正代码。</span><br><br><span class="hljs-comment">//显然，我们所面对的问题并不会主动停止整个程序：虽然逻辑上有问题，但不会导致 JVM 出错，所以应该继承 Exception。</span><br><br></code></pre></td></tr></table></figure><p><strong>异常处理的语法规则：</strong></p><ul><li>try 语句块不能单独存在，catch 语句块可以有一个或多个，finally 语句块最多一个；</li><li>try-catch-finally 均不能单独使用；</li><li>有多个catch块时，Java会按顺序匹配，如找到匹配则不会继续执行后面的catch；</li><li>throw语句后的语句不会被执行；</li></ul><p><strong>异常处理的规则：</strong></p><ul><li>避免过大的 try 语句块；</li><li>细化异常的类型，不要都用 Exception；</li><li>自己能处理的异常不要抛给别人；</li><li>不要用 try-catch 实现控制流程的跳转；</li><li>尽可能重用已经存在的异常类</li></ul><p><strong>cmd中，执行java命令与javac命令的区别：</strong></p><ul><li>javac：是编译命令，将java源文件编译成.class字节码文件 例如：javac hello.java 将生成hello.class文件</li><li>java：是运行字节码文件；由java虚拟机对字节码进行解释和运行。例如：java hello</li></ul><p>java中的值类型都是无符号类型</p><p>两个变量相加，先对类型进行提升，然后运算，再将运算结果赋值</p><p>即如果byte d &#x3D; c + b;会报错，因为编译器自动将c+b看做是int，需要强转byte d &#x3D; （byte ）c + b;</p><p><strong>java自动类型转换：</strong></p><ul><li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型</li><li>否则，如果其中一个操作数是float类型，另一个将会转换为float类型</li><li>否则，如果其中一个操作数是long类型，另一个会转换为long类型</li><li>否则，两个操作数都转换为int类型</li><li>特殊的：final修饰的short, char变量相加后不会被自动提升</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">byte</span> b1=<span class="hljs-number">1</span>,b2=<span class="hljs-number">2</span>,b3,b6; <br> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> b4=<span class="hljs-number">4</span>,b5=<span class="hljs-number">6</span>; <br> b6=b4+b5;     <span class="hljs-comment">//不会发生编译错误</span><br> b3=(b1+b2);   <span class="hljs-comment">//会发生编译错误</span><br> System.out.println(b3+b6);<br><br><span class="hljs-comment">//特殊的注意强转的运算优先级</span><br> <span class="hljs-type">byte</span> b;<br> b=<span class="hljs-number">3</span>;<br> b=(<span class="hljs-type">byte</span>)b*<span class="hljs-number">3</span>    <span class="hljs-comment">//编译出错，因为(byte)的运算级别比*高,所以会先转换b后再*3</span><br> b=(<span class="hljs-type">byte</span>)(b*<span class="hljs-number">3</span>)  <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p> 注意区分boolean和Boolean，前者是值类型，后者是引用类型</p><p><strong>子父类强转的说明：</strong>将子类对象强转为父类对象并不是一种编译时错误，即编译器在编译过程中不会认为这是一种错误，但是在运行期会出现<strong>ClassCastException</strong> 异常，一般常用的父类转成子类的情况是，父类引用变量本身指向的就是子类对象，在使用过该变量后，需要其成为一个子类对象时进行强转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">String s;<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br><span class="hljs-comment">//程序不能通过编译，因为字符串变量 s 没有初始化</span><br><br>  <span class="hljs-type">float</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-type">float</span> <span class="hljs-variable">foo1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) -<span class="hljs-number">1.0</span>;<br>  <span class="hljs-type">float</span> foo2=  (<span class="hljs-type">float</span>) <span class="hljs-number">42e1</span>;<br>  <span class="hljs-type">float</span> <span class="hljs-variable">foo3</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2.02f</span>; <br>  <span class="hljs-type">float</span> <span class="hljs-variable">foo4</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) <span class="hljs-number">3.03d</span>; <br>  <span class="hljs-type">float</span> <span class="hljs-variable">foo5</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0123</span>;<br>  <span class="hljs-comment">//需要强转的部分如果不进行强转编译会报错，其等号右边是double类型</span><br>  String s[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">5</span>]; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; s[i++] = “” ); <br>  String s[<span class="hljs-number">5</span>] = &#123;“”, “”, “”, “”, “”&#125;;<br>  <span class="hljs-comment">//以上两种方式都能生成五个空字符</span><br>  <span class="hljs-comment">//注意区分空字符（&quot;&quot;）和空格（&quot; &quot;）</span><br></code></pre></td></tr></table></figure><p>对象之间的赋值，等号右边的对象一定要被赋值过</p><p>二维数组和一维数组之间的数组名不能相互转化</p><p>\uxxxx:其中xxxx表示一个16进制数字 这种格式是unicode码的写法表示一个char字符 例如：char ch &#x3D; ‘\ucafe’;  注意是\而不是&#x2F;</p><p><a href="https://blog.csdn.net/qq_26918031/article/details/52744383?utm_source=blogxgwz8">外部对内部类进行实例化和引用</a></p><p><a href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Gone with the wind&quot;</span>;<br>t = s[<span class="hljs-number">3</span>] + <span class="hljs-string">&quot;one&quot;</span>;  <span class="hljs-comment">//s[3]不能通过这种方式进行获取</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Gone with the wind&quot;</span>;     <span class="hljs-comment">//不能通过这种方式进行初始化</span><br><span class="hljs-type">StringBuffer</span>  <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Gone with the wind&quot;</span>;     <span class="hljs-comment">//不能通过这种方式进行初始化</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(“abc”);  <span class="hljs-comment">//正确初始化方式</span><br><span class="hljs-comment">//注意字符串中没有 -(减) 这种操作</span><br>s.toUpperCase( );<span class="hljs-comment">//将字符串中的字符全部变成大写字符</span><br><span class="hljs-comment">//Java中静态变量只能是成员变量,局部方法中的局部变量除final外不能有任何其他修饰符</span><br><span class="hljs-comment">//即java中不能在方法中定义静态变量</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br><span class="hljs-comment">//以上代码是java中object的tostring方法</span><br><span class="hljs-comment">//恰如调用方法时，父类引用子类实例的情况下，变量只能调用父类中已有的方法和变量，但是注意父类和子类中的同名变量会输出父类的变量</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>System.out.println(a.i); <span class="hljs-comment">//输出结果为1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">42</span>);<br><span class="hljs-type">Long</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">42</span>);<br><span class="hljs-type">Double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">42.0</span>);<br>System.out.println(d. equals(i));<span class="hljs-comment">//false</span><br>System.out.println(i. equals(d));<span class="hljs-comment">//false</span><br>System.out.println(i. equals(ll));<span class="hljs-comment">//false</span><br>System.out.println(i. equals(<span class="hljs-number">42</span>));<span class="hljs-comment">//true</span><br><span class="hljs-comment">//其根本原因是Integer的equals()源代码如下(其他数据类型的equals的代码相似)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value == (Integer)obj;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//只要不是被比较类的子类或者被比较类本身就是false</span><br>    &#125;<br>&#125;<br>i.equals(ll.intValue());<span class="hljs-comment">//true</span><br><span class="hljs-comment">//在对内部类进行实例化之前必须先取得对父类的引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnclosingOne</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InideOne</span> &#123;<br>    &#125; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerTest</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arge[])</span> &#123; <br>        <span class="hljs-type">EnclosingOne</span> <span class="hljs-variable">eo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnclosingOne</span>(); <br>        EnclosingOne. InsideOne ei=eo. <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsideOne</span>( );<span class="hljs-comment">//这一步很关键</span><br>        <span class="hljs-comment">//先取得A的引用，在借由A的实例对B进行实例化，由于此时B作为A的成员，因此B中可自由访问A类的其他成员。这种情况下A与B之间联系密切，实例化B必须取得A的引用。(其中A为外部类，B为内部类)</span><br>    &#125; <br>&#125;<br><br><span class="hljs-comment">//方法的形参名称改变不属于重载</span><br><span class="hljs-comment">//子类重写的方法的访问修饰符必须比父类该方法的访问修饰符权限要大，一定不能做更严格的限制</span><br></code></pre></td></tr></table></figure><p><strong>方法重载和方法重写（覆盖）的区别：</strong></p><p>相同点：方法名称相同；都属于多态机制</p><p>不同点：位置、参数列表、权限修饰符、返回值类型、抛出异常不同</p><p><strong>重载overload：</strong>发生在同一个类中，方法名相同，参数列表不同，与权限修饰、 返回值类型、抛出异常无关</p><p><strong>重写&#x2F;覆盖override:</strong> 发生在继承类中，方法名和参数列表相同，权限修饰符大 于等于父类、返回值类型小于等于父类、抛出异常小于等于父类</p><p><strong>多线程相关：</strong></p><ul><li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li><li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定</li><li>想要启动多线程，必须调用start方法</li><li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”</li></ul><p><strong>synchronized</strong> <strong>与</strong> <strong>Lock</strong> <strong>的对比</strong>：</p><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li></ul><p><strong>优先使用顺序：</strong></p><p>Lock  &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外）</p><p>Thread  和Runnable都是在java.lang包下定义的</p><p>并不是每一个线程对应一个cpu</p><p>必须是public void run() ，其修饰符和返回值不能发生改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用Runnable接口进行创建多线程的方式可以使用this充当同步监视器</span><br><span class="hljs-type">Window</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(w);<br><span class="hljs-comment">//使用继承Thread的方式进行创建多线程的方式谨慎使用this充当同步监视器</span><br><span class="hljs-comment">//可以使用MyThread.class充当同步监视器，类本身也是一个类</span><br><span class="hljs-comment">//同步方法仍然需要同步监视器，只是同步方法的同步监视器不需要手动进行设置</span><br><span class="hljs-comment">//非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类.class</span><br><span class="hljs-comment">//故使用Runnable接口进行创建多线程的方式应当用非静态的同步方法</span><br><span class="hljs-comment">//而使用继承Thread的方式进行创建多线程的方式应当用静态的同步方法</span><br><span class="hljs-comment">//lock是手动进行解锁上锁，而synchronized的都是自动的上锁解锁</span><br><br><span class="hljs-comment">//字符串大小写操作的转化</span><br><span class="hljs-type">String</span> <span class="hljs-variable">Upstr</span> <span class="hljs-operator">=</span> str.toUpperCase();<br><span class="hljs-type">String</span> <span class="hljs-variable">Lowstr</span> <span class="hljs-operator">=</span> str.toLowerCase()<br>    <br><span class="hljs-comment">//匿名内部类的使用</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() &#123;<br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>                  System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>              &#125;<br>          &#125;.show();<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>          <span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>          o.method();<br>      &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>线程阻塞的分类：</strong></p><ul><li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态（注意调用sleep方法并不会释放锁，“抱着锁睡觉”）</li></ul><p>允许一个类既是Thread的子类又实现了Runnable接口</p><p>在默认情况下，新建的线程的优先级与创建该线程的线程优先级相同</p><p>对于main线程，它的默认优先级是5，最好不要修改线程的默认优秀级</p><p>java线程在创建后任何时候（线程终止前）都可以重新设置优先级</p><p>A. setDaemon( )的作用是将指定的线程设置成后台线程，即变成守护进程</p><p>join ( ) 的作用是阻塞指定线程等到另一个线程完成以后再继续执行，即在A线程中调用B.join()则会使得B线程先完成后才会继续调用A线程</p><p>throw是解决一个问题，throws是声明一个方法时表示把这个问题交给上一级解决，上一级方法再使用try-catch继续处理</p><p>子类只能抛出比父类更加细致的异常</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\20190316111318681.png" alt="20190316111318681"></p><p>运行时异常是非受检异常，可以不对其进行处理</p><p>声明所要抛出的异常所限定的范围大于等于实际抛出的异常</p><p>就算try或者catch中有return，finally中的代码都会执行</p><p>JVM是Java Virtual Machine（<a href="https://baike.baidu.com/item/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6810577">Java虚拟机</a>）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>，是通过在实际的计算机上仿真模拟各种计算机功能来实现的</p><p>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/8290180">编译程序</a>只需生成在Java虚拟机上运行的目标代码（<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683">字节码</a>），就可以在多种平台上不加修改地运行</p><p>java中的boolean变量的大小取决于编译环境</p><p>数组和字符串都有length()方法</p><p>注意变量除了赋值操作以外，任何操作都要求变量已经被赋值了</p><p>子类重写方法的相关规定：权限修饰符大于等于父类、返回值类型小于等于父类、抛出异常小于等于父类</p><p>父类中的private的方法由于不能被子类所访问到，自然也就无法被重写</p><p>无论try代码块中的异常是否被catch捕获到，一旦throw了异常，try代码块中的剩余部分就不会被运行，但是在try-catch-finally体系以外的代码会被执行</p><p>是否能处理共享数据和是否能调用CPU是两回事，sleep并没有释放锁，但是不影响别的线程进行调用</p><p>释放锁的操作：当前线程的同步方法、同步代码块执行结束。</p><p>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</p><p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</p><p>当前线程在同步代码块、同步方法中执行了线程对象的**wait()**方法，当前线程暂停，并释放锁</p><p>不会释放锁的操作：线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</p><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）</p><p>使用全类名的类就不需要导入了</p><p>考试好运！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Java%E7%AC%94%E8%AE%B0Part2/"/>
    <url>/2023/03/06/Java%E7%AC%94%E8%AE%B0Part2/</url>
    
    <content type="html"><![CDATA[<h4 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(Interface)</h4><ul><li>接口和类是一种并列的结构，一定程度上解决了Java中的单继承的问题，使得其可以进行多重继承</li><li>继承类是指“是不是”，接口类是指“能不能”</li><li>接口中所定义的属性都是全局常量（即必须同时使用public static final 但是可以省略不写）<ul><li>同样的，接口中的方法默认是public abstract修饰的，而且可以省略不写</li></ul></li><li>接口是比抽象类更抽象的结构</li><li>class A extends B implements C,D,E(可实现多继承)</li><li>接口和接口之间也可以进行继承，并且可以进行多继承</li><li>接口的具体使用，实际上就是多态性的体现，接口实际上可以看做是一种规范</li><li>可以在形参列表中进行创建一个接口，并进行调用</li><li>Java8中关于接口的新特性：<ul><li>除了可以定义全局常量和抽象方法之外，还可以定义<strong>静态方法和默认方法</strong></li><li>接口中的静态方法只能通过接口进行调用，不能通过实现类进行调用（类似工具类）</li><li>接口中的默认方法可以通过实现类的对象可以调用接口中的默认方法，若实现类重写了接口中的默认方法，调用时使用的是重写过后的方法，如果一个子类继承的父类和实现的接口的同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（类优先原则）</li><li>如果实现类实现了多个接口，而这些多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，编译器会报错（接口冲突）这就需要我们必须在实现类中重写此方法</li></ul></li></ul><p>在Java中，Java文件是源文件，而class文件是通过Java文件编译后产生的字节码文件</p><h4 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h4><ul><li>开发中优先选择实现Runnable接口的方式<ul><li>原因：a，实现的方式没有类的单继承性的局限性  b,实现的方式更适合来处理多个线程有共有数据的情况</li></ul></li><li>两种方式的相同点：两种创建线程的方式都需要重写run()方法，将线程要执行的逻辑声明在run()方法中</li></ul><p>this代指的对象是调用该方法的对象</p><p>所有省略没写调用方法的对象名的对象都是this</p><p>注意两种创建新线程的方式不同：若是使用继承Thread类的方式创建多线程的方式，慎用this来充当同步监视器。可以考虑使用当前类来充当同步监视器；若是使用实现Runnable接口的方式创建新线程，则可以使用this关键词来充当同步监视器(前一种方法创建了多个对象，即产生的锁不唯一，而后一种方法只创建了一个继承Runnable接口的类的实例化对象，其他对象只是以这个这个实例化对象为参数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//这种解决线程安全的处理方式适合于该方法中的所有操作都是基于共享数据的  </span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-comment">//(针对于继承类的开启新线程方法）这两种方法是等价的，即在方法前用synchronized修饰等价为用synchronized修饰该代码块的锁</span><br></code></pre></td></tr></table></figure><p>解决线程安全问题的方式：1、同步代码块2、同步方法3、Lock锁(JDK5.0新增)</p><p>是否需要考虑如何解决线程安全问题：若有共享数据则需要考虑解决线程安全问题</p><h4 id="Lock锁的使用方法："><a href="#Lock锁的使用方法：" class="headerlink" title="Lock锁的使用方法："></a>Lock锁的使用方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*synchronized和lock的异同？</span><br><span class="hljs-comment">相同：二者都可以解决安全问题</span><br><span class="hljs-comment">不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器，而Lock需要手动的启动同步(Lock())，同时结束同步也需要手动的进行实现unlock()</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.实例化ReentrantLock</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">//2.调用锁定方法lock()</span><br>lock1.lock();<br><span class="hljs-comment">//3.调用解锁方法unlock()</span><br>lock1.unlock();<br></code></pre></td></tr></table></figure><p>在IDEA中定义过但没有调用过的方法体是灰色的</p><p>线程通信当中使用的三个方法：</p><ul><li>wait( )：一旦执行此方法，当前线程就会进入阻塞状态，并且释放同步监视器</li><li>notify( ):一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级较高的那个线程</li><li>notifyAll( ):一旦执行此方法，就会唤醒所有被wait的线程</li></ul><p>1、这三个在线程通信中所使用的方法必须使用在同步代码块或者同步方法中</p><p>2、这三个方法的调用者必须是同步代码块或者同步方法中的同步监视器，否则会出现异常</p><p>3、这三个方法是继承于java.lang.object</p><h4 id="sleep-和wait-的异同"><a href="#sleep-和wait-的异同" class="headerlink" title="sleep( )和wait( )的异同"></a>sleep( )和wait( )的异同</h4><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</p><p>不同点：1、两个方法所声明的位置不同：Thread类中声明sleep( )，而在Object类中声明wait( ) 2、调用的要求不同：sleep( )可以在任何需要的场景下进行调用，wait( )必须使用在同步代码块或者同步方法中 3、关于是否释放同步监视器：如果两个方法都使用在同步代码块或者同步方法中，sleep( )不会释放锁，而wait()会释放锁</p><h4 id="类中还可定义类作为主类的成员变量："><a href="#类中还可定义类作为主类的成员变量：" class="headerlink" title="类中还可定义类作为主类的成员变量："></a>类中还可定义类作为主类的成员变量：</h4><p>如果在主类中声明了一个其他类的对象，那么主类实例化的时候，也同时实例化了那个其他类的对象。如果这个其他类对象有自己的特殊的构造函数，你主类构造时如果没有实现那个构造函数。那么这个其他类的对象因为缺少构造函数的调用是无法实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在顾客消费货物问题的main方法中</span><br><span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br><span class="hljs-comment">//Clerk是Producer和Consumer中所共有的子类</span><br><span class="hljs-type">Producer</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(clerk);<br>p1.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br><span class="hljs-comment">//二者都将clerk作为其类中的参数，而clerk在此之前就已经被创建了，clerk是Clerk类的实例化对象</span><br><span class="hljs-type">Consumer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(clerk);<br>c1.setname(<span class="hljs-string">&quot;消费者1&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="print、printf、printin的区别："><a href="#print、printf、printin的区别：" class="headerlink" title="print、printf、printin的区别："></a>print、printf、printin的区别：</h4><p>print:普通输出    printin：比普通输出多个换行   printf：主要是继承了C语言的printf的一些特性，可以进行格式化输出</p><p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</p><p>路径：<br>    1、绝对路径是指这个文件在操作系统中的位置，<br>    2、相对路径通过这个文件的上一级 &#x2F; 或下一级&#x2F; 来指定文件内容</p><pre><code class="hljs">    例如：    D:\Steam\steamapps\common\dota 2 beta    流中用的就是路径名。因为和系统文件相关。</code></pre><p>全类名：全类名是指package + （.）类的名字</p><pre><code class="hljs">    例如：    二分查找.NO4第一个错误的版本.Solution     包名           包名          类名全类名例如 Class.forName（&quot;....&quot;），通过字符串来创建字节码对象（类对象）。</code></pre><h4 id="创建抽象类的匿名子类"><a href="#创建抽象类的匿名子类" class="headerlink" title="创建抽象类的匿名子类"></a>创建抽象类的匿名子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<span class="hljs-comment">//创建抽象类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建匿名子类的非对象p，重写抽象类中的方法</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<span class="hljs-comment">//等号左边表示的是被应用的对象类型（是个引用变量），右边才是真正的创建对象</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123; <br>System.out.println(<span class="hljs-string">&quot;走路&quot;</span>);<br>&#125;<br>&#125;;<br>method(p);<br>method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<span class="hljs-comment">//创建抽象类的匿名子类</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;chifan&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;huxi&quot;</span>);<br>        &#125;<br>&#125;<br><span class="hljs-comment">//这里的method方法仅用如测试重写方法是否成功，与如何创建抽象类的匿名子类无关，如果输出结果是“吃饭 走路”，则表示创建成功。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Person p)</span> &#123;<br>p.eat();<br>p.walk();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>string类实际上相当于将字符数组进行封装，将其看做是一个类，使用方法对其进行操作</p><p>string的内存解析：尚硅谷P469</p><p>string的不可变性：对字符串的任意操作都需要重新创建一个字符串，而不是在原来字符串的基础上进行改变</p><p><strong>字符串的比较大小</strong>是从两个字符串的第一个开始比较大小，若相同则一起往后移动一个格，直到遇到字符不相同的时候返回值是不同的那对字符的ASCII值的差值 </p><p>在字符串类型的操作方法往往都是“左闭右开”的</p><p>只有具有子父类关系的类才能进行强转</p><p>当编码集和解码集不一致时，解析完产生的结果可能出现乱码</p><p>Java没有无符号类型，全部是有符号类型的数据类型</p><h4 id="StringBuffer和StringBuilder、string的异同"><a href="#StringBuffer和StringBuilder、string的异同" class="headerlink" title="StringBuffer和StringBuilder、string的异同"></a>StringBuffer和StringBuilder、string的异同</h4><p>StringBuffer：可变的字符序列；线程安全的，效率较低（尝试用于多线程的情况）底层使用char型数组存储</p><p>StringBuilder：可变的字符序列；线程不安全的，效率较高（非多线程的时候常用）底层使用char型数组存储</p><p>String：不可变的字符序列；底层使用char型数组存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-comment">//相当于创建了char[ ] value = new char[0];</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//相当于创建了char[ ] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><span class="hljs-comment">//相当于char[ ] value = new char [16];</span><br>sb1.append(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//相当于 value[0]=&#x27;a&#x27;;</span><br>sb1.append(<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">//相当于 value[1]=&#x27;b&#x27;;</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//相当于创建了char[] value = new char[&quot;abc&quot;.length()+16];</span><br>System.out.printin(sb2.length());<span class="hljs-comment">//sb2.length()=3  返回字符串的实际长度</span><br>System.out.printin(sb2.capacity());<span class="hljs-comment">//sb2.capacity()=16 返回字符串所占容器的总大小</span><br>容量不等于实际长度<br><span class="hljs-comment">//扩容问题：如果要添加的数据底层数组存放不下，则需要对底层数组进行扩容，默认情况下，扩容为原来容量的两倍多2，同时将原有数组中的元素复制到新的数组中，特别的：若添加的字符串很长，即使是扩容后依然无法容纳，数组会将这个长字符串的长度当成扩容的长度</span><br><br><span class="hljs-comment">//开发中常使用构造器StringBuffer(int capacity)或StringBuilder (int capacity)即在创建StringBuffer时就确定其大小，避免扩容过程中对数组的复制降低效率</span><br></code></pre></td></tr></table></figure><p><strong>健壮性(鲁棒性）</strong>：鲁棒是Robust的音译，也就是健壮和强壮的意思。它也是在异常和危险情况下系统生存的能力。比如说，计算机软件在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。</p><p><strong>调用过时的结构的时候关键词会被idea中间画黑线，提示这种结构已经过时了(存在更合适更好的结构)</strong></p><p>有时输出的界面会有延迟，输出的实际结果可能和计算结果不符</p><p>list相当于是动态数组</p><p>遍历集合的方法：</p><p>iterator本身是个迭代器，操作数据是在原本数据基础上进行操作的，其本身并不存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>    System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//hasNext():判断是否存在下一个元素</span><br><span class="hljs-comment">//next():1、指针下移  2、将下移以后集合位置上的元素返回</span><br>下面是错误方式<span class="hljs-number">1</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br><span class="hljs-keyword">while</span>(iterator.next()!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(iterator.next());<br>&#125;<span class="hljs-comment">//会导致越界，并且导致输出是间隔一个进行输出（进行两次next才输出一次）</span><br>下面是错误方式<span class="hljs-number">2</span><span class="hljs-comment">//创建了匿名的迭代器（通过调用iterator()方法来生成迭代器）</span><br><span class="hljs-keyword">while</span>(coll.iterator().hasNext())&#123;<br>    System.out.println(coll.iterator.next());<br>&#125;<span class="hljs-comment">//由于集合对象每一次调用iterator()方法都会得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前，所以这个错误方式会一直不断产生新的迭代器，同时不断输出该coll中的第一个元素</span><br><span class="hljs-comment">//remove()方法的使用：删除集合中的Tom</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br><span class="hljs-keyword">while</span> (iteratior.hasNext())&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;Tom&quot;</span>.equals(obj))&#123;<br>        iterator.remove();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意remove必须在next之后调用，而且不能连续使用两次remove因为remove方法只是移除但是并不对指针进行移动，需要使用next方法将指针后移</span><br>新特性：foreach(增强版<span class="hljs-keyword">for</span>循环)<br>遍历集合：<span class="hljs-keyword">for</span>(集合元素的类型 局部变量：集合对象)<br>    <span class="hljs-keyword">for</span>(Object obj : coll)&#123;<br>        System.out.println(obj);<br>    &#125;<span class="hljs-comment">//改变obj的值不会影响原集合的值</span><br>遍历数组：<span class="hljs-keyword">for</span>(数组元素的类型 局部变量：数组对象)<br><span class="hljs-type">int</span>[ ] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>        System.out.println(i);<br>    &#125;<span class="hljs-comment">//改变i的值不会影响原数组的值</span><br><span class="hljs-comment">//第一次取得coll集合的第一个元素，然后将这个元素赋给Object类型的obj元素，然后取得coll集合的下一个元素，重复此操作，实际上内部仍然使用了迭代器</span><br> <br></code></pre></td></tr></table></figure><h4 id="List接口的使用："><a href="#List接口的使用：" class="headerlink" title="List接口的使用："></a>List接口的使用：</h4><p><strong>Array和list的异同：</strong>二者都是顺序表，Array是一段连续的存储结构而List不是连续的存储结构，List的每一个节点都包含有Next标明了下一个元素存在的位置</p><p>ArrayList、LinkedList、Vector三者的异同</p><ul><li>相同点：三个类都是实现List接口，存储数据的特点相同，都是存储有序的、可重复的数据</li><li>不同点：<ul><li>ArrayList：作为List接口的主要实现类；<strong>线程不安全的，效率高</strong>；底层使用的是Object[ ] elementData存储</li><li>LinkedList：对于频繁的插入、删除操作，使用此类比ArrayList的效率高；底层使用的是双向链表存储</li><li>Vector：作为List接口的古老实现类：<strong>线程安全的，效率低</strong>；底层使用Object[ ] elementData存储</li></ul></li></ul><p><strong>建议在开发中使用带参构造器：ArrayList List &#x3D; new ArrayList(int capcity)使其避免进行扩容，提高运行效率</strong></p><p>集合中不能存放基本数据类型，存放基本数据类型需要转化为对应的包装类</p><p>collection接口子接口：1、Set接口  2、list接口</p><p>list.add(list1); 将list1看做个整体加到list中</p><p>list.addall(list1);将list1中的元素分开来看，一个一个加到list中</p><p>list.remove(2); 舍弃的是角标为2的元素</p><p>list.remove(new Integer(value 2));舍弃的是list中元素值为2</p><h4 id="重写和重载的比较："><a href="#重写和重载的比较：" class="headerlink" title="重写和重载的比较："></a>重写和重载的比较：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-built_in">super</span>.move();<span class="hljs-comment">//使用super关键词调用父类中被重写的方法</span><br>      System.out.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;狗可以吠叫&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDog</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>      <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// Animal 对象</span><br>      <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>      b.bark();<br>   &#125;<br>&#125;<br><span class="hljs-comment">//编译时会报错，因为b的数据类型是Animal但是Animal类中没有bark方法(左边是数据类型，右边是构造器方法)</span><br></code></pre></td></tr></table></figure><h5 id="重写特点"><a href="#重写特点" class="headerlink" title="重写特点"></a>重写特点</h5><ul><li>重写方法的参数列表必须完全相同</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected</li><li>声明为 static 的方法不能被重写，但是能够被再次声明</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以</li><li>构造方法不能被重写</li></ul><h5 id="重载特点"><a href="#重载特点" class="headerlink" title="重载特点"></a>重载特点</h5><ul><li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同</li><li>被重载的方法可以改变访问修饰符</li><li>被重载的方法可以声明新的或更广的检查异常</li><li>方法能够在同一个类中或者在一个子类中被重载</li><li>无法以返回值类型作为重载函数的区分标准</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式</p><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现</li></ul><h5 id="instanceof-关键词"><a href="#instanceof-关键词" class="headerlink" title="instanceof 关键词"></a>instanceof 关键词</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> obj <span class="hljs-keyword">instanceof</span> Class<br>    <span class="hljs-comment">//其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false</span><br>　<span class="hljs-comment">//　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定</span><br></code></pre></td></tr></table></figure><h5 id="默认方法，静态方法，私有方法"><a href="#默认方法，静态方法，私有方法" class="headerlink" title="默认方法，静态方法，私有方法"></a>默认方法，静态方法，私有方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>   <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;我是一辆车!&quot;</span>);<br>   &#125;<br>&#125;<br><span class="hljs-comment">//在没有默认方法之前，需要对接口进行升级，则需要使用定义一个对应接口的子接口，然后让需要升级的继承类再次继承这个子接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterfaceSon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">newshow</span><span class="hljs-params">()</span>;<br>&#125;<br>Interface3 <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Interface0</span>, Interface1...<br><span class="hljs-comment">//继承多个接口的写法</span><br><span class="hljs-comment">/*默认方法：</span><br><span class="hljs-comment">*       默认方法是可以在接口中写执行体的。主要作用：</span><br><span class="hljs-comment">*       1.接口升级，可以避免改变其他实现类。</span><br><span class="hljs-comment">*       2.函数拼接</span><br><span class="hljs-comment">* 格式：public default 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*该格式中的public可以省略</span><br><span class="hljs-comment">*   注意：接口的默认方法可以通过接口或者实现类的对象类进行调用，实现类可以选择性地其进行覆盖重写。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 静态方法：</span><br><span class="hljs-comment">*静态方法不可以实例化，在接口中也是一样的</span><br><span class="hljs-comment">*注意静态方法不能够调用非静态方法       </span><br><span class="hljs-comment">*所以在接口中定义静态方法的作用就是类的静态方法的作用：</span><br><span class="hljs-comment">*不需要实例化，直接使用，并且只能通过接口进行调用而不能通过其实例化的类或者对象进行调用，节省内存空间。</span><br><span class="hljs-comment">*格式：public static 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*该格式中的public可以省略</span><br><span class="hljs-comment">* 注意：接口中静态方法和类中静态方法一样，只能通过接口.静态方法名的方式调用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">PS:接口中在新特性中能够使用私有方法，并不是意味着只有接口中才能够使用静态方法</span><br><span class="hljs-comment">私有方法的好处：1.减少重复代码数量，提高代码的可读性 2.为封装性考虑</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*私有方法：</span><br><span class="hljs-comment">*格式：private 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*作用：当两个默认方法或者静态方法中包含有一段相同的代码实现时，程序必然考虑将这一段代码抽取成一个共性方法，而这个共性方法是不需要让别人了解的(黑盒)，因此进行私有化隐藏起来</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*私有静态方法：</span><br><span class="hljs-comment">*格式：private static 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*作用：同私有方法相同，只不过私有静态方法是针对于静态方法中的相同代码块</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//默认方法可以调用私有的静态方法和私有的非静态方法</span><br><span class="hljs-comment">//静态方法只能够调用私有的静态方法</span><br></code></pre></td></tr></table></figure><h4 id="多态的具体理解"><a href="#多态的具体理解" class="headerlink" title="多态的具体理解"></a>多态的具体理解</h4><p>编译时多态：比如重载<br>运行时多态：比如重写</p><p>父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。</p><p>我们将引入Java静态分派和动态分派这个概念。</p><ul><li>静态分派:所有依赖静态类型来定位方法执行版本的分派动作。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，而是由编译器来完成。（编译时多态）</li><li>动态分派：在运行期根据实际类型确定方法执行版本的分派动作。（运行时多态）</li></ul><p>static变量并不是归于对象所有，而是归属于类所有，被所有的对象所共有</p><h5 id="多态成员访问的特点"><a href="#多态成员访问的特点" class="headerlink" title="多态成员访问的特点"></a>多态成员访问的特点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p><strong>成员变量</strong></p><p>编译看左边（基类），运行看左边（基类）；无论如何都是访问基类的成员变量</p><p><strong>成员方法</strong></p><p>编译看左边（基类），运行看右边（派生类），动态绑定</p><p><strong>Static方法</strong></p><p>编译看左边（基类），运行看左边（基类）。</p><p>非静态的成员方法</p><p>编译看左边（基类）,运行看右边（派生类）</p><p>这样，我们也可以得出多态的局限：</p><p><strong>不能使用派生类特有的成员属性和派生类特有的成员方法</strong></p><p><strong>总结：</strong></p><ul><li><strong>在调用成员变量以及静态方法时，“编译看左边，运行看左边”，</strong>即程序编译时创建了一个Animal类型的对象，并且使用new Cat()对于这个Animal对象赋值，但最终得到的还是一个Animal类的对象，只需要看“&#x3D;”左边的Animal animal即可</li><li>在调用非静态方法时，由于Animal类的对象是用Cat()来实例化的，这个非静态方法在运行时会被重写，从而输出子类中方法重写后的结果。这就是“编译看左边，运行看右边”</li></ul><h5 id="foreach（增强版for）的使用："><a href="#foreach（增强版for）的使用：" class="headerlink" title="foreach（增强版for）的使用："></a>foreach（增强版for）的使用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//for(集合或数组中元素的类型 局部变量i :集合或数组的名称)</span><br><span class="hljs-keyword">for</span>(Object obj : coll)&#123;<br>    System.out.println(obj);<br>&#125;<span class="hljs-comment">//遍历集合</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>    i=i+<span class="hljs-number">10</span>;<span class="hljs-comment">//注意这里不会改变数组元素的值，i在这里是个形参</span><br>    System.out.println(i);<br>&#125;<span class="hljs-comment">//遍历数组</span><br><span class="hljs-comment">//其本质还是调用了迭代器</span><br></code></pre></td></tr></table></figure><h5 id="set特点"><a href="#set特点" class="headerlink" title="set特点"></a>set特点</h5><p>Set接口中没有定义额外的新的方法，使用的都是Collection中声明过的方法</p><p>要求：向Set中添加新的数据，其所在的类一定要重写equals()方法和hashCode()方法，重写的equals()方法和hashCode()方法尽可能保持一致性：相同的对象必须具有相等的散列码，equal()方法用于判断元素是否相同，hashCode()用于判断元素应该存放的角标位置</p><p><strong>使用Alt+Shift+S可以直接生成新的equals()方法和hashCode()方法</strong></p><p>无序性和不可重复性——以HashSet为例说明：</p><ul><li>无序性：并不是随机性，多次遍历的输出顺序是相同的，都是按照某个特定的顺序进行输出，存储的数据在底层数组中并非按照数组索引的顺序进行添加，而是通过数据的哈希值来决定存放位置</li><li>不可重复性：保证添加的元素按照equals()判断时，不能返回true，即相同的元素只能添加一个</li></ul><p>添加元素的过程——以HashSet为例说明：</p><ul><li><p>通过数据的哈希值进行某些算法决定底层数组存储的角标，避免了添加第100个元素时得和以前的所有数据进行比较，但是由于哈希值不同计算出来的角标位置是可能是相同的，若待存放数据计算得到的位置已经有元素了，进行equals()，若不相同则用链表的方式连接到这个元素上(存放的位置“七上八下”) ，即<strong>Set实际上是数组和链表的结合</strong></p><p> JDK7：待存放的元素指向原来存在的元素</p><p> JDK8：原来存放的数组指向待存放的元素</p></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>LinkedHashSet是HashSet的子类</li><li>在存放数据的时候同时多了一个标注顺序的双向链表，在添加数据的同时每个数据还维护了两个引用，记录此数据前一个数据和后一个数据</li><li>优点：对于需要频繁的遍历操作 LinkedHashSet效率高于HashSet</li></ul><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><ul><li>向TreeSet中添加数据，要求是相同类的对象（因为需要进行比较）</li><li>排序的方式：自然排序(实现Comparable接口)  和  定制排序(Comparator)</li><li>TreeSet中比较是否重复和排序的根据是类中重写的compareTo方法（自然排序）或者compare方法（定制排序）进行比较</li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul><li>和collection类是并列的关系，用于存储双列数据，类似函数</li></ul><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul><li>在集合中没有使用泛型的情况下可能会有两种问题：1、存放学生成绩时用Object类可能会导致非int型的变量输入  2、由于输入的数据可能不是所想要的数据强转的过程中可能会异常</li><li><strong>只有在实例化的时候才确定了泛型所对应的数据类型，在自定义泛型类的时候可以把泛型看作是一个类，但实际上它是一个参数类型</strong></li><li>如果定义了泛型类，但是实例化没有指明类的泛型，则认为该泛型类型是Object类型</li><li>如果定义了类是带泛型的，建议在实例化的时候指明类的泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承带泛型的父类的两种情况</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;Integar&gt;&#123;&#125;<br><span class="hljs-comment">//由于子类在继承带泛型的父类时就指明了所接入的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;T&gt;&#123;&#125;<br><span class="hljs-comment">//继承带泛型的父类时，同样也可以保留使用泛型的特点</span><br><br><span class="hljs-comment">//如果想要创建泛型数组的写法</span><br>T[ ] arr = (T[ ]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确写法</span><br>T[ ] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//错误写法</span><br></code></pre></td></tr></table></figure><ul><li>泛型不同的引用对象不能彼此之间相互赋值</li><li><strong>由于泛型是在实例化调用的时候才使用确定的，而静态结构是在实例化之前存在的，故静态方法中不能使用类的泛型，特殊的，自定义异常类不能使用泛型</strong></li><li>泛型方法：在方法中出现了泛型的结构，至于泛型方法所属的类是不是泛型类都行，注意并不是使用泛型的方法就是泛型方法</li><li>泛型方法可以被声明为静态的，因为其泛型参数是在调用方法时确定的，而不是在实例化类的时候确定的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">Dosth</span> <span class="hljs-params">(E[] arr)</span>&#123;<br>    <span class="hljs-comment">//&lt;E&gt;表明E是一个泛型，该方法是泛型方法</span><br>    <span class="hljs-comment">//List&lt;E&gt;表明返回值是一个泛型List</span><br>    <span class="hljs-comment">//E[] arr表明参数是个泛型数组</span><br>&#125;<br><span class="hljs-comment">//泛型方法在调用时，指明泛型参数的类型</span><br>List&lt;Integer&gt; list = order.Dosth(arr);<br></code></pre></td></tr></table></figure><ul><li><p>泛型在继承方面的体现：是否有子父类关系取决于外层对象的类</p></li><li><p>如果类A和类B是子父类关系，（或者其他类型）List(A)和List(B)不具有子父类关系</p></li><li><p>如果类A和类B是子父类关系，且A是B的父类，则A<G>是B<G>的父类</p></li><li><p><strong>总结</strong></p><ul><li>集合接口和集合类在JDK5.0时都修改成了带泛型的结构</li><li>在实例化集合类的时候，可以指明具体的泛型类型</li><li>在指明完后，在集合类或者接口中凡是定义类或者接口时，内部结构（方法、属性、构造器等）使用到类的泛型的位置，都指定为实例化的泛型类型</li><li>泛型的类型必须是类，不能是基本数据类型，在需要使用基本数据类型的位置，使用包装类</li><li>如果实例化时没有指明泛型的类型，默认类型为Object类型</li></ul><h4 id="🥙通配符-即？"><a href="#🥙通配符-即？" class="headerlink" title="🥙通配符(即？)"></a>🥙通配符(即？)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*如果类A和类B是子父类关系，（或者其他类型）List(A)和List(B)不具有子父类关系,二者共同的父类是G&lt;?&gt;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    List&lt;Object&gt; list1 = <span class="hljs-literal">null</span>;<br>    List&lt;String&gt; list2 = <span class="hljs-literal">null</span>;<br>    List&lt;?&gt; list = <span class="hljs-literal">null</span>;<br>    list = list1;<br>    list = list2;<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<span class="hljs-comment">//编译时产生错误，因为我们不知道list当中的成员的具体数据类型，故无法添加任何数据，除了null因为null特殊在它是所有类型的成员</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//读取是允许的，按照Object类型方式进行读取</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>？表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>文件的位置：</p><p>1、绝对路径：从D:\开始写等等</p><p>File file1 &#x3D; new File(“D:\\workspace\\day08\\he.txt”)</p><p>(本身Windows的分隔符是  \  但是由于这个符号在编译器里是转义字符，所以要写成连续两个\\)</p><p>2、相对路径：默认相对于在当前module目录下（如果该语句写在主函数当中，则是相较于当前工程而言的）</p><p>File file2 &#x3D; new File(“he.txt”)</p><p>3、寻找文件夹的方式：</p><p>File file3 &#x3D; new File(“D:\\workspace”，JavaSenior)；</p><p>寻找名为JavaSenior的文件夹</p><p>4、寻找指定文件夹下的文件</p><p>File file1 &#x3D; new File(file3,”hi.txt”)；注意第一个参数是一个File类，即名为JavaSenior的文件夹</p><p>输入输出总是相对而言的，而相对于文件和程序，对于程序员而言，应当从程序的角度来分析输入输出，即从内存的角度来分析输入输出 </p><p><strong>缓冲流</strong>：能够提高流的读取和写入的速度，提高速度的原因是，存在缓存区，当缓冲区的存储数据满后批量移动数据，</p><p><strong>flush()</strong>;缓冲流的方法，用于刷新缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;地址&quot;</span>)));<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;地址&quot;</span>)));<br><span class="hljs-comment">//由于缓冲流是包在节点流之外的，所以可以用一行代码来代替</span><br></code></pre></td></tr></table></figure><p><strong>转换流</strong>：属于字符流也是处理流，其作用是提供字节流和字符流之间的转化，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过使用转换流，可以使得使用某编码集的文件转换成另一种编码集的文件</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;something.txt&quot;</span>);<br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis);<br><span class="hljs-comment">//所传的一个参数应该是字节输入流，此时默认使用系统默认的字符集</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//所传的第二个参数是指定的编码集，具体使用什么字符集取决于文件something.txt保存时所使用的字符集</span><br></code></pre></td></tr></table></figure><p><strong>字符集</strong>：许多字符集都兼容ASCII码</p><p>汉字有的需要两个字节储存，有的需要一个字节存储，为避免将一个两个字节的文字看成是两个一个字节的文字，故在第一个字节时，如果首位是0则说明是这两个自己分别有意思，如果首位是1这说明是两个字节是一个整体</p><p><strong>数据流</strong>：数据流的写入都需要使用数据流来操作 ，读取不同类型的数据的顺序要和当初写入文件时，保存的数据的顺序一致</p><p><strong>反序列化</strong>：将磁盘文件中的对象还原成内存中的一个Java对象，通过使用ObjectInputStream来进行实现</p><h4 id="复习异常的处理"><a href="#复习异常的处理" class="headerlink" title="复习异常的处理"></a>复习异常的处理</h4><ul><li>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</li><li>Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</li><li>如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，如果父类在子类的前面则会使得对于异常对象的查找不合适，父类会覆盖掉本应该让子类异常处理的问题，导致有没意义的异常处理出现</li><li>异常的出现相当于：提前预判了可能会出现的错误输出情况并且显式的给出了对应的解决异常方法</li></ul><p>API:应用程序编程接口</p><p>Java中的API：JDK中所提供的的各种Java类</p><p>java中的lang包是不需要导包的</p><p>抽象类可以作为形参和返回值，但是注意由于抽象类是不能够被实例化的，所以如果方法中的参数是抽象类，需要实际上传入抽象类的子类作为参数(使用了多态的性质)，同理当抽象类作为一个返回值时实际上返回的是抽象类的子类。</p><p>接口可以作为形参和返回值，类似抽象类，实际形参是接口的实现类对象，返回的实际上是接口的实现类对象</p><p>Animal a &#x3D; new Cat();</p><h4 id="Properties类的使用"><a href="#Properties类的使用" class="headerlink" title="Properties类的使用"></a>Properties类的使用</h4><ul><li>Properties 类位于 java.util.Properties ，是Java 语言的配置文件所使用的类， Xxx.properties 为Java 语言常见的配置文件，如数据库的配置 jdbc.properties, 系统参数配置 system.properties</li></ul><p><img src="https://img-blog.csdnimg.cn/20190626192756554.png" alt="在这里插入图片描述"></p><ul><li>继承了Hashtable 类，以Map 的形式进行放置值， put(key,value) get(key)</li></ul><h4 id="内部类补充"><a href="#内部类补充" class="headerlink" title="内部类补充"></a>内部类补充</h4><ul><li>内部类可以看成是外部类的组成部分，比如人的心脏，心脏应该是人的一个变量但是一个变量不足以表示心脏，故将其看做是一个内部类</li><li>外部类想要调用内部类不需要创建一个内部类的对象才能够调用内部类的方法属性，而内部类可以调用外部类的变量(在类的定义以外调用，更需要通过内部类所特殊的创建类的方法 )</li></ul><p>内部类可以分为四种:<strong>成员内部类、局部内部类、匿名内部类、静态内部类</strong></p><ul><li>成员内部类:定义在类中的类</li><li>局部内部类：定义在方法中的类，和成员内部类的区别在于局部内部类的访问权限仅限于方法或作用域内</li><li>注意内部类可以写在参数列表当中，在需要该参数时顺便创建了该参数的对象</li><li>匿名内部类：没有构造方法。也是唯一没有构造方法的内部类。<strong>匿名内部类和局部内部类只能访问外部类的final变量</strong>，匿名内部类的本质是继承了该类或者实现了该接口的子类匿名对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当匿名内部类作为参数时，这个方法中定义的参数可以是接口可以是抽象类可以是具体类，并且写匿名内部类的代码块当中可以给对应的父类或者接口中的方法进行重写</span><br><span class="hljs-comment">//匿名内部类的使用(写在类中或者写在方法中)</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>)<br>    &#125;<br>&#125;.show();<span class="hljs-comment">//创建对象的时候就调用方法</span><br><span class="hljs-comment">//由于本质上匿名内部类是一个对象，所以如果想要多次调用方法则应该使用多态的形式</span><br><span class="hljs-type">Inter</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>)<br>    &#125;<br>&#125;<br>i.show();<br>i.show();<br><span class="hljs-comment">//该方法创建了一个抽象类或者接口的匿名子类，然后通过多态的方式进行调用方法</span><br></code></pre></td></tr></table></figure><ul><li>静态内部类：静态内部类和成员内部类相比多了一个static修饰符。它与类的静态成员变量一样，是不依赖于外部类的。同时静态内部类也有它的特殊性。因为外部类加载时只会加载静态域，所以静态内部类不能使用外部类的非静态变量与方法。</li></ul><p>使用内部类的好处：</p><ul><li>完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响</li></ul><p>静态内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; new 外部类.内部类();</strong><br>成员内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; 外部类对象名.new 内部类();</strong></p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>尽量避免面向对象的复杂语法，强调去做什么而不是强调怎么去做的思想</p><p>当需要对一个函数式接口实例化的时候，可以使用Lambda表达式，<strong>Lambda表达式的本质就是作为函数式接口的实例</strong></p><p>lambda表达式的出现使得之前使用匿名实现类进行表示的现在都可以使用Lambda表达式来写</p><p>Lambda表达式只影响了创建实例的方式，不影响调用方法的过程</p><p>使用给定的函数式接口的场景 ：</p><p>如果在开发中需要定义函数式接口，首先确定在已有的jdk中提供的函数式接口，如果有则直接进行调用即可</p><p>lambda表达式使用前提：</p><ul><li>有一个接口</li><li>接口中有且只有一个抽象方法 </li><li>必须有上下文环境才能推导出lambda表达式对应的接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//能够使用lambda表达式的方法定义格式</span><br>方法名（接口类型 接口形参名）<br><span class="hljs-comment">//即参数是一个接口的类型，不能是抽象类或者是具体类</span><br><span class="hljs-comment">//但实际上在使用lambda表达式调用方法时，所传入的参数是取决于接口中的唯一的抽象方法所使用的的参数</span><br></code></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>通过方法引用来使用已经存在的方案</p><p>lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</p><p>lambda表达式被对象的实例方法所替代的时候，它的形式参数全部传递给该方法作为参数</p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>若在一个接口中，只声明了一个抽象方法，则这个接口就称之为函数式接口，我们可以在一个接口上使用@FunctionaLInterface注解，这样可以用于检查这个接口是否为函数式接口</p><p>Lambda表达式本质是函数式接口的实例</p><p>当某一个方法的参数为一个接口时，可以使用lambda表达式来代替用匿名类进行创建，填入接口参数位置时，只需要写</p><p>参数 -&gt; 调用的方法</p><p>因为在接口形参的位置填入lambda表达式本身编译器就可以推断出对应的接口类型</p><h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h4><p><strong>运行时类</strong>：加载到内存中的类</p><p>在Person类外部，不可以通过Person类的对象调用其内部的私有结构</p><p>通过反射可以调用类中的私有结构</p><p>常见使用直接new和反射的方式，常见都是直接使用new的方式调用公共的结构，但是如果在反射具有动态性的时候用后者（使用反射创建对象就是为了体现反射的动态性）</p><p><strong>反射机制和面向对象的封装性不矛盾</strong>：封装性强调的是不建议在外部调用私有的属性，而反射的特性相当于强化了Java的能力，强调它可以调用私有的结构</p><p><strong>关于java.lang.Class类的理解</strong>：万事万物皆对象的概念理解，即类本身也是另一个类的对象，加载到内存中的运行时类会缓存一定的时间，在此时间内，我们可以通过不同的方式来获取此运行时类，并且通过不同的方式获取的运行时类是相同的，Class实例对应着加载到内存中的一个运行时类</p><p>**newInstance():**方法实际上 其本质还是使用了其类的空参构造器进行创建对象</p><p><strong>newInstance():正常使用的条件</strong>1.运行时类必须提供空参的构造器  2.空参的构造器的访问权限需要足够。通常设置为public</p><p>在javabean中要求提供public的空参构造器，原因如下：1.便于通过反射，创建运行时类的对象  2.便于子类继承此运行时类时，默认调用super()，保证父类有此构造器</p><p>使用反射创建对象就是便于在运行时确定想要创建的类，便于对框架的使用</p><p>通过反射可以获取和调用运行时类的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过反射创建对象的方式之一</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><span class="hljs-comment">//通过反射创建对象的方式之二</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-comment">//往往采用第一种方式创建对象，因为反射的动态性，所有需要提高代码的通用性，使用第一种方法来调用对应类中的空参构造器</span><br></code></pre></td></tr></table></figure><p>创建对象的方法：1. new + 构造器  2.部分类中存在静态方法用于创建对象  3.通过反射进行创建对象</p><p>待处理：反射相关的方法</p><p><a href="%5Bjava%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3_fly_zhyu%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_java%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90%5D(https://blog.csdn.net/fly_zhyu/article/details/74178883)">Java内存解析</a></p><p><a href="https://www.cnblogs.com/jian0110/p/10690483.html">Java泛型解析</a></p></li></ul><p>**Javabean:1、所有属性为private  2、提供默认构造方法  3、提供getter和setter  4、实现serializable接口 **       <a href="https://www.zhihu.com/question/19773379">JavaBean详细解释</a></p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>静态代理特点：在编译期间代理类和被代理类就已经确定了</strong></p><p><strong>实现动态代理所需要解决的问题：</strong></p><p><strong>问题一：</strong>如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</p><p><strong>问题二：</strong>当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</p><p>定义代理类时，可以定义参数是代理类所实现的接口，因为当实际创建代理类对象时，传入的参数是实现接口的被代理类（多态）</p><h2 id="amp-和-amp-amp-：当且仅当-a、b-都为-true-时，结果为-true-；"><a href="#amp-和-amp-amp-：当且仅当-a、b-都为-true-时，结果为-true-；" class="headerlink" title="&amp;和&amp;&amp;：当且仅当 a、b 都为 true 时，结果为 true ；"></a>&amp;和&amp;&amp;：当且仅当 a、b 都为 true 时，结果为 true ；</h2><h2 id="和-：-当且仅当-a、b-都为-false-时，结果为-false-；"><a href="#和-：-当且仅当-a、b-都为-false-时，结果为-false-；" class="headerlink" title="| 和 || ： 当且仅当 a、b 都为 false 时，结果为 false ；"></a>| 和 || ： 当且仅当 a、b 都为 false 时，结果为 false ；</h2><p>(前者是不聪明的逻辑运算，后者是聪明一点的逻辑运算)</p><p>在java中&amp;和&amp;&amp;均可用于当逻辑运算符，区别同上，并且单个的&amp;也可以当做位运算符使用</p><p>形参用final进行修饰表示的是这个形参只能被实参赋值一次</p><p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址</p><p>注意子类的异常类型应当放在父类的异常类型之下，如果父类的异常放在子类的上面，则子类的异常类型就不起作用了</p><p><strong>foreach</strong>并不是一个关键字，习惯上将for(元素类型t 元素变量x : 遍历对象obj)这种特殊的for语句格式称之为<strong>“foreach”</strong>语句</p><p><strong>数组和集合的差别：</strong>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了 而集合是可以动态扩展容量，可以根据需要动态改变大小</p><p><strong>ArrayList和Array的区别：</strong></p><ul><li>ArrayList是属于集合当中的，其长度可以发生改变，并且因为其实集合的缘故，<strong>ArrayList中不能存放基本数据类型</strong>（但是在编写当中没有差距，因为存在自动装箱的操作，但是仍然不能使用ArrayList<int>系统会认为其错误，进行报错）</li><li>ArrayList是基于array，它提供和array一定程度上一样的性能 但是在一些额外功能性的ArrayList上性能还是和array 存在一定差别，主要是内存的使用和CPU 耗时 </li><li>ArrayList 是类型安全的，因为它支持泛型(Generics) 允许编译器检查 ArrayList 里所包含的对象是否是正确的类型</li><li>ArrayList 也允许你删除元素，这在<strong>array上也是不可能的 通过删除</strong>，我的意思并不是将null置于对应的index里，而是将所删除元素的后面所有元素的index都往前移动一位，这些都是ArrayList自动为我们做的（添加元素同理）</li><li>ArrayList中支持使用迭代器进行遍历</li><li>ArrayList提供一个size()方法来告诉你当前时间点ArrayList存储了多少个元素  size() 总是和length不同的，它也是ArrayList的容量</li><li>ArrayList和array的另外一个重要的区别就是array可以使多维度的  如你可以设置一个二维数组或者三维数组，可以使你创在一个特殊的数据结构来代表矩阵或者2D形式(terrains)  另一方面，ArrayList并不支持允许你指定维度</li></ul><h4 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h4><p>构造器无法被标示为<em>synchronized</em>, <em>final</em>, <em>abstract</em>, <em>native</em>, 或者 <em>static</em></p><p><strong>抽象类的构造器作用：</strong></p><ul><li>子类的构造方法中，如果没有调用父类的构造方法，就会默认加一个super()</li><li>抽象类的构造器不能用来实例化对象，但是可以被子类调用</li></ul><p>Java 里的构造器会按照以下顺序完成下列工作：</p><ol><li>将类变量初始到缺省值。（byte, short, int, long, float, 和 double 变量会默认设为它们相应的0值，booleans 会被设为 false, chars 会被设为空字符(‘\u0000’)，对象引用会被设为 null）</li><li>引用父类的构造器，如果没有定义任何构造器。</li><li>将实例变量初始化到指定值。</li><li>执行构造器内的代码。</li></ol><p>一、普通代码块<br>　　直接在一个方法中出现的{}就称为普通代码块，例子程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo01</span>&#123;<br>　　　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>　　　　<span class="hljs-comment">//普通代码块</span><br>　　　　&#123;<br>　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>　　　　　　System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x);<br>　　　　&#125;<br>　　　　<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>　　　　System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x);<br>　　　　&#125;<br>　　&#125;<br><span class="hljs-comment">//在方法中定义的代码块，并没有特殊的实际意义</span><br></code></pre></td></tr></table></figure><p>二、构造代码块</p><p>　　直接在类中定义的没有加static关键字的代码块{}称为构造代码块，例子程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;第一构造块&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test1</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次调用&quot;</span> + <span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br> <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;第二构造块&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">2</span>);<br> <br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行结果  第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第0次调用构造方法</span><br><span class="hljs-comment"> *           第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第1次调用构造方法</span><br><span class="hljs-comment"> *           第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第2次调用构造方法</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 构造代码块：直接在类中定义且没有加static关键字的代码块称为&#123;&#125;构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。如果存在多个构造代码块，执行顺序由他们在代码中出现的次序决定，先出现先执行。</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>三、静态代码块<br>静态代码块:在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行</p><p>如果类中包含多个静态代码块，那么将按照”先定义的代码先执行，后定义的代码后执行”</p><p>1 .静态代码块不能存在于任何方法体内</p><p>2 .静态代码块不能直接访问实例变量和实例方法，需要通过类的实例对象来访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">STATIC_FIELD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;静态属性&quot;</span>;<br> <br>    <span class="hljs-comment">// 静态块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(STATIC_FIELD);<br>        System.out.println(<span class="hljs-string">&quot;静态代码块1&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;非静态属性&quot;</span>;<br> <br>    <span class="hljs-comment">// 非静态块</span><br>    &#123;<br>        System.out.println(field);<br>        System.out.println(<span class="hljs-string">&quot;非静态代码块2&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InitOderTest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造函数&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InitOderTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitOderTest</span>();<br>    &#125;<br> <br>    <span class="hljs-comment">// 非静态块</span><br>    &#123;<br>        System.out.println(field);<br>        System.out.println(<span class="hljs-string">&quot;非静态代码块1&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 静态块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(STATIC_FIELD);<br>        System.out.println(<span class="hljs-string">&quot;静态代码块2&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 运行结果  静态属性</span><br><span class="hljs-comment"> *           静态代码块1</span><br><span class="hljs-comment"> *           静态属性</span><br><span class="hljs-comment"> *           静态代码块2</span><br><span class="hljs-comment"> *           非静态属性</span><br><span class="hljs-comment"> *           非静态代码块2</span><br><span class="hljs-comment"> *           非静态属性</span><br><span class="hljs-comment"> *           非静态代码块1</span><br><span class="hljs-comment"> *           无参构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//在调用主方法之前，先调用所有的静态代码块(按顺序调用)再调用所有的非静态代码块(按顺序调用)，最后再调用主方法</span><br><span class="hljs-comment">//注意静态代码块只能调用静态变量</span><br></code></pre></td></tr></table></figure><p>四、同步代码块<br>　　同步代码块主要出现在多线程中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>　　　　<span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>　　　　<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>　　　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>　　　　　　<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>　　　　　　　　<span class="hljs-keyword">synchronized</span>(obj)&#123;<br>　　　　　　　　　　<span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;<br>　　　　　　　　　　　　ticket--;<br>　　　　　　　　　　&#125;<br>　　　　　　　　&#125;<br>　　　　　　&#125;<br>　　　　&#125;<br>　　&#125;<br></code></pre></td></tr></table></figure><h4 id="Javabean"><a href="#Javabean" class="headerlink" title="Javabean"></a>Javabean</h4><p>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。</p><p>通过这样的编写习惯来保证代码的<strong>向后兼容性</strong></p><p><strong>ArrayList中size和capacity的区别：</strong></p><ul><li>size指的是ArrayList中元素的数量</li><li>capacity指的是在ArrayList底层实现中Object数组的大小，也可以理解为ArrayList的容量</li></ul><p><strong>equal和 &#x3D;&#x3D;的区别：</strong></p><ul><li>对于基本数据类型：二者一样，都可以看做是比较两者的值</li><li>对于引用数据类型：&#x3D;&#x3D;号比较两个对象时比较的是两个对象的地址值，而由于equals()方法存在于Object类中，并且Object类是所有类的直接或间接父类，也就是说所有的类中的equals()方法都继承自Object类，<strong>并且Object类中equals()方法底层依赖的是&#x3D;&#x3D;号，那么，在所有没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;号的效果一样，也是比较的地址值，</strong>然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值（对于自定义类型，往往要重写equal方法）（即未重写的equals方法实际上和&#x3D;&#x3D;相同）</li></ul><h4 id="绝对路径和相对路径的区别："><a href="#绝对路径和相对路径的区别：" class="headerlink" title="绝对路径和相对路径的区别："></a>绝对路径和相对路径的区别：</h4><p>绝对路径：</p><blockquote><p><em>就是真实的路径,是计算机中完整路径,必须准确,否则不能找到,起点是系统的根目录,也就是各个盘符</em></p></blockquote><p>举例：C:&#x2F;Users&#x2F;a1394&#x2F;Desktop&#x2F;OneDrive</p><p>相对路径：</p><blockquote><p><em>绝对路径是一种简化版的路径,以当前文件,活动窗口目录为根目录,进行向上或者向下c</em></p></blockquote><p>举例：</p><ul><li><p>1</p></li><li><ul><li><p>2</p></li><li><ul><li>3.jpg</li></ul></li></ul></li><li><p>a</p></li><li><ul><li><p>b</p></li><li><ul><li>c.html</li><li>c.jpg</li></ul></li></ul></li></ul><p>1,2,a,b都是文件夹,假设现在我打开的是c.html,那么c.html所在的目录就是相对根目录</p><p>1.如果在同一目录下另一个文件使用c.jpg,那么路径就是<strong>url&#x3D;”c.jpg”</strong></p><p>2.如果我要去找3.jpg的话,就要回到父文件夹的父文件夹,也就是1,此时路径为<strong>url&#x3D;”..&#x2F;..&#x2F;“</strong>    </p><p>此时1文件夹和a文件夹同一级,那么就进入1然后进入2,找到3.jpg,所以最后的路径为<strong>url&#x3D;..&#x2F;..&#x2F;1&#x2F;2&#x2F;3.jpg</strong></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h3><p>相对路径比较灵活,只要层级结构没有变化,比如上面的a和b文件夹只是换了个名字,那么不影响寻址,但是绝对路径就要好好确认下路径有没有问题了</p><p>前端开发或者你的程序需要在不同的设备中来回移动的话,必须用相对路径,因为你换设备就会改变绝对路径,就类似于你用u盘的时候,你的盘符都不是固定的一个道理</p><p><strong>总结:</strong></p><p>绝对路径就是写死的路径,缺点是换设备会出现路径找不到问题</p><p>相对路径就是灵活的路径,优点是不会因为设备更换出现路径问题</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>1、函数的调用过程</p><p>调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。</p><p> 这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的<strong>压栈</strong>和<strong>出栈</strong>。 </p><p>因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。</p><p>2、内联函数</p><p>那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。<strong>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。</strong>显然，这样就不会产生转去转回的问题，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。</p><blockquote><p>写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等）。在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被编译器视为内联函数。</p></blockquote><p>3、JVM内联函数</p><p>C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，<strong>一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</strong></p><p>JVM内联有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。<strong>如果是长方法JVM可能直接就跪了</strong>。第二个原因则更重要：方法内联 </p><p><strong>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身</strong>。比如说下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;  <br>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>    &#125;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2)</span> &#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>在金融计算中使用BigDecimal来表示准确的数字</p><p>”&gt;&gt;&gt;”表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</p><p>switch中使用的标签支持使用String类型</p><p>case穿透现象：如果不在case中添加break则会继续下一个</p><p><strong>cmd执行java命令与javac命令的区别：</strong></p><p>javac：是编译命令，将java源文件编译成.class字节码文件。需要加扩展名</p><p>例如：javac hello.java  将生成hello.class文件。</p><p>java：是运行字节码文件；由java虚拟机对字节码进行解释和运行。不需要加扩展名</p><p>例如：java hello<br>eg：c:\Users\Administrator\Desktop\javadoc&gt; java HelloWorld hello hello 123 321</p><p>即从被运行的文件以后的视为参数</p><p>若在cmd窗口中输入这些则会运行HelloWorld程序，并且传递的参数args[0]&#x3D;args[1]&#x3D;hello,args[2]&#x3D;123;</p><p>在单例模式要保证构造器私有</p><p>只有一个函数的接口称之为函数式接口</p><p>Date类中建议使用calendar类，更为先进</p><p><strong>StringBuffer：</strong>效率低，安全，多线程用</p><p>**StringBulider:**效率高，不安全，单线程用</p><p>泛型起到约束的作用，避免类型转换之间的问题</p><h4 id="可变长参数详解："><a href="#可变长参数详解：" class="headerlink" title="可变长参数详解："></a>可变长参数详解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//格式:</span><br>print(String... args)&#123;<br><br>&#125;<br><span class="hljs-comment">//在具有可变长参数的方法中可以把参数当成数组使用，例如可以循环输出所有的参数值</span><br>print(String... args)&#123;<br>   <span class="hljs-keyword">for</span>(String temp:args)<br>   System.out.println(temp);<br>&#125;<br><span class="hljs-comment">//调用的时候可以给出任意多个参数也可不给参数，例如：</span><br>print();<br>print(<span class="hljs-string">&quot;hello&quot;</span>);<br>print(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-comment">//调用可变长参数方法的调用规则：</span><br><span class="hljs-comment">//1、在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则选择固定参数的方法</span><br><span class="hljs-comment">//即优先使用更加精确的对应方法</span><br><span class="hljs-comment">//2、如果要调用的方法可以和两个可变参数匹配，则出现错误</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            out.println(args[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test,String...args )</span>&#123;<br>          out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VarArgsTest1</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VarArgsTest1</span>();<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>);<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;alexia&quot;</span>);<br>    &#125;<span class="hljs-comment">//对于上面的代码，main方法中的两个调用都不能编译通过，因为编译器不知道该选哪个方法调用</span><br><span class="hljs-comment">//3、一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数</span><br><br><span class="hljs-comment">//调用可变长参数的使用规范</span><br><span class="hljs-comment">//1、避免带有可变长参数的方法重载</span><br><span class="hljs-comment">//2、在可变长参数中避免使用null值和空值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test, Integer... is)</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test,String...args )</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VarArgsTest1</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VarArgsTest1</span>();<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>);<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br><span class="hljs-comment">//这时会发现两个调用编译都不通过,因为两个方法都匹配，编译器不知道选哪个，于是报错了，这里同时还有个非常不好的编码习惯，即调用者隐藏了实参类型，这是非常危险的，不仅仅调用者需要“猜测”该调用哪个方法，而且被调用者也可能产生内部逻辑混乱的情况</span><br></code></pre></td></tr></table></figure><h4 id="java包机制详解："><a href="#java包机制详解：" class="headerlink" title="java包机制详解："></a>java包机制详解：</h4><ul><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li><li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突</li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li></ul><p>创建包的注意：创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头</p><p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它</p><p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中</p><p><strong>javadoc:</strong></p><p>javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件</p><p>每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引</p><p>由于 javadoc 的实现不同，工作也可能不同，你需要检查你的 Java 开发系统的版本等细节，选择合适的 Javadoc 版本</p><p>java中本身数组是引用变量，即无论数组元素中基本类型还是引用类型，在进行数组间的赋值时，实际上是将两个数组引用变量指向同一个数组实体，如果需要对数组进行真实的拷贝，需要调用copy方法</p><p>在编码过程中尽量减少读取内存的操作，因为读取内存消耗的时间远大于计算所需的开销，即内存墙</p><p><a href="https://www.jianshu.com/p/54e2aeca013b">什么是编译型语言和解释型语言？</a></p><h4 id="静态语言和动态语言："><a href="#静态语言和动态语言：" class="headerlink" title="静态语言和动态语言："></a>静态语言和动态语言：</h4><p><strong>静态语言（强类型语言）</strong>：</p><p>在编译时变量的数据类型就已经确定，多数静态类型语言要求在使用变量之前必须声明数据类型。比如：C，C++，Java等，不允许隐式转化数据类型</p><p> <strong>动态语言（弱类型语言）</strong>：</p><p>在运行时，确认数据类型的语言。变量使用之前不需要声明类型，通常变量的类型是被赋值的那个值的类型。比如：Python，PHP，SQL，Ruby等，允许隐式转换数据类型</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\b0aeb7ffd1667b9162e5329154d43777_r.png" alt="b0aeb7ffd1667b9162e5329154d43777_r"></p><p>无论是基本数据类型还是引用数据类型，数组本身都是引用类型，只是基本数据类型中的元素是数据本身存储在堆空间中，引用类型的数组的元素数组元素也是存储在堆空间中，但是数组元素是引用对象的引用</p><p>如果创建了一个3*3的二维数组，则该数组的a[2]实际上是一个地址</p><p><strong>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</strong></p><p>创建字符串两种方式的不同之处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1;                    <span class="hljs-comment">// 相同引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br><span class="hljs-comment">//使用new即一定在堆空间重新开辟了空间存放</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\java-string-1-2020-12-01.png" alt="java-string-1-2020-12-01"></p><h4 id="Comparable接口和Comparator接口的比较"><a href="#Comparable接口和Comparator接口的比较" class="headerlink" title="Comparable接口和Comparator接口的比较:"></a>Comparable接口和Comparator接口的比较:</h4><p><strong>Comparable接口:</strong></p><ul><li>此接口强行对实现它的每个类的对象进行整体排序 </li><li>类的 compareTo 方法被称为它的自然比较方法</li></ul><p><strong>Comparable接口的compareTo方法：</strong><br>public int compareTo(T o);-<br>这个Comparable是一般让一个自定义类的作为其实现类<br>将this对象与T  o对象比较，如果return0，则表示它们相等，如果&gt;0 则表示this对象比T o 对象大，如果 &lt; 0 则 this对象比T o 小</p><p> <strong>Comparator接口:</strong><br>对集合对象或数组对象进行排序</p><p><strong>Comparator接口 的compare方法：</strong><br>int compare(T o1, T o2);<br>Comparator是不需要对自定义提供接口的，而是重新写一个Comparator的新的实现类作为比较器，当做sort的一个参数，<br>sort函数的形参专门有接口这些比较器的类型（这种写法很常见，实现代码重用、扩展，也就是策略模式了） 它和Comparable比较规则一样，这里o1 与 o2比较，如果返回值 &#x3D; 0 则表示o1 &#x3D;&#x3D; o2 ；如果 &gt; 0 则表示 o1 &gt; o2; 如果 &lt; 0 则 o1 &lt; o2;</p><p>Comparator接口 的compare方法均为返回值&gt;0即前者大，返回值&lt;0则后者大</p><p><strong>Comparable接口和Comparator接口的区别：</strong></p><ul><li>Comparator位于包java.util下，而Comparable位于包java.lang下</li><li>Comparable接口将比较代码嵌入自身类中，而后者在一个独立的类中实现比较</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>                <span class="hljs-keyword">return</span> str1.compareTo(str2);<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//Comparator接口中可以实现不同种类的排序，并且可以通过匿名类的方式对Comparator接口进行实现</span><br><span class="hljs-comment">//注意区别Collection和Collections，前者是集合类，后者是工具类</span><br><span class="hljs-comment">//sort方法的第一个参数是待排序的数组，第二个参数是重写的构造器</span><br></code></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/31203609">Java 到底是值传递还是引用传递？</a></p><p>字符流不能用于读取二进制文件，因为在使用字符流的过程中存在着编码和解码的过程，而正常二进制的文件中可能存在超过字符集编码设定范围的数字导致错码乱码</p><p>显示读取文件路径只传入String类型的文件名实际上是，传入的是省略了路径符号的相对路径</p><p><a href="https://blog.csdn.net/weixin_43871333/article/details/89042724?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">常见几种编码格式及比较_B–rabbit的博客-CSDN博客_常见编码格式</a></p><p>@Test方法可以使得不必编写main方法而可以直接调用该方法</p><p>parseInt():将输入参数转换成int类型的返回值</p><p>使用字节流处理非文本文件，使用字符流处理文本文件，特殊的如果只是想将文件从一个文件复制到另外一个文件，则文本文件也可以用字节流进行处理，只要不在内存层面进行显示即可，反之不行</p><p>对象流的读出是按object的形式读出，可以进行强转为特定对象</p><p>实际上在使用对象流进行序列化时，往往是令文件中都是一种类的文件，而不是有各种各样的对象</p><p>序列化不仅要让当前类是可序列化的，类中的元素的数据类型也必须都是可序列化的</p><p>随机读取流：使得下载文件暂停后重新打开是继续进行的</p><p>jar包相当于是第三方提供的额外的API导入后即可使用，比如文件的复制读写等操作都有相应的jar包使用</p><p><strong>字符集编码知识：</strong><br>GBK:如果是1开头则标注是由两个字节表示的，如果是0开头则表明是由一个字节所表示的</p><p>UTF-8:在该编码集中，使用三个字节来标注汉字，其属于变长编码使用1~4个字节编码</p><p>Unicode：确立了编码和字符一一对应的关系而不是具体编码的形式(UTF-8,UTF-16是对应的编码形式)</p><p>使用” xxx.* “表示的是导入xxx包下的所有结构，但是导入的只是xxx包下的结构，如果需要使用xxx包的子包中的结构则还需要导包</p><p>如果定义的类或接口是本包下定义的则不需要使用import，在java.lang包下的结构也不需要使用import</p><p>若在源文件中使用不同的包下存在同名的结构，则需要至少其中一个类用全类名的方式调用</p><p>由于反射是为了进行实现动态，所以倾向于使用通用性较强的方法而不是特定的方法</p><p>在java中可以简单的理解为基本数据类型是传值，而引用数据类型是传引用</p><p>在java中每一个类都对应一个main方法，但是在一个java文件中只能有一个public的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeOrNotTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeOrNot</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> x[])</span> &#123;<br>i = -<span class="hljs-number">1</span>;<br>    x[<span class="hljs-number">0</span>] = -<span class="hljs-number">2</span>;<br>    <span class="hljs-type">double</span> y[] = x;<br>    y[<span class="hljs-number">1</span>] = -<span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> z[] = &#123;-<span class="hljs-number">4</span>, -<span class="hljs-number">8</span>, -<span class="hljs-number">12</span>&#125;;<br>    x = z;<br>    <span class="hljs-comment">//x和z像两个小旗帜，x = z只是标明了x所指向的方向，并不是真的通过x所指的方向改变了A数组</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> A[] = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>&#125;;<br>    changeOrNot(k, A);<br>    System.out.println(<span class="hljs-string">&quot;k = &quot;</span> + k);      <span class="hljs-comment">//  1</span><br>    System.out.println(<span class="hljs-string">&quot;A[0] = &quot;</span> + A[<span class="hljs-number">0</span>]);<span class="hljs-comment">//  -2</span><br>    System.out.println(<span class="hljs-string">&quot;A[1] = &quot;</span> + A[<span class="hljs-number">1</span>]);<span class="hljs-comment">//  -3</span><br>    System.out.println(<span class="hljs-string">&quot;A[2] = &quot;</span> + A[<span class="hljs-number">2</span>]);<span class="hljs-comment">//   3</span><br>&#125;<br>    <span class="hljs-comment">//注意数组的[]相当于是一次取址，故使用[]时会改变对应的真实值，而不进行取址时不会改变对应的具体值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>javac需要后缀名，而java不需要后缀名</p><p>注意由于标准输出输入流是字节流所以在进行读写操作时注意将其转化成字符流</p><p>文件路径默认在当前module下</p><p>多种字节码文件的集合即jar包可以理解成对基本java的补充，即插件类似，其不仅有编写好的类还有相关的辅助资源</p><p>read(arr)其中的arr可以看做是一种容器，需要注意的是其前一次搬运的数据并不会被清空而是保留之前存放好的文件</p><p>缓冲流的读写速度要好于结点流，往往使用缓冲流而非节点流</p><p>类只有两种访问权限：default和public</p><p>子类的方法的权限修饰符必须要比父类的访问权限修饰符要更加宽松，否则当将子类的实例赋值给父类时，若子类更加严格的访问修饰符，则无法通过父类变量调用子类的方法</p><p><strong>抽象方法、实例方法和虚方法的区别：</strong></p><ul><li><strong>抽象方法：</strong>使用abstract修饰的方法，只能用来声明而不能实现，抽象方法必须声明在抽象类中，反过来抽象类中不一定要有抽象方法，抽象方法的作用就是强制子类实现该抽象方法（如果子类不是抽象类的话）</li><li><strong>实例方法：</strong>可以用对象的引用调用的都称之为实例方法，实例方法必须在对象实例化之后，通过对象引用进行调用</li><li><strong>虚方法：</strong>可以被覆写的方法都称之为虚方法，因此虚方法并不需要进行特殊的声明（即虚方法是默认的，在java中不存在virtual关键词）</li></ul><p><strong>泛型方法</strong>中  <strong>T</strong>  的含义：</p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211013122204.png" alt="微信图片_20211013122204"></p><p><strong>编译看左边，运行看右边的理解：</strong></p><ul><li><strong>编译看左边：</strong>虽然实际运行的方法是子类中的方法，但这个方法必须要在父类中定义过（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了）</li><li><strong>运行看右边：</strong>实际调用的方法是右侧变量的方法</li></ul><p>A a&#x3D;new B()：引用变量a决定了调用的是A类中的方法和属性，而引用的的对象类型B确定了调用的方法，如果B覆盖了A类的方法，那么调用B中重写的方法；如果没有覆盖，调用A类中的方法； 方法调用的优先问题 ：优先级由高到低依次为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)    （和编译看左边，运行看右边并不冲突）</p><p>（优先调用左边的父类，其次调用右边的父类，一次保证只用一次父类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>  ... &#123;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(D obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);<br>         &#125; <br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);<br>         &#125; <br>&#125;  <br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">B</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">A</span> ... &#123;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(B obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);<br>         &#125; <br>&#125;<br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">C</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">B</span> &#123;&#125;  <br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">D</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">B</span> &#123;&#125;  <br> <span class="hljs-type">A</span> <span class="hljs-variable">a1</span>  <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">A</span>();<br> <span class="hljs-type">A</span> <span class="hljs-variable">a2</span>  <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">B</span>();<br> <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>     <span class="hljs-keyword">new</span>  <span class="hljs-title class_">B</span>();<br> <span class="hljs-type">C</span> <span class="hljs-variable">c</span>  <span class="hljs-operator">=</span>    <span class="hljs-keyword">new</span>  <span class="hljs-title class_">C</span>(); <br> <span class="hljs-type">D</span> <span class="hljs-variable">d</span>  <span class="hljs-operator">=</span>    <span class="hljs-keyword">new</span>  <span class="hljs-title class_">D</span>(); <br>System.out.println(a2.show(b));  B and A<br>System.out.println(a2.show(c));  B and A<br>System.out.println(a2.show(d));  A and D<br>System.out.println(b.show(b));   B and B<br>System.out.println(b.show(c));   B and B<br>System.out.println(b.show(d));   A and D   <br><br></code></pre></td></tr></table></figure><p>（目前看来）没有返回值是迭代器的方法，注意有时返回的是接口名，即返回继承这个接口的子类，相当于使用了多态</p><p><strong>静态导入</strong>可以帮助您使用静态成员的简单名称来简化程序的编写和读取，但是有时静态导入可能会在程序中引入细微的错误，这可能很难调试，故尽量减少使用静态导入</p><p><a href="https://blog.csdn.net/u010859650/article/details/85009595?ops_request_misc=%7B%22request_id%22:%22163525828516780269811366%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163525828516780269811366&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-85009595.pc_search_result_control_group&utm_term=%E8%AF%A6%E8%A7%A3Java%E4%B8%ADComparable%E5%92%8CCompartor%E6%8E%A5%E5%8F%A3&spm=1018.2226.3001.4187">Java中Comparable和Comparator接口的区别_</a></p><p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211026222630.jpg" alt="微信图片_20211026222630"></p><p>静态字段和非静态字段在初始化的时候都会被默认赋初始值，不同的是：静态字段是在在类加载的准备阶段时被赋值初始值，而非静态字段是在对象被创建的时候被赋初始值,本地变量，即方法中的变量不会被系统默认赋初始值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Java%E7%AC%94%E8%AE%B0Part1/"/>
    <url>/2023/03/06/Java%E7%AC%94%E8%AE%B0Part1/</url>
    
    <content type="html"><![CDATA[<p>api (application programming interface)应用程序编程接口。</p><h3 id="对于Java而言"><a href="#对于Java而言" class="headerlink" title="对于Java而言:"></a>对于Java而言:</h3><p>java api是指java标准类库提供的函数，android开发的api是指android sdk函数库。</p><h3 id="对于网站而言："><a href="#对于网站而言：" class="headerlink" title="对于网站而言："></a>对于网站而言：</h3><p>网站api一般是指一个网站提供的接口，比如登录验证、信息查询、通知、支付等等。</p><h3 id="对于Windows操作系统而言："><a href="#对于Windows操作系统而言：" class="headerlink" title="对于Windows操作系统而言："></a>对于Windows操作系统而言：</h3><p>windows api是指windows操作系统提供的api。</p><p>类和对象有时都统称*”<em>对象</em>“<em>，为了明确起见，后者称为</em>“*对象实例”</p><h3 id="封装性的特点"><a href="#封装性的特点" class="headerlink" title="封装性的特点"></a>封装性的特点</h3><ul><li><p>模块化：将属性和行为封装在类中，程序定义很多类。</p></li><li><p>信息隐蔽：将类的细节部分隐藏起来，用户只通过受保护的接口访问某个类。</p></li></ul><h3 id="继承性的特点"><a href="#继承性的特点" class="headerlink" title="继承性的特点"></a>继承性的特点</h3><ul><li>继承性：父类和子类之间共享数据和方法</li><li>继承的好处：更好的进行抽象与分类；增强代码的重用率；提高可维护性；</li></ul><h3 id="多态性的特点"><a href="#多态性的特点" class="headerlink" title="多态性的特点"></a>多态性的特点</h3><ul><li><p>不同的对象收到同一个消息(调用方法)可产生完全不同的效果</p></li><li><p>实现的细节则由接收对象自行决定</p></li></ul><p>boolean类型数据只允许取值 true或false，并且不可以0或非0的整数替代 true和false </p><p>Java字符采用Unicode编码，每个字符占两个字节</p><h3 id="数字进制的特点"><a href="#数字进制的特点" class="headerlink" title="数字进制的特点"></a>数字进制的特点</h3><ul><li><p>十进制整数，如12，-314，0</p></li><li><p>八进制整数，要求以0开头，如012</p></li><li><p>十六进制数，要求以0x或0X开头，如0x12</p></li><li><p>二进制数，以0b或0B开头，如0b00010010</p></li></ul><p>Java浮点型常量默认为<strong>double型</strong>，如要声明一个常量为float型，则需在数字后面加 f或F</p><h4 id="标识符要满足如下的规定："><a href="#标识符要满足如下的规定：" class="headerlink" title="标识符要满足如下的规定："></a>标识符要满足如下的规定：</h4><p>a. 标识符可以由字母、数字和下划线_、美元符号$组合而成</p><p>b. 标识符必须以字母、下划线或美元符号开头，不能以数字开头</p><h4 id="标识符定义特点："><a href="#标识符定义特点：" class="headerlink" title="标识符定义特点："></a>标识符定义特点：</h4><p>按Java惯例，类名首字母用大写，其余的(包名、方法名、变量名)首字母都小写</p><p>少用下划线，变量、常量随时用随时定义</p><p>“+”运算符两侧的操作数中只要有一个是字符串String类型，系统会自动将另一个操作数转换为字符串然后再进行连接。</p><p>整型提升：所有的byte，short，char参与算术运算等转为 int，即使是两个byte相加也是变成int</p><h4 id="Java中可以采用三种注释方法："><a href="#Java中可以采用三种注释方法：" class="headerlink" title="Java中可以采用三种注释方法："></a>Java中可以采用三种注释方法：</h4><ul><li><p>单行注释&#x2F;&#x2F;：注释从&#x2F;&#x2F;开始，终止于行尾</p></li><li><p>多行注释&#x2F; <em>… * &#x2F;：注释从&#x2F;</em> 开始，到 *&#x2F;结束，且这种注释不能互相嵌套</p></li><li><p>Java所特有的doc注释&#x2F;** … <em>&#x2F;：注释从&#x2F;</em>* 开始，到 *&#x2F;结束</p></li></ul><h4 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h4><p>第三种注释主要是为了支持JDK工具<strong>javadoc</strong>而采用的注释方法</p><p><strong>javadoc</strong>能识别注释中用标记@标识的一些特殊变量，并把doc注释加入它所生成的HTML文件</p><p>常用的@标记如下：</p><p>@see：引用其他类</p><p>@version：版本信息</p><p>@author：作者信息</p><p>@param：参数名说明</p><p>@return：说明</p><p>@exception：异常说明</p><p>对于有@标记的注释，javadoc在生成有关程序的文档时，会自动地识别它们，并生成相应的文档。</p><p>如：生成：javadoc HelloDate.java </p><h2 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML?"></a>什么是HTML?</h2><p><strong>HTML 是用来描述网页的一种语言。</strong></p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><p>数组声明时，[ ]放到数组名前后均可。（int[ ]a   int a[ ]）作用相同</p><p>Java语言中声明（注意是声明，在实例化数组的时候还是要指明长度的）数组时不能指定其长度 (数组中元素的个数)</p><p><strong>二维数组的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型 数组名 [ ][ ] = new 数据类型[m][n]</span><br><span class="hljs-comment">//数据类型 [ ][ ]  数组名 = new 数据类型[m][n]</span><br><span class="hljs-comment">//数据类型 [ ]  数组名 [ ] = new 数据类型[m][n]</span><br><span class="hljs-comment">//即[]放在数组名前后均可</span><br><br><span class="hljs-comment">//二维数组可以使用静态初始化的方式进行不规则初始化</span><br><span class="hljs-type">int</span> [][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;&#125;;<br><br><span class="hljs-comment">//定义数组的时候必须从最高级的维度进行初始化</span><br><span class="hljs-type">int</span>[][][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//t</span><br><span class="hljs-type">int</span>[][][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][];<span class="hljs-comment">//t</span><br><span class="hljs-type">int</span>[][][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>][][];<span class="hljs-comment">//t</span><br><br><span class="hljs-type">int</span>[][][]a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">10</span>][][<span class="hljs-number">10</span>];<span class="hljs-comment">//f</span><br><br></code></pre></td></tr></table></figure><p>数组已经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。</p><p>数值类型是0，引用类型是null </p><p>如果没有extends子句，则该类默认为 java.lang.Object 的子类并且所有的类都是通过直接或间接地继承 java.lang.Object得到的。</p><ul><li><p>如果对父类方法只是改写方法体，则称之为对父类方法的<strong>改写</strong>。</p></li><li><p>如果对父类方法的参数类型和方法体都改变，则称之为对父类方法的<strong>重载</strong>.</p></li></ul><p>字段&#x3D;域&#x3D;成员变量</p><h3 id="super关键字的使用方法："><a href="#super关键字的使用方法：" class="headerlink" title="super关键字的使用方法："></a>super关键字的使用方法：</h3><ul><li><p>正是由于继承，使用this可以访问父类的域和方法。但有时为了明确地指明父类的域和方法，就要用关键字super。例如，父类Student有一个域age，在子类Student中用age，this.age， </p><p>super.age来访问age是完全一样的</p></li><li><p>使用super不能访问在子类中添加的域和方法</p></li><li><p>使用super可以访问被子类所隐藏了的同名变量，例如，当覆盖父类的同名方法的同时，又要调用父类的方法，就必须使用super  该关键词的意义实际上是在覆盖父类的方法的同时，又利用已定义好的父类的方法</p></li></ul><h4 id="构造方法在父类的变化："><a href="#构造方法在父类的变化：" class="headerlink" title="构造方法在父类的变化："></a>构造方法在父类的变化：</h4><ul><li><strong>构造方法是不能继承的</strong>，比如，父类Person有一个构造方法 Person(String,int)，不能说子类Student也自动有一个构造方法 Student(String,int)，但是，子类在构造方法中，可以用super来调用父类的构造方法，并且使用时，<strong>super()必须放在第一句</strong></li><li>可理解为构造方法必须是和类同名的构造方法</li></ul><h4 id="父类对象与子类对象的转换"><a href="#父类对象与子类对象的转换" class="headerlink" title="父类对象与子类对象的转换"></a>父类对象与子类对象的转换</h4><p>类似于基本数据类型数据之间的强制类型转换，存在继承关系的父类对象和子类对象之间也可以在一定条件下相互转换：</p><ul><li><p>子类对象可以被视为其父类的一个对象，父类对象不能被当作其某一个子类的对象（狗可以看做是动物但动物不能看做是狗）</p></li><li><p>如果一个方法的形参定义的是父类对象，那么调用这个方法时，可以使用子类对象作为实参传入这个形参中</p></li><li><p>如果父类对象引用指向的实际是一个子类对象，那么这个父类对象引用可以用强制转换类型转变成子类对象的引用</p></li></ul><p>为了能使用Java中已提供的类，需要用 import语句来导入所需要的类</p><h3 id="非访问控制符的使用："><a href="#非访问控制符的使用：" class="headerlink" title="非访问控制符的使用："></a>非访问控制符的使用：</h3><table><thead><tr><th align="center"></th><th align="center">基本含义</th><th align="center">修饰类</th><th align="center">修饰成员</th><th align="center">修饰局部变量</th></tr></thead><tbody><tr><td align="center">static</td><td align="center">静态的、非实例的、类的</td><td align="center">可用来修饰内部类</td><td align="center">yes</td><td align="center"></td></tr><tr><td align="center">final</td><td align="center">最终的、不可改变的</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">abstract</td><td align="center">抽象的、不可实例化的</td><td align="center">yes</td><td align="center">yes</td><td align="center"></td></tr></tbody></table><h2 id="static的使用方法："><a href="#static的使用方法：" class="headerlink" title="static的使用方法："></a>static的使用方法：</h2><h4 id="1、静态变量"><a href="#1、静态变量" class="headerlink" title="1、静态变量"></a>1、静态变量</h4><ul><li><p>静态变量最本质的特点是：<strong>他们是类的变量，不属于任何一个对象实例</strong></p></li><li><p>它不保存在某个对象实例的内存区间中，而是保存在类的内存区域的公共存储单元</p></li><li><p><strong>类变量可以通过类名直接访问，也可以通过实例对象来访问，两种方法的结果是相同的</strong></p></li><li><p>如 System类的 in和out 对象，就是类的静态变量，直接用类名来访问，即System.in和System.out</p></li><li><p>在一定程度上，可以将静态变量看作是全局变量</p></li></ul><h4 id="2、静态方法"><a href="#2、静态方法" class="headerlink" title="2、静态方法"></a>2、静态方法</h4><ul><li><p>用static修饰符修饰的方法仅属于类的静态方法，又称为类方法，与此相对，不用static修饰的方法，则为实例方法</p></li><li><p>类方法的本质是该方法是属于整个类的，不是属于某个实例的</p></li><li><p>声明一个方法为static有以下几重含义：</p><ul><li><p>a. 非static的方法是属于某个对象的方法，在这个对象创建时，<strong>对象的方法在内存中拥有自己专用的代码段。而static的方法是属于整个类的，它在内存中的代码段将随着类的定义而进行分配和装载，不被任何一个对象专有</strong></p></li><li><p>b. 由于static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即<strong>static方法只能处理本类中的static域或调用static方法</strong></p></li><li><p>c. static方法中，不能访问实例变量，不能使用<strong>this</strong>和<strong>super</strong> </p></li><li><p>d. <strong>调用这个方法时，应该使用类名直接调用</strong>，也可以用某一个具体的对项目例如：Math.random，Integer.parseInt()等就是类方法，直接用类名进行访问</p></li></ul></li></ul><h4 id="3、静态代码块"><a href="#3、静态代码块" class="headerlink" title="3、静态代码块"></a>3、静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态代码块的特点：<strong>随着类的加载而执行，而且只执行一次</strong></li><li>执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即static修饰的数据成员</li><li><strong>执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，在每个对象生成时都会被执行一次，它可以初始化类的实例变量</strong>。非静态初始化块会在构造函数执行时，在构造函数主体代码执行之前被运行</li><li>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，<strong>它不在任何的方法体内</strong>，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次</li><li>static 方法和变量能独立于任何对象而被使用</li></ul><h2 id="final的使用方法："><a href="#final的使用方法：" class="headerlink" title="final的使用方法："></a>final的使用方法：</h2><h3 id="1-final变量"><a href="#1-final变量" class="headerlink" title="1.final变量"></a>1.final变量</h3><ul><li>final变量的值一旦给定，就不能更改并且是只读量，它们能且只能被赋值一次，而不能被赋值多次</li><li>一个字段被<strong>static</strong>、<strong>final</strong>两个修饰符所限定时（即1、这个变量是属于类，为所有的对象所共有，2、且只能被赋值一次），他可以表示常量 </li><li>在定义static final域时，若不给定初始值，则按默认值进行初始化</li><li>在定义final字段时，若不是static的域，则必须且只能赋值一次，不能缺省并且这种变量的赋值方式有两种：a.定义变量的时候赋初始值  b.在每一个构造函数中进行赋值</li><li>final变量和常量的区别：在定义final局部变量时，也必须且只能赋值一次。它的值可能不是常量，但它的取值在变量存在期间不会改变</li></ul><h3 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2.final方法"></a>2.final方法</h3><p>final修饰符所修饰的方法，<strong>是不能被子类所覆盖的方法</strong></p><h3 id="3-final类"><a href="#3-final类" class="headerlink" title="3.final类"></a>3.final类</h3><p>如果一个类被final修饰符所修饰和限定，说明<strong>这个类不能被继承</strong>，即不可能有子类 </p><h2 id="abstract的使用方法："><a href="#abstract的使用方法：" class="headerlink" title="abstract的使用方法："></a>abstract的使用方法：</h2><ul><li>抽象类不能被实例化</li><li>被abstract所修饰的方法叫抽象方法，<strong>抽象方法的作用在为所有子类定义一个统一的接口</strong>。对抽象方法只需声明，而不需实现，**即用分号；而不是用{}**，格式如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> returnType <span class="hljs-title function_">abstractMethod</span><span class="hljs-params">([paramlist])</span>；<br></code></pre></td></tr></table></figure><ul><li>抽象类中可以包含抽象方法，也可以不包含abstract方法。但是，一旦某个类中包含了abstract方法，则这个类必须声明为abstract类</li><li>抽象方法在子类中必须被实现，否则子类仍是abstract的</li></ul><p><strong>this可用于调用构造器来替代多种构造器中的重复代码（高级构造器是在基础构造器的基础上改造）</strong></p><h3 id="接口的使用方法"><a href="#接口的使用方法" class="headerlink" title="接口的使用方法"></a>接口的使用方法</h3><p><strong>接口中的所有方法都自动是public abstract，并且可以实现多继承</strong></p><p>接口的作用：</p><ul><li><p>a. 通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系。从而在一定意义上实现了多重继承。</p></li><li><p>b. 通过接口可以指明多个类需要实现的方法</p></li><li><p>c. 通过接口可以了解对象的交互界面，而不需了解对象所对应的类</p><p><strong>通常接口以able或ible结尾，表明接口能完成一定的行为</strong></p><p>public指明任意类均可使用这个接口，缺省情况下，只有与该接口定义在同一个包中的类才可以访问这个接口</p><p>extends子句与类中的extends子句基本相同，不同的是一个接口可 以有多个父接口，<strong>用逗号隔开</strong>，而一个类只能有一个父类。子接口继承父接口所有的常量和方法</p></li></ul><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><ul><li>在类的声明中用implements子句来表示一个类使用某个接口，在类体中可以使用接口中定义的常量，而且必须实现接口中定义的所有方法，注意一个类可以实现多个接口</li><li>接口中不能定义变量，只能定义常量，在接口中定义的常量具有public,static,final的属性</li><li>在Java8中可以使得接口成员可以是static方法，其类似为默认方法（这种方法的好处是：提供了一个默认实现，子类在implements可以不用再重新写了）</li><li>默认方法有方法体，由default修饰符修饰，是接口中定义方法的默认实现</li></ul><p><strong>标准格式：</strong><code>class A extends B implements C,D,E</code></p><h4 id="完整的Java源文件格式"><a href="#完整的Java源文件格式" class="headerlink" title="完整的Java源文件格式"></a>完整的Java源文件格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> packageName; <span class="hljs-comment">//指定文件中的类所在的包，0个或1个 </span><br><span class="hljs-keyword">import</span> packageName.[className|*]; <span class="hljs-comment">//指定引入的类，0个或多个 </span><br><span class="hljs-keyword">public</span> classDefinition <span class="hljs-comment">//属性为public的类定义，0个或1个 </span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Definition</span> and classDefinition <span class="hljs-comment">//接口或类定义，0个或多个</span><br></code></pre></td></tr></table></figure><ul><li>源文件的名字必须与属性为public的类的类名完全相同</li><li>在一个.java文件中，package语句和public类最多只能有1个 ，当然也可以没有</li><li><strong>对于引用型变量，传递的值是引用值，而不是复制对象实体</strong></li></ul><h4 id="字段变量和局部变量的区别"><a href="#字段变量和局部变量的区别" class="headerlink" title="字段变量和局部变量的区别"></a>字段变量和局部变量的区别</h4><ul><li><p>字段变量是在类中，局部变量是方法中定义的变量或方法的参变量</p></li><li><p>从内存角度来看：</p><ul><li><p>存储位置：字段变量为对象的一部分、存在于堆中的，局部变量是存在于栈中 </p></li><li><p>生命周期不同：<strong>栈内存中的局部变量随着方法的消失而消失</strong> <strong>成员变量存储在堆中的对象里面，由垃圾回收器负责回收</strong>。</p></li><li><p>初始值：<strong>字段变量可以自动赋初值，局部变量则须显式赋值</strong></p></li></ul></li><li><p>从修饰符的角度来看：</p><ul><li>字段变量属于类，可以用public、private、static、final修饰</li><li>局部变量不能够被访问控制符及static修饰</li><li>都可以被final修饰</li></ul></li></ul><p><strong>方法的返回值可以是基本类型也可以是引用类型，并且当返回类型是引用类型时，它可以存取对象实体</strong></p><p><a href="https://blog.csdn.net/lazyzhong1/article/details/84511852">上溯造型和下溯造型</a></p><h4 id="构造器的使用"><a href="#构造器的使用" class="headerlink" title="构造器的使用"></a>构造器的使用</h4><ul><li>this调用本类中的其他构造方法，super调用直接父类的构造方法</li><li><strong>使用this或super调用构造器需要放在第一条语句，且只能够有一条</strong></li><li><strong>如果没有this及super，则编译器自动加上super()，即调用直接父类不带参数的构造方法（这样做的目的在于必须令所有父类的构造方法都得到调用，否则整个对象的构建就可能不正确）</strong></li></ul><h4 id="关于自动调用"><a href="#关于自动调用" class="headerlink" title="关于自动调用"></a>关于自动调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    A(<span class="hljs-type">int</span> a)&#123;&#125; <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    B(String s)&#123;<br>        <span class="hljs-comment">//隐式调用了A()</span><br>        <span class="hljs-comment">//注意调用的是A()而不是A(String s)</span><br>    &#125;<span class="hljs-comment">//编译不能够通过 </span><br>&#125; <br></code></pre></td></tr></table></figure><ul><li>出错原因：编译器会自动调用B(String s){ super(); }出错</li><li>解决方法<ul><li>在B的构造方法中，加入super(3); </li><li>在A中加入一个不带参数的构造方法，A(){}；</li><li>去掉A中全部的构造方法，则编译器会自动加入一个不带参数的构造方法，称为默认的构造方法</li></ul></li></ul><h4 id="创造对象时就对其进行初始化"><a href="#创造对象时就对其进行初始化" class="headerlink" title="创造对象时就对其进行初始化"></a>创造对象时就对其进行初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;&#123; <span class="hljs-comment">//针对于没有相应构造函数，又要赋值的类</span><br>    age=<span class="hljs-number">18</span>;      <span class="hljs-comment">//注意使用了双括号</span><br>    name=<span class="hljs-string">&quot;李明&quot;</span>; <br>&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="对象清除和垃圾回收机制"><a href="#对象清除和垃圾回收机制" class="headerlink" title="对象清除和垃圾回收机制"></a>对象清除和垃圾回收机制</h4><ul><li>对象清除：在Java中使用new来创建对象，而Java中是自动清除</li><li>对象回收是由Java虚拟机的垃圾回收线程来完成的</li><li>垃圾回收的判定方式：<strong>任何对象都有一个引用计数器，当其值为0时，说明该对象可以回收</strong></li></ul><h4 id="内部类、局部类"><a href="#内部类、局部类" class="headerlink" title="内部类、局部类"></a>内部类、局部类</h4><ul><li><p><strong>内部类</strong>：定义在一个类中的类即为内部类</p><p>内部类的注意：</p><ul><li><p>内部类不能和外部类重名；</p></li><li><p>若内部类在封装它的类中内部使用内部类，则和使用普通类的方式相同；若内部类在其他位置使用，则在使用内部类前要冠以外部类的名字</p></li><li><p><strong>在使用new创建内部类实例时，也要在new前面冠以对象变量，格式：外部对象名.new 内部类名(参数)</strong></p></li><li><p>在内部类中可以直接访问外部类的字段和方法（即使是private也可以），若内部类和外部类有同名的字段或者方法，则可以使用  外部类名.this.字段及方法进行调用</p></li><li><p>内部类与类中的字段、方法一样是外部类的成员，它的前面也可以有访问控制符和其他修饰符</p><ul><li><p>特殊的：使用static修饰内部类时，表明该内部类实际上是一种外部类，因为其实际上和外部类的实例无关</p></li><li><p>static使用方法：</p><p>i. 实例化static类时，在new前面不需要用对象实例变量</p><p>ii. static类中不能访问其外部类的非static的字段及方法，即只能访问static成员</p><p>iii. static方法中不能访问非static的域及方法，也不能够不带前缀地new一个非static的内部类</p></li></ul></li></ul></li><li><p><strong>局部类</strong>：定义在方法中的类，也可理解为“方法中的内部类”</p><p>局部类的注意：</p><ul><li>同局部变量一样，方法中的内部类：不能够用public、private、protected、static修饰，但可以被final或者abstract修饰</li><li>可以访问其外部类的成员</li><li>不能够访问该方法的局部变量，除非是final局部变量</li></ul><h4 id="匿名类的使用"><a href="#匿名类的使用" class="headerlink" title="匿名类的使用"></a>匿名类的使用</h4><ul><li>匿名类的定义：是一种特殊的内部类，它没有类名，在定义类的时候就生成了一个该对象的实例，即相当于<strong>“一次性使用”的类</strong></li><li>匿名类的特点：<ul><li><p>不取名字，直接用其父类或接口的名字，也就是说，该类是父类的子类，或者实现了一个接口</p></li><li><p>类的定义的同时就创建实例，即理解为类的定义前面有一个<strong>new</strong></p><ul><li>格式：new 类名或接口名(){…}    比普通构造函数多一对{}</li><li>不使用关键词class，也不使用extends及implements</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建的匿名类继承了 Polygon 类，在实现多态的时候就进行了重写</span><br><span class="hljs-comment">//注意区分匿名类和匿名对象</span><br>      <span class="hljs-type">Polygon</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Polygon</span>() &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;在匿名类内部。&quot;</span>);<br>       &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure></li><li><p>在构造对象时使用父类构造方法，其本身无法使用构造方法，因为它没有名字，注意该类实例化对象时如果需要参数，则使用父类的构造方法(构造器的名字必须和类的名字相同)</p></li></ul></li></ul><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换<img src="https://img-blog.csdnimg.cn/20181219203059531.png" alt="img"></h4><h3 id="基本类型的包装类"><a href="#基本类型的包装类" class="headerlink" title="基本类型的包装类"></a>基本类型的包装类</h3><ul><li>基本类型包装类产生的意义：java是一门面向对象的语言，但是在Java中基本数据类型不具备面向对象的特征，所以实际使用中很不便所以为java八种基本数据类型提供了对应的包装类。</li><li>自动拆箱：<strong>包装类——&gt;基本数据类型</strong> (原理是调用了xxxValue方法)  </li><li>自动装箱：<strong>基本数据类型——&gt;包装类</strong> (原理是调用了valueOf方法)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer I=<span class="hljs-number">10</span>;<span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> i=I;<span class="hljs-comment">//拆箱</span><br><span class="hljs-comment">//实际译为以下 </span><br><span class="hljs-comment">//Integer I=Integer.valueOf(10); </span><br><span class="hljs-comment">//int i=I.intValue();</span><br>Object []ary=&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&quot;aaa&quot;</span>&#125;;<span class="hljs-comment">//主要做的目的是方便用于集合中</span><br></code></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>注解的定义：注解（annotation）又称为注记、标记、标注、注释 (不同于comments)</li><li>注解的意义：<strong>在各种语法要素上加上附加信息，以供编译器或其他程序使用</strong></li><li>注解所在的父类：所有的注解都是java.lang.annotation.Annotation的子类</li><li>常用的注解类型：<ul><li>@Override 表示覆盖父类的方法</li><li>@Deprecated 表示过时的方法</li><li><strong>@SuppressWarnings 表示让编译器不产生警告</strong></li></ul></li><li>存在自定义注解，但使用比较复杂</li></ul><h4 id="没有指针的Java语言"><a href="#没有指针的Java语言" class="headerlink" title="没有指针的Java语言"></a>没有指针的Java语言</h4><p>实际上引用(reference )本身的实质就是指针(pointer),但是在Java语言中所使用的的指针是安全的、受控的，其表现为如下几个方面</p><ul><li>会检查空指引</li><li>没有指针运算 *(p+5)</li><li>不能访问没有引用到的内存</li><li>自动回收垃圾</li></ul><p>对于引用类型来说，引用本身就相当于是指针，可以用来修改对象的属性、调用对象的方法</p><p>实际上Java语言中的许多特性就相当于对指针的使用：</p><ul><li>数组–&gt;指针运算</li><li>接口、Lambda表达式–&gt;函数指针</li><li>对象的引用–&gt;指向结点的指针</li></ul><h4 id="对于Java语言中的相等概念的理解"><a href="#对于Java语言中的相等概念的理解" class="headerlink" title="对于Java语言中的相等概念的理解"></a>对于Java语言中的相等概念的理解</h4><p>简单地说，<strong>基本类型是值相等，引用类型是引用相等</strong>，但有不少的具体情况具体分析，如下</p><ul><li><p>对于基本类型的比较</p><ul><li><p>数值类型：转换后才能进行比较</p></li><li><p>特殊的，Boolean型无法与int相比较</p></li><li><p>浮点数类型：一般不直接用&#x3D;&#x3D;来进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Double.NAN==Double.NAN; <span class="hljs-comment">//结果为false 详见JDK的API文档</span><br><span class="hljs-comment">//由于浮点数在计算机当中的存储方式的不同，所存储的浮点数的最后一位可能浮动</span><br></code></pre></td></tr></table></figure><p>相等判定常见易错题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <br>Integer j=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <br>System.out.println(i==j); <br><span class="hljs-comment">//false,因为对象是两个 </span><br>Integer m=<span class="hljs-number">10</span>; <br>Integer n=<span class="hljs-number">10</span>; <br>System.out.println(m==n); <br><span class="hljs-comment">//true,因为对象有缓存，m,n都指向缓存区的integer对象 </span><br>Integer p=<span class="hljs-number">200</span>; <br>Integer q=<span class="hljs-number">200</span>; <br>System.out.println(p==q); <br><span class="hljs-comment">//false,因为对象是两个</span><br><br><span class="hljs-comment">//由于IntegerCache的存在，使用第一种方法初始化的对象，如果值的范围在-128~127之间，则相同的值会被包装的同一对象中  而用new产生的对象不同于前一种方式产生的对象不会在同一内存区域</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">47</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">47</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">47</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-number">47</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br> <br>        System.out.println(n1 == n2);   <span class="hljs-comment">//false，两个new的对象</span><br>        System.out.println(n1 == n3);   <span class="hljs-comment">//false  n1在堆中，n3指向IntegerCache缓存（方法区中）</span><br>        System.out.println(n3 == n4);   <span class="hljs-comment">//true   都指向缓存中同一个对象</span><br>        System.out.println(n5 == n6);   <span class="hljs-comment">//false  超出缓存范围，分别是两个new出来的对象</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>对于引用类型的比较</p><ul><li>是直接看两个引用是否一样</li><li>如果要判断内容是否一样，则要重写 equals方法</li><li>如果重写equals方法，则最好重写 hashCode()方法</li></ul></li><li><p>对于字符串类型的比较</p><ul><li>判断相等，一定不要用**&#x3D;&#x3D;<strong>，要用</strong>equals**</li><li>但是字符串常量(String literal) 及字符串常量会进行内部化(interned)，相同的字符串常量是&#x3D;&#x3D;的</li></ul><p>常见字符串类型比较易错题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">String hello=<span class="hljs-string">&quot;Hello&quot;</span>,lo=<span class="hljs-string">&quot;lo&quot;</span>; <br>System.out.println(hello==<span class="hljs-string">&quot;Hello&quot;</span>);<span class="hljs-comment">//true</span><br>System.out.println(hello==(<span class="hljs-string">&quot;Hel&quot;</span>+<span class="hljs-string">&quot;lo&quot;</span>));<span class="hljs-comment">//true </span><br>System.out.println(hello==<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<span class="hljs-comment">//false</span><br>System.out.println(hello==(<span class="hljs-string">&quot;Hel&quot;</span>+lo).intern()); <span class="hljs-comment">//true</span><br><span class="hljs-comment">//intern() 方法返回字符串对象的规范化表示形式。</span><br><span class="hljs-comment">//它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。</span><br><span class="hljs-comment">//在java中下面两种方式创建字符串的方式都是在堆空间中开辟新的空间存放字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(str1 == str2); <span class="hljs-comment">// false</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;----------比较引用地址是否相等---------------&quot;</span>);<br>        System.out.println(s1 == s2); <span class="hljs-comment">//t</span><br>        System.out.println(s2 == s3); <span class="hljs-comment">//f</span><br>        System.out.println(s3 == s4); <span class="hljs-comment">//f</span><br></code></pre></td></tr></table></figure></li></ul><p>阅读JDK API文档的方式</p><ul><li>在线查阅：<a href="http://docs.oracle.com/javase/8/docs/api/index.html">http://docs.oracle.com/javase/8/docs/api/index.html</a></li><li>文档下载：<a href="http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html">http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html</a></li></ul><p>阅读JDK源码</p><ul><li>JDK的源代码：安装JDK后即有 src.zip（例如：在C:\Program Files\Java\jdk\下 ）</li></ul><h4 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h4><ul><li>java.lang——Java语言的核心类库</li><li>java是自动导入java.lang.*的 </li><li>java.util——实用工具</li><li>java.io——标准输入&#x2F;输出类库</li><li>java.awt、javax.swing——图形用户界面GUI的类库</li><li>java.net——网络功能的类库</li><li>java.sql——数据库访问的类库</li></ul><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object类是所有类的直接或间接父类，该类让所有的类有了一致性</p><p>Object类中常用的方法：</p><ul><li>equals()<ul><li>简单的说，**&#x3D;&#x3D;是引用是否相等，equals是内容含义相等**</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer one=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>); <br>Integer anotherOne=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">if</span>(one==anotherOne);<span class="hljs-comment">//false </span><br><span class="hljs-keyword">if</span>(one.equals(anotherOne));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><ul><li>getClass()<ul><li>getClass() 方法是final方法，它不能被重载</li><li>它返回一个对象在运行时所对应的类的表示</li></ul></li><li>toString()<ul><li>toString()方法用来返回对象的字符串表示</li></ul></li><li>finalize()<ul><li>用于在垃圾收集前清除对象</li></ul></li><li>notify()、notifyAll()、wait()<ul><li>和线程相关的方法</li></ul></li></ul><h4 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h4><p>Java的基本数据类型用于定义简单的变量和属性将十分方便，但为了与面向对象的环境一致，Java中提供了基本数据类型的包装类wrapper，它们是这些基本类型的面向对象的代表</p><p>与8种基本数据类型相对应，基本数据类型的包装类也有8种，分别是：</p><p>Character、Byte、Short、Integer、Long、Float、Double、Boolean </p><h5 id="包装类的特点"><a href="#包装类的特点" class="headerlink" title="包装类的特点"></a>包装类的特点</h5><ul><li>这些类都提供了一些常数<ul><li>如Integer.MAX_VALUE(整数最大值)，Double.NaN(非数字，表示未定义或不可表示的值)，Double.POSITIVE_INFINITY(正无穷)等</li></ul></li><li>提供了 valueOf(String)，toString()<ul><li>用于从字符串转换及转换成字符串</li></ul></li><li>通过 xxxxValue()方法可以得到所包装的值<ul><li>Integer对象的intValue()方法</li></ul></li><li><strong>对象中所包装的值是不可改变的(immutable)</strong><ul><li>要改变对象中的值只有重新生成新的对象</li></ul></li><li>toString()、equals()等方法进行了覆盖</li><li>有的类还提供了一些实用的方法以方便操作<ul><li>例如，Double类就提供了parseDouble()、max、min方法</li></ul></li></ul><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Math类常用于完成一些常用的数学运算</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> E;<span class="hljs-comment">//数学常量e </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> PI;<span class="hljs-comment">//圆周率常量 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//绝对值 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//参数次幂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//不大于参数的最大整数 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> IEEE <span class="hljs-title function_">remainder</span><span class="hljs-params">(<span class="hljs-type">double</span> f1,<span class="hljs-type">double</span> f2)</span>;<span class="hljs-comment">//求余</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//自然对数 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span>;<span class="hljs-comment">//最大值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">float</span> a,<span class="hljs-type">float</span> b)</span>;<span class="hljs-comment">//最小值 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span>;<span class="hljs-comment">//乘方 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">random</span><span class="hljs-params">()</span>;<span class="hljs-comment">//产生0和1(不含1)之间的伪随机数 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">rint</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//四舍五入 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//平方根 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sin</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//正弦 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cos</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//余弦 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//正切 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">asin</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//反正弦 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acos</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//反余弦 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">atan</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<span class="hljs-comment">//反正切</span><br></code></pre></td></tr></table></figure><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><ul><li><p>在Java中，系统属性可以通过环境变量来获得</p><ul><li>System.getProperty(String name)方法获得特定的系统属性值</li><li>System.getProperties()方法获得一个 Properties类的对象，其中包含了所有可用的系统属性信息</li></ul></li><li><p>在命令行运行Java程序时可使用 -D选项添加新的系统属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Dvar=value MyProg<br></code></pre></td></tr></table></figure></li></ul><h4 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h4><ul><li><p>字符串可以分为两大类</p><ul><li>String类<ul><li>创建之后不能再进行修改和变动</li></ul></li><li>StringBuffer、StringBuilder类<ul><li>创建之后可以再去做更改和变化</li><li>其中StringBuilder是JDK1.5增加的，它是非线程安全的</li></ul></li></ul></li><li><h5 id="StringBuffered类"><a href="#StringBuffered类" class="headerlink" title="StringBuffered类"></a>StringBuffered类</h5><p><img src="C:\Users\小赵同学\AppData\Roaming\Typora\typora-user-images\image-20210426191527697.png" alt="image-20210426191527697"></p></li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量（environment variables）一般是指在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>中用来指定操作系统运行环境的一些参数，如：<a href="https://baike.baidu.com/item/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%A4%B9/1061467">临时文件夹</a>位置和<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%B9/5328647">系统文件夹</a>位置等。</p><p>环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F">变量</a>是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F">程序</a>所将使用到的信息。例如<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>和<a href="https://baike.baidu.com/item/DOS/32025">DOS</a>操作系统中的path环境变量，当要求系统运行一个<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525">程序</a>而没有告诉它程序所在的完整路径时，系统除了在<a href="https://baike.baidu.com/item/%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95/7205107">当前目录</a>下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F">变量</a>，来更好的运行进程。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/html&amp;css%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/html&amp;css%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>注释之间不能进行嵌套</p><p>属性可以写在开始标签或者自结束标签中，还可以设置属性，属性是个键值对的形式，具体的属性名和属性值取决于文档的编程规范，其中有些属性是没有值的，键值对之间使用空格进行分隔</p><p>文档声明(doctype)用于告诉浏览器当前网页的版本，位于<strong>第一行</strong>  例如：<!doctype html> 不区分大小写</p><p>meta标签用来设置网页的元数据可以通过meta标签来设置网页的字符集，避免出现乱码问题，meta标签写在head中</p><p>html是文件的根标签，网页中的所有元素都要出现在根元素的里面</p><p>head是网页的头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎来解析网页</p><p>title中的内容会显示在浏览器的标题栏，搜索引擎会根据title中的内容来判断页面的主要内容</p><p>body是html的子元素，表示网页的主题，网页中所有的可见内容都该放在body中，其中所有的内容都用户可见</p><p>例如空格或者&lt; 、&gt;该类的符号会被浏览器解析为别的意思，故需要使用实体来进行表示</p><p>使用meta中的属性进行命名时，注意对应的变量名是固定好的，而并不是自己随意添加的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML,ASP,PHP,SQL&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--name属性中可以赋值多个关键字，关键字之间用,隔开&gt;</span><br></code></pre></td></tr></table></figure><p>lang元素指的是使用的语言</p><p>在网页中html专门用来负责页面的结构，所以在使用html标签时<strong>，应该关注的是标签的语义而不是标签的格式</strong></p><p>不同的标题等级表示的是重要级，一般来说h1在网页中的重要性仅次于title，一般来说一个页面只会有一个h1，由于一般使用标题标签只会最多用到h3，剩下的很少用，因为其标注的重要性太低了</p><p>在页面中独占一行的元素称之为块元素(block element)</p><p>在页面中不会独占一行的元素称之为行内元素(inline element)</p><p>hgroup指的是标题组，用来为标签分组，可以将一组相关的标题放入同一个标题组</p><p>em标签用于表示语音语调的一个加重</p><p>strong表示的是强调的重要内容</p><p>q表示是一个短引用</p><p>blockquote是一个长引用</p><p>在网页中一般通过块元素对页面进行宏观的一些布局，而行内元素是主要用来包裹文字来实现特殊的效果，一般是在块元素中放置行内元素，而不会在行内元素中放块元素，并且p元素中不能放任何块元素</p><p>浏览器会在解析网页的时候，会自动对网页中不符合规范的内容进行修正，比如：将标签写在了根元素的外部、p元素中嵌套了块元素、根元素中出现了除了head和body以外的子元素</p><p>header表示网页的头部(可以有多个头部)</p><p>main表示网页的主题部分(一个页面中只会有一个main)</p><p>footer表示网页的底部</p><p>nav表示网页的导航</p><p>aside表示和网页主题相关的其他内容(侧边栏)</p><p>article表示的是一个独立的文章</p><p>section表示的是独立的区块，当以上的标签没办法合理的表示时，用section</p><p>div没有语义，就用来表示的是一个区块，目前往往还是div是页面的主要布局元素</p><p>span没有语义，是一个行内元素，一般用于网页中选中文字</p><p>ul表示的创建无序列表，使用li来表示列表项</p><p>ol表示的创建有序列表，用li表示列表项</p><p>dl表示定义列表，使用dt来表示定义的内容，使用dd来对内容进行解释说明</p><p>最常使用的是ul标签，并且列表之间可以互相嵌套</p><p>超链接也是一个行内元素，在a标签中可以嵌套除了它自身类型以外的任意元素</p><p>超链接的href可以指定外部的网站的地址，也可以写一个内部页面的地址，当我们需要跳转到一个服务器内部的页面时，一般我们都会使用相对路径，相对路径都会使用.&#x2F;或者..&#x2F;开头，如果没有以这两个开头，则会默认添加一个.&#x2F;</p><ul><li><p>.&#x2F;  表示的是文件所在目录</p></li><li><p>..&#x2F; 表示的是当前文件所在目录的上一级目录</p></li></ul><p>.&#x2F;inner&#x2F;123.html表示的是返回所在文件的目录下寻找inner文件夹进一步寻找123.html文件，所有文件都可以通过这样的方法往上往下寻找到的</p><p>可以将超链接的href属性设置为只有一个#，这样点击这个超链接以后，页面不会进行跳转，而是转到当前页面的顶部位置</p><p>id表示的是该元素的特定标识，每一个标签都可以添加一个id属性，同一个页面不能出现重复的id属性，id属性是字母开头</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#p3&quot;</span>&gt;</span>这里是一个超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>当点击这个超链接的时候会跳转到当前页面下id值为p3的标签位置<br></code></pre></td></tr></table></figure><p>img元素中的src属性指定的是外部图片的路径，这个路径可以是你存储的图片位置（路径的调用规则是一样的），也可以是网上图片的网络地址，img的alt属性表示的是对图片的描述，这个描述是在默认情况下不会显示，有些浏览器会在图片无法加载时显示，搜索引擎会根据这个属性进行识别图片</p><p>img属性中的width和height属性的单位是像素，如果只是改变两个其中一个则另外属性会跟着等比例变化，但是如果两个属性都赋值改变了则根据你赋值的值进行缩放，在pc端往往不改变图片的这两个属性，美工会裁剪好使用的图片，减少性能开销</p><p>常见的图片格式：</p><ul><li>jpeg(jpg)：支持的颜色比较丰富，不支持透明效果，不支持动图，一般用来显示照片</li><li>gif：支持的颜色比较少，支持简单透明和动图，一般用于单一的图片、动图</li><li>png:支持的颜色丰富，支持复杂透明，不支持动图，往往用网页部分</li><li>webp：该格式是谷歌新推出的专门用于表示页面中的图片格式，它具备其他三种格式的所有优点，而且文件还特别的小，但是缺点是其兼容性不好，有些老浏览器没办法兼容</li><li>base64：将图片使用base64编码，这样可以将图片转化成字符来引用页面中，一般是一些需要和页面一起加载的图片才会使用base64（直接将这个编码复制到img元素中的src内中）</li></ul><p>iframe表示创建一个内联框架，相当于在当前页面内创建了一个小分块来显示外部网页，其中也是使用src进行标注要显示的页面，可以通过改变iframe标签的属性来改变分块的大小</p><p>audio标签用于向页面引入一个外部的音频文件，音视频文件引入时默认情况不允许用户自己播放停止</p><p><strong>audio属性：</strong></p><ul><li>controls 是否允许用户控制播放(标注即可无需赋值)</li><li>autoplay音频文件是否自动播放(标注即可无需赋值)<ul><li>如果设置了autoplay则音乐会在打开文件的时候自动播放，但是目前大部分情况下是不允许其自动播放的</li></ul></li><li>loop属性表示的是循环播放(标注即可无需赋值)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 除了通过src来指定外部文件的路径以外，还可以通过source来指定文件的路径 --&gt;</span><br><span class="hljs-comment">&lt;!--使用source来指定文件的路径可以提高兼容性，比如有些浏览器不支持解析audio标签，则若使用较低版本浏览器解析以下代码，则会浏览器无法识别audio，source等，只显示出“对不起，您的浏览器不支持播放音频！请升级浏览器！” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>        对不起，您的浏览器不支持播放音频！请升级浏览器！<br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/audio.mp3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/audio.ogg&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/audio.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mp3&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- embed是一个比较老的标签用于兼容老的浏览器 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        使用video标签来向网页中引入一个视频</span><br><span class="hljs-comment">            - 使用方式和audio基本上是一样的</span><br><span class="hljs-comment"> --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/flower.webm&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/flower.mp4&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./source/flower.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>内联样式相当于将html和css复合起来了，使得其耦合，这样的样式不合理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--注意在style标签内部的部分不再属于html的部分，该标签中的命名格式和逻辑不符合html的逻辑，应该遵循的是Css的规范--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span><br><span class="language-css">      <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">          <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">          <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>由于id具有独特性，不能有重复的元素，所以html中有class来保证相似元素的类型设置，对应的有id选择器和class选择器，一般在开发中往往使用class选择器，同时可以对一个元素指定多个class，多个class之间使用空格隔开</p><p><strong>选择器分类：</strong>元素选择器、id选择器、类选择器、通配选择器（所有元素都用这个格式）</p><p>块元素也有对应的title属性，当光标放置在这个属性上时，会显示出来对应的title</p><p>通过css添加的文字无法用光标进行选择</p><p>由于内联样式的设定的优先级最高，所以一般不建议使用内联样式去决定元素的样式，一旦使用内联样式去指定元素的样式会使得该元素无法被修改</p><p>当样式编写后没有被生效，可能是因为选择器的权重没有被记录</p><p>当子元素相加的元素加起来不等于父元素内容区的宽度，则称之为过度约束，即等式会自动进调整使得等式保持满足</p><p>如果父元素没有设置高度，则其高度取决于子元素的高度大小（子元素将父元素所撑开）</p><p>如果父元素设置了高度，则父元素的高度取决于其自身所定义的高度</p><p>可以使用overflow属性来设置父元素如何处理溢出的子元素</p><p>相邻的垂直方向外边距会发生重叠现象，兄弟元素之间的响铃垂直外边距会取两者之间的较大值（两者都是正值，如果相邻的外边距一正一负，则取二者的和，如果相邻的外边距都是负值，则取两者中绝对值较大的）</p><p>display可以用来设置成元素显示的类型</p><p>在开发中由于浏览器自带样式，并且每一款浏览器所自带的样式不同，为统一浏览器样式，需要对浏览器的默认样式进行清除</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 去除浏览器本身的默认样式--&gt;</span><br><span class="hljs-comment">&lt;!-- 方法一：使用通配选择器来清除浏览器默认样式--&gt;</span><br>*&#123;<br>    margin: 0;<br>    padding: 0;<br> &#125;<br><span class="hljs-comment">&lt;!-- 方法二：使用经典的重置样式表css文件进行清除--&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        重置样式表：专门用来对浏览器的样式进行重置的</span><br><span class="hljs-comment">            reset.css     直接去除了浏览器的默认样式</span><br><span class="hljs-comment">            normalize.css 对默认样式进行了统一</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> --&gt;</span><br></code></pre></td></tr></table></figure><p>在设置导航条的时候，如果所需的导航条是横向的，则需要将元素设置为<strong>浮动</strong></p><p>可以将公共的样式重写到另外一个<strong>单独的选择器</strong>中，简化代码</p><p>需要水平放置在同一行的需要对放置在同一行的所有元素都设置为<strong>水平浮动</strong></p><p>往往父元素的高度是不能显性赋值的，避免当内容过多时导致内容溢出等异常情况</p><p>行内块元素不适合作为外部元素</p><p>若元素上方有浮动元素，其下方的元素会自动上移，而文字不会上移，文字会自动环绕在浮动元素之上</p><p>伪元素是css内置好的而不能进行自定义，只能修改和调用定义好的伪元素</p><p>浮动会使得元素脱离文档流，造成高度塌陷的问题</p><p>相对定位的位置是相对于其他元素之外的，可以理解成浮在其他元素之上，相对定位理解成“灵魂出窍”，虽然元素的确发生了移动，但是该元素浮在其他元素之上，而其之前的“身体”仍然占据着位置</p><p>只要position的值不是static即为开启了定位</p><p>粘滞定位由于其兼容性的影响，往往不常使用</p><p><strong>对于开启了定位的元素</strong>，并且和绝对定位或者相对定位等设置无关，可以通过z-index属性来指定元素的层级，index需要一个整数作为参数，且值越大表示的是元素的层级越高，元素的层级越高越优先显示，当该参数的值大小相同时，根据HTML代码中出现的顺序来决定元素的层级，<strong>祖先元素的层级再高也不会盖住后代元素</strong></p><p> 字体文件本身是一种矢量图，无论如何进行放大缩小都不会失真</p><p>常见使用的图标字体库是现成的，不需要通过自己创建</p><p>all.min.css和all.css的区别在于前者是压缩过的，前者的大小相对而言更小一点</p><p>使用字符实体进行设置图标字体时注意得先通过link标签来引入相关css文件</p><p>注意父元素浮动和子元素浮动是有区别的，同时注意可以设置让父元素向左浮动，让子元素向右浮动，呈现的效果是整体向左移，在父元素的格子里面的子元素整体向右移</p><p>为了避免子元素高度的改变导致父元素高度的变化，可以将父元素的高度显式赋值，避免其高度受影响</p><p>使用overflow属性来规定当内容溢出元素框时的处理方式</p><p>简写属性是不存在顺序要求的（写一大串就可以）</p><p>创建一个组件的时候注意首先创建一个对整个组件进行作用的<strong>外部容器</strong></p><p>组件的大小需要依据其包含的具体内容确定时，不能设置其具体的大小</p><p>由于图片是存放在容器里面的，所以图片本身也需要使用容器包含其中，同理文字也需要使用专门的容器进行存放</p><p>给元素的width属性进行赋值时，如果单位是%则表示其定义基于包含块（父元素）宽度的百分比宽度</p><p>在网页也可以使用表单，网页中的表单用于将本地的数据提交给远程的服务器</p><p>向右或者向左浮动的元素的排序取决于在html中代码出现的先后顺序</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/%E8%B6%A3%E5%91%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/06/%E8%B6%A3%E5%91%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>继电器–&gt;真空管–&gt;晶体管</p><p>bug由来是虫子影响了继电器计算机</p><p>一张纸厚度100000纳米，晶体管50纳米</p><p>Cache存储器，<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91/124859">电脑</a>中为<a href="https://baike.baidu.com/item/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/9027270">高速缓冲存储器</a>，是位于<a href="https://baike.baidu.com/item/CPU/120556">CPU</a>和<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/10635399">主存储器</a>DRAM（Dynamic Random Access Memory）之间，规模较小，但速度很高的存储器，通常由<a href="https://baike.baidu.com/item/SRAM/7705927">SRAM</a>（Static Random Access Memory <a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8/6797116">静态存储器</a>）组成。它是位于CPU与内存间的一种容量较小但速度很高的存储器</p><p>cache hit:所需数据恰好在高速缓冲存储器中</p><p>cache miss:所需数据不在高速缓冲存储器中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/Java%E7%AC%94%E8%AE%B0Part3/"/>
    <url>/2023/03/06/Java%E7%AC%94%E8%AE%B0Part3/</url>
    
    <content type="html"><![CDATA[<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>lambda表达式可以替代我们之前经常编写的匿名内部类来进行实现接口，lambda表达式的本质是一个匿名函数</p><p>正常方法组成：返回值，方法名，参数列表，方法体</p><p>lambda表达式组成：参数列表，方法体</p><p>(参数列表)-&gt;{方法体}</p><p>表达式必须依托于接口？</p><p>参数类型也可以省略</p><p>参数只有一个的时候可以省略()</p><p>方法体只有一条的时候可以省略{}</p><p>如果方法体中唯一的语句是return语句，那么大括号和return都可以省略</p><p>方法引用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/C#%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/C#%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/access-modifiers">访问修饰符</a></p><p>C#里所有的值都是类型的实例</p><p>C#中预定义类型（int等）在写的时候就已经初始化了</p><p>给引用变量进行赋值，赋值的是内存的地址，使得多个变量可以引用同一块内存</p><p>数值类型的数字之间可以加_，编译完了会自动忽略</p><p>unchecked(表达式)  这时这个溢出不会被报错</p><p>decimal:是最精确的浮点数数据类型，基于10，可以精确的表示基于10的数据（包括基于2,5的数据）</p><p>double和decimal都无法准确的表达循环数据</p><p><strong>readonly修饰符防止字段在构造之后被改变，并且readonly字段只能在声明的时候被赋值，或者在构造函数中被赋值</strong></p><h4 id="const和readonly"><a href="#const和readonly" class="headerlink" title="const和readonly"></a>const和readonly</h4><ul><li>const是静态常量或者叫编译时常量，是指编译器在编译时候会对常量进行解析，并将常量的值替换成初始化的那个值。必须在声明的时候初使化， const 关键字声明的字段默认带有 static 属性，因此只可以通过类对 const 常量进行访问</li><li>readonly称为动态常量，也叫运行时常量，运行时常量的值是在运行的那一刻才获得的，编译器编译期间将其标示为只读常量，而不用常量的值代替，这样动态常量不必在声明的时候就初始化（当然也可以在声明的时候初使化），而可以延迟到构造函数中初始化</li></ul><p>参数相同的不同顺序也是不同的方法，两个方法如果只有返回值不同，则也属于不同的方法 </p><p>构造方法和普通方法，在只有一条语句的时候可以将大括号转化成&#x3D;&gt;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123; &#125;<span class="hljs-comment">//按值传递</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; &#125;<span class="hljs-comment">//按引用传递</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x</span>)</span> &#123; &#125;<br><span class="hljs-comment">//第一种和第二种方法看做是不同种类的方法，因为一个是按值传递，一个是按引用传递，但第一种方法和第二种方法是一种方法</span><br></code></pre></td></tr></table></figure><p>**本地方法:**嵌套在方法中的方法，如果某种方法只在特定方法中被调用，则可以使用本地方法，注意本地方法不能被写成static</p><p>可以把表达式传递给另外一个构造函数，但是表达式本身不能使用this引用，因为这时候对象还没有被初始化，所以对象上的任何方法的调用都会失败，但是可以使用static方法</p><p>和Java中类似的，如果不编写构造函数，编译器会默认写一个无参的构造函数，如果编写过构造函数，这个默认的无参构造器就会消失</p><p>字段的初始化发生在构造函数执行之前，并且字段按照声明的先后顺序进行初始化</p><p>构造函数可以不是public的，其可以在本类中调用构造器进行实例化，而调用过程可以写在类的某个方法中，外界通过调用该方法来进行实例化该类的对象</p><p><strong>Deconstructor(解构造器):</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">float</span> width</span>)</span><br>&#123;<br>    width = Width;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">作用基本和构造函数相反，它是使得类中的字段反赋值给一堆变量</span><br><span class="hljs-comment">这个方法的方法名只能是Deconstruct,可以有一个或者多个out参数</span><br><span class="hljs-comment">该方法可以被重载</span><br><span class="hljs-comment">Deconstruct这个方法可以是扩展方法</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>静态变量和静态方法不能够通过this关键词进行调用，因为this关键词本身所指的是当前对象，但是静态方法和静态变量实际上没有对象的，自然不能使用this关键词</p><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><p>首先注意字段和属性是两种不同的概念,属性的声明和字段的声明很像，但是属性的声明多了一个get  set  块</p><ul><li>get  set  代表属性的访问器</li><li>get访问器会在属性被读取的时候运行，必须返回一个该属性类型的值</li><li>set访问器会在属性被赋值的时候运行，有一个隐式的该类型的参数value，通常会把value赋给一个私有字段</li><li><strong>字段和属性的区别：</strong>属性的访问方式和字段的访问方式相同，但是不同之处在于，属性赋予了实现者对于获取和赋值的完全控制权，这种控制权允许实现者选择任意所需的内部标识，而不向属性的使用者公开其内部实现细节</li><li><strong>如果属性只有get访问器，则该属性是只读的</strong></li><li>属性通常拥有一个专用的”幕后”字段，这个幕后字段用于存储数据</li><li>注意get和set访问器可以拥有不同的访问级别<ul><li>典型用法：public get ,internal&#x2F;private set</li><li>注意属性的访问级别更宽松一点，而访问器的访问级别更严格一点</li></ul></li><li>C#的属性访问器在其内部会被编译成get_XXX和set_XXX</li><li>简单的非virtual属性访问器会被JIT编译器进行内联(inline)操作，这会消除访问属性和访问字段之间的性能差异。内联是一种优化技术，它会把方法调用换成直接使用方法体</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//从C# 6开始，表示只读属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Worth =&gt; currentPrice;<br><span class="hljs-comment">//从C# 7开始，get和set方法都可以采用这种形式</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Worth<br>&#123;<br>    <span class="hljs-keyword">get</span> =&gt; currentPrice*n<br>    <span class="hljs-keyword">set</span> =&gt; shareOwned = <span class="hljs-keyword">value</span> / current<br>&#125;<br></code></pre></td></tr></table></figure><p>C#中的命名空间可以理解为Java中的包</p><p><strong>索引器：</strong>索引器提供了一种可以访问封装了列表值或者字典？？？</p><h4 id="参数相关问题："><a href="#参数相关问题：" class="headerlink" title="参数相关问题："></a>参数相关问题：</h4><p><a href="https://blog.csdn.net/susan19890313/article/details/6841541">参数相关问题合集</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//部分可选(x为必选，y为可选)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Demo2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x, <span class="hljs-built_in">int</span> y = <span class="hljs-number">5</span></span>)</span><br>&#123;<br>      <span class="hljs-comment">//do something...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>       <span class="hljs-comment">//调用</span><br>       Demo2(<span class="hljs-string">&quot;similar&quot;</span>);       <span class="hljs-comment">// y不传入实参时，y使用默认值5</span><br>       Demo2(<span class="hljs-string">&quot;similar&quot;</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">// y传入实参，则使用实参10</span><br>       Demo3(y:<span class="hljs-number">10</span>);<span class="hljs-comment">//若X，y都有默认值，但是只是传入Y的值</span><br>&#125;<br><span class="hljs-comment">//当参数为部分可选时,可选参数的声明必须定义在不可选参数（命名参数）的后面（如上： y 的声明在 x 之后）</span><br><span class="hljs-comment">//参数声明定义可以无顺序，但调用时必须与声明时的一致</span><br></code></pre></td></tr></table></figure><p><strong>常量：</strong>使用const关键词进行声明，<strong>声明的同时必须使用具体的值来对其进行初始化</strong>，常量的类型可以是内置的数值类型，bool，char，string或enum类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//常量举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> Message = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">常量和静态只读字段的区别:</span><br><span class="hljs-comment">常量比静态只读字段检查更加严格：1、可使用的类型更加严格 2、字段初始化的语义上更加严格</span><br><span class="hljs-comment">常量是在编译时就带入计算的</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><img src="https://images0.cnblogs.com/blog/565226/201310/13225257-1f9fa4aee7a24adcbef8bda723d23ac9.png" alt="img"></p><p><strong>静态构造函数：</strong>相较于非静态构造函数而言，静态构造函数是每一个类型执行一次，一个类型只能定义一个静态构造函数，并且该静态构造函数必须无参数</p><p>在实例化一个类型或者访问类型的一个静态成员之前编译器会自动调用类型的静态构造函数，并且只允许使用unsafe和external修饰符限定</p><p>注意若静态构造函数抛出了未处理的异常，那么这个类型在该程序的剩余生命周期中将无法使用</p><p>静态类中的成员都是静态成员，并且静态类不能有子类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//通过partial关键词使得类可以分成好几部分写，也可以将方法的声明和方法的定义通过partial来进行分开编写</span><br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;<span class="hljs-comment">//限定partial的方法的返回值只能是void，并且是隐式private的</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> B</span>)</span>;<span class="hljs-comment">//定义</span><br>&#125;<br><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> B</span>)</span>&#123;<span class="hljs-comment">//实现</span><br>        printf(<span class="hljs-string">&quot;do something&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果partial method只有定义而没有实现，那么编译的时候定义就没有了，调用该方法的代码也没有了，这样的特性允许自动生成的代码可以自由的提供“钩子”而不用担心代码膨胀</span><br></code></pre></td></tr></table></figure><p>nameof操作符会返回任意符号（成员，类型，变量等） 的名字（string），这样的目的:是便于重构</p><p><strong>多态的原理是：子类完整的拥有父类所有的特性，但是父类并没有完全的拥有子类的特性</strong></p><p>一个对象可以隐式的转化成对父类的引用（向上转换），但是想转换到子类的引用必须进行显示的转化（向下转化），引用转化的实质是创建了一个新的引用，使得它指向同一个对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">Stock msft = <span class="hljs-keyword">new</span> Stock();<br>Asset a  = msft;<br>Console.Writeline(a == msft);<span class="hljs-comment">//True</span><br><span class="hljs-comment">//尽管这两个变量指向的是同一个对象，但是父类的“可视范围”更小</span><br></code></pre></td></tr></table></figure><p>向上转换和向下转化的实质都是引用转换</p><p><strong>as操作符：</strong>as操作符会执行向下转换，如果转化失败，不会抛出异常但是值会变成null</p><p><strong>is操作符：</strong>判断对象是否是某个类的对象，或者是某个基类的派生类的对象，或者是某个接口的实现类的对象，往往用于向下转型前的认证</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">Fatherclass f = <span class="hljs-keyword">new</span> Fatherclass();<br>Sonclass    s = f <span class="hljs-keyword">as</span>  Sonclass;<br><span class="hljs-comment">//as操作符的使用</span><br><span class="hljs-keyword">if</span> (s <span class="hljs-keyword">is</span> Fatherclass )<br>    Console.Writeline(<span class="hljs-string">&quot;do thing&quot;</span>);<br><span class="hljs-comment">//is操作符的使用</span><br><span class="hljs-keyword">if</span>(s <span class="hljs-keyword">is</span> Fatherclass f &amp;&amp;f.name=<span class="hljs-string">&quot;Tom&quot;</span>);<br><span class="hljs-comment">//is操作符的新特性，模式变量，可以在判断是否为指定对象的同时创建一个指定类的对象</span><br></code></pre></td></tr></table></figure><p><strong>虚函数的意义：</strong></p><ul><li>虚方法和重写方法的签名，返回类型，可访问程度必须是一样的</li><li>在构造函数中调用虚方法可能比较危险，因为编写子类的开发人员可能不知道他们在重写方法的时候，面对的是一个未完全初始化的对象</li><li>即重写的方法可能会访问依赖于还未被构造函数初始化的字段的属性或者方法</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//直接重写不调用虚方法的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span>&#123; Console.Write(<span class="hljs-string">&quot;Parent&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> : <span class="hljs-title">Parent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span>&#123; Console.Write(<span class="hljs-string">&quot;Child&quot;</span>); &#125;<br>&#125;<br><br>Child o = <span class="hljs-keyword">new</span> Child();<br>o.Method(); <span class="hljs-comment">//Child</span><br>Parent p = o <span class="hljs-keyword">as</span> Parent;<br>p.Method();<span class="hljs-comment">//Parent</span><br><br><span class="hljs-comment">//通过调用虚方法的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span>&#123; Console.Write(<span class="hljs-string">&quot;Parent&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> : <span class="hljs-title">Parent</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span>&#123; Console.Write(<span class="hljs-string">&quot;Child&quot;</span>); &#125;<br>&#125;<br><br>Child o = <span class="hljs-keyword">new</span> Child();<br>o.Method(); <span class="hljs-comment">//Child</span><br>Parent p = o <span class="hljs-keyword">as</span> Parent;<br>p.Method();<span class="hljs-comment">//Child</span><br><span class="hljs-comment">//通过虚方法调用，使得对象在赋给一个父类对象时，两者变量指向的事同一个对象，使得调用方法是根据对象的本质来调用方法，而不是根据表明的类来调用方法</span><br></code></pre></td></tr></table></figure><p>Base关键词：</p><p><strong>base</strong> 关键字用于从派生类中访问基类的成员：</p><ul><li>调用基类上已被其他方法重写的方法。</li><li>指定创建派生类实例时应调用的基类构造函数。</li></ul><p>仅允许基类访问在构造函数、实例方法或实例属性访问器中进行。</p><p>从静态方法中使用 <code>base</code> 关键字是错误的。</p><p>所访问的基类是类声明中指定的基类。 例如，如果指定 <code>class ClassB : ClassA</code>，则从 ClassB 访问 ClassA 的成员，而不考虑 ClassA 的基类。</p><p>通过base关键词调用父类同名方法的方式和super关键词相同</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseClass</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;in BaseClass()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        num = i;<br>        Console.WriteLine(<span class="hljs-string">&quot;in BaseClass(int i)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetNum</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// This constructor will call BaseClass.BaseClass()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>() : <span class="hljs-title">base</span>()</span><br>    &#123;<br>    &#125;<br><br> <span class="hljs-comment">//This constructor will callBaseClass.BaseClass(int i)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">i</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DerivedClass md = <span class="hljs-keyword">new</span> DerivedClass();<br>        DerivedClass md1 = <span class="hljs-keyword">new</span> DerivedClass(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">in BaseClass()</span><br><span class="hljs-comment">in BaseClass(int i)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/new-modifier">new 修饰符 - C# 参考</a></p><p>如果Counter是两个类中的桶面变量则：</p><ul><li>编译时对A的引用就会绑定到A.Counter</li><li>编译时对B的引用就会绑定到B.Counter</li></ul><h4 id="sealed关键词："><a href="#sealed关键词：" class="headerlink" title="sealed关键词："></a>sealed关键词：</h4><p>应用于某个类时，<code>sealed</code> 修饰符可阻止其他类继承自该类。 在下面的示例中，类 <code>B</code> 继承自类 <code>A</code>，但没有类可以继承自类 <code>B</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;&#125;<br><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>还可以对替代基类中的虚方法或属性的方法或属性使用 <code>sealed</code> 修饰符。 这使你可以允许类派生自你的类并防止它们替代特定虚方法或属性。</p><p>子类不能<strong>直接</strong>调用父类的构造函数，如果要调用父类的构造函数，需要在子类的构造函数中调用服父类的构造函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> : <span class="hljs-title">Baseclass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">X</span>)</span>  &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果子类的构造函数里没有使用base关键词，那么父类的无参构造函数会被隐式的调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Baseclass</span>()</span>&#123;<br>        X=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> : <span class="hljs-title">Baseclass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subclass</span>()</span>&#123;<br>       Console.WriteLine(X);<br>    &#125;<span class="hljs-comment">//输出结果为1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果父类没有无参的构造函数，那么子类就必须在构造函数中使用base关键词</p><p>装箱对于类型统一十分重要，但是数组和泛型只支持引用转换，不支持装箱（将值类型转化成object类型），实际上，装箱会把值类型的实例复制到一个新的对象，而拆箱会把这个对象的内容再复制给一个值类型的实例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span>[] a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">3</span>];    <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">object</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>   [<span class="hljs-number">3</span>];    <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>可以在自定义类型上重写ToString方法，使得ToString方法返回你想要的值，如果不重写该方法，则会默认返回该类型的名称（指的是全名，包括命名空间）</p><h4 id="struct类型："><a href="#struct类型：" class="headerlink" title="struct类型："></a>struct类型：</h4><p>struct是值类型，不能继承，一般来说类能有的成员struct都可以有，除了：1、无参构造函数   2、字段初始化器  3、 终结器  4、virtual或者protected成员</p><p>struct有一个无参的构造函数，但是你不能对这个无参的构造函数进行重写，它会对字段进行按位归零的操作，当定义struct构造函数时，必须显式的为每一个字段进行赋值，并且不可以有字段初始化器，即在声明字段的时候不能够给其赋初值</p><p>struct也可以实现接口  </p><p>外层的访问权限永远大于内层元素的访问权限，即使编写代码的过程中可以使内部成员访问权限更大但是实际上还是以外部成员的访问权限为准</p><p>接口中的实现都是隐式的，不能对接口的成员声明权限修饰符</p><p>返回值不同的方法是两个不同的方法</p><p><strong>显式的接口实现：</strong>如果继承多个接口过程中可能会出现成员签名的冲突，通过使用显示实现接口成员来解决这个问题</p><p>显式的接口实现即：接口名.方法名( )  以这样的方式重写方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span> &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title">I2</span> &#123;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">f</span>()</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> : <span class="hljs-title">I1</span>,<span class="hljs-title">I2</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>&#123;<br>        Console.Writeline(<span class="hljs-string">&quot;f1执行&quot;</span>)<br>    &#125;<br>    <span class="hljs-built_in">int</span> I2.f()&#123;<br>        Console.Writeline(<span class="hljs-string">&quot;f2执行&quot;</span>)<br>    &#125;<br>&#125;<span class="hljs-comment">//通过显式指明使用的接口来避免方法名冲突</span><br>((Parent)c).Do();<span class="hljs-comment">//强转为父类后立马调用方法</span><br>((Interface)c).Do();<span class="hljs-comment">//强转为接口后立马调用方法</span><br></code></pre></td></tr></table></figure><p>默认实现接口的方法是sealed的，如果子类想要重写该方法，需要第一次重写这个方法是virtual或者abstract的</p><h4 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C#中的泛型"></a>C#中的泛型</h4><ul><li>泛型的存在是为了写出适应不同类型的代码</li><li>泛型和object的作用：如果使用object则需要对所有类型都进行装箱操作，并且还需要进行向下转型的操作，但是这种转换在编译过程中无法进行检查</li><li>使用泛型方法可以提高代码的复用性</li></ul><p>注意区别泛型方法和泛型类中的普通方法？？  </p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>通过委托可以编写插件式的方法，因为方法是在运行时才赋值给委托变量的</p><p>由于所有的委托实例都具有多播的能力，一个委托实例可以引用一组目标方法</p><p>委托可以合并亦可以移除，调用委托的方法和添加到委托上的方法的顺序一致</p><p>如果委托变量本身只有一个方法，移除这个方法后这个委托实例的值即变为null</p><p>委托是不可变的，在使用+&#x3D;或者-&#x3D;操作符时，实际上是创建了新的委托实例，并将其赋值给当前的委托变量</p><p>委托的返回值取决于调用的最后一个方法的返回值</p><p>委托中使用的+、-、+&#x3D;、-&#x3D;操作会被系统编译成System.Delegate的Combine和remove两个静态方法</p><p>使用泛型委托就可以写出这样一组委托类型，它们可调用的方法可以拥有任意的返回类型和任意数量的参数</p><p>一般而言委托可以解决的问题，接口都可以解决，在以下三种情况更适合使用委托而不是接口：1、接口只能定义一个方法  2、需要多播能力的  3、订阅者需要多次实现接口（多个类都需要实现该接口时）</p><p>委托类型之间互不相容，即使是除了方法名以外所有的关键词都相同，这两个委托类型也是不同的委托类型</p><p>如果委托拥有相同的方法目标，则委托实例就认为是相同的</p><p>调用委托时，传递给委托的参数可以比方法本身的参数更加具体</p><p>调用委托时，方法本身返回的类型可以比委托类本身返回的类型更加具体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StringAction</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ActOnObject</span> (<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span> =&gt; Console.WriteLine(o);<br><span class="hljs-comment">//即委托的参数更加具体（所谓具体仅仅支持引用类型的转换，数值转换不适用于这种情况）仍然可以通过委托来进行调用方法</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">object</span> <span class="hljs-title">ObjectRetriever</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">RetrieveString</span>()</span> =&gt; <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">//即委托调用后的返回值可以比委托本身定义的返回值更加具体</span><br></code></pre></td></tr></table></figure><p>out参数更像是对给定参数赋值一个已知参数</p><h4 id="幕后字段："><a href="#幕后字段：" class="headerlink" title="幕后字段："></a>幕后字段：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CalendarEntry</span><br>&#123;<span class="hljs-comment">//幕后字段往往是private的，保证只能通过属性中的访问器来获取修改这个值</span><br>    <span class="hljs-keyword">private</span> DateTime _date;<br>    <span class="hljs-keyword">public</span> DateTime Date<br>    &#123; <span class="hljs-keyword">get</span> =&gt;<span class="hljs-keyword">return</span> _date;<br>      <span class="hljs-keyword">set</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span>.Year &gt; <span class="hljs-number">1900</span> &amp;&amp; <span class="hljs-keyword">value</span>.Year &lt;= DateTime.Today.Year)<br>        &#123; _date = <span class="hljs-keyword">value</span>; &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException();&#125;<br>    &#125;<br>    &#125;<br><span class="hljs-comment">// 自动属性：编译器会默认帮你创建一个匿名的幕后字段，但是无法除了属性外调用，并且无法添加特殊的逻辑操作   </span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="override关键词："><a href="#override关键词：" class="headerlink" title="override关键词："></a>override关键词：</h4><p><code>override</code> 方法提供从基类继承的方法的新实现。 通过 <code>override</code> 声明重写的方法称为重写基方法。 <code>override</code> 方法必须具有与重写基方法相同的签名。 从 C# 9.0 开始，<code>override</code> 方法支持协变返回类型。 具体而言，<code>override</code> 方法的返回类型可从相应基方法的返回类型派生。 在 C# 8.0 和更早版本中，<code>override</code> 方法和重写基方法的返回类型必须相同。</p><p>不能重写非虚方法或静态方法。 重写基方法必须是 <code>virtual</code>、<code>abstract</code> 或 <code>override</code>。</p><p><code>override</code> 声明不能更改 <code>virtual</code> 方法的可访问性。 <code>override</code> 方法和 <code>virtual</code> 方法必须具有相同<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/access-modifiers">级别访问修饰符</a>。</p><p>不能使用 <code>new</code>、<code>static</code> 或 <code>virtual</code> 修饰符修改 <code>override</code> 方法。</p><p>重写属性声明必须指定与继承的属性完全相同的访问修饰符、类型和名称。 从 C# 9.0 开始，只读重写属性支持协变返回类型。 重写属性必须为 <code>virtual</code>、<code>abstract</code> 或 <code>override</code></p><p><img src="https://img-blog.csdnimg.cn/20210425175918174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkzNTM5OA==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/06/IDEA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/06/IDEA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>eclipse中的workplace和IDEA的project相同</p><p>在idea中可以指定所编写的文件所使用的编码集，可以让其只是显示的时候更换编码集也可以在存入的时候也更换编码集</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/20/%E5%89%91%E6%8C%87offer/"/>
    <url>/2023/02/20/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer题目指南"><a href="#剑指offer题目指南" class="headerlink" title="剑指offer题目指南"></a>剑指offer题目指南</h1><h3 id="3、数组中重复的元素"><a href="#3、数组中重复的元素" class="headerlink" title="3、数组中重复的元素"></a>3、数组中重复的元素</h3><p>下标法：交换到数字本身对应的下标位置（使用数组本身作为一个hashmap）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[nums[i]] == nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[temp];<br>            nums[temp] = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4、二维数组查找"><a href="#4、二维数组查找" class="headerlink" title="4、二维数组查找"></a>4、二维数组查找</h3><p>左下角出发进行比较</p><ul><li>若给定数据更大，则右移一位</li><li>若给定数据更小，则上移一位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路本身简单，但有以下细节需要注意</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//注意为0的特殊情况</span><br>        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//注意如果matrix是空数组，则matrix.length为0，可用来赋值，但是matrix[0].length是未知量，不能用来赋值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> y - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; x &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> matrix[j][i];<br>            <span class="hljs-keyword">if</span> (num &gt; target) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; target) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) i--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) j++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5、替换空格"><a href="#5、替换空格" class="headerlink" title="5、替换空格"></a>5、替换空格</h3><p>如果只是使用stringbuilder，由于java不支持字符串原地扩容，所以一定要使用N的空间复杂度</p><p>如果使用C++，则可以原地扩容然后从右往左倒序遍历数组（空间复杂度为O(1)）</p><h3 id="6、从尾到头倒序打印链表"><a href="#6、从尾到头倒序打印链表" class="headerlink" title="6、从尾到头倒序打印链表"></a>6、从尾到头倒序打印链表</h3><ul><li>使用栈来实现逆序打印（栈的特性）</li><li>实际上先遍历一遍链表然后反着装一遍效率更高</li></ul><h3 id="7、重建二叉树"><a href="#7、重建二叉树" class="headerlink" title="7、重建二叉树"></a>7、重建二叉树</h3><p>根据前序遍历和中序遍历的结果返回二叉树根结点</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208224618157.png" alt="image-20230208224618157"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存在迭代方法进行求解，但是递归方法更为简洁，每一个部分都看做左子树和右子树进行求解</span><br><span class="hljs-comment">//这里实际上就是看清楚传递的参数和对应参数的关系</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorder_root</span> <span class="hljs-operator">=</span> preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_root]);<br>        <br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left_subtree</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i); <span class="hljs-comment">//快速求得对应结点的下标</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//纯享无注释版本</span><br><span class="hljs-comment">//为了快速获取到根结点对应的值</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorder_root</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorder_left]);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorder_left]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> inorder_root - inorder_left;<br>        root.left = myBuildTree(preorder, inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+sub,inorder_left,inorder_root-<span class="hljs-number">1</span> );<br>        root.right = myBuildTree(preorder, inorder, preorder_left + sub + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i); <span class="hljs-comment">//快速求得对应结点的下标</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="9、用两个栈实现队列"><a href="#9、用两个栈实现队列" class="headerlink" title="9、用两个栈实现队列"></a>9、用两个栈实现队列</h3><p>使用两个栈，A和B，每次出“队列”都是从栈B出，然后一旦B空了就从A中倒出来给B，再从B中出</p><p>实际上就是使用A倒给B的过程来实现队列的顺序操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">//输入可以直接添加即可，类似分段看做不同的栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        inStack.push(value);<br>    &#125;<br><br>    <span class="hljs-comment">//设定输出只能从输出栈中输出，类似将未合并的段进行合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>                outStack.push(inStack.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="10-1、斐波那契数列"><a href="#10-1、斐波那契数列" class="headerlink" title="10.1、斐波那契数列"></a>10.1、斐波那契数列</h3><p>迭代算法：相当于只使用三个格子不断的计算到对应的i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        n = n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            a = b;  <span class="hljs-comment">//注意这里先对ab进行修改再计算</span><br>            b = c;<br>            c = (a + b) % MOD; <span class="hljs-comment">//注意这个结果的时候就需要取余了</span><br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c % MOD;<br>    &#125;<br></code></pre></td></tr></table></figure><p>快速幂算法（字节）：时间复杂度为O(n)</p><ul><li>实际上是正数快速幂的修改版</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230210185547087.png" alt="image-20230210185547087"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] q = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = pow(q, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] pow(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">//和正常的快速幂算法类似</span><br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                ret = multiply(ret, a);<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>            a = multiply(a, a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">//这里定义矩阵的乘法运算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiply(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b) &#123;<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                c[i][j] = (<span class="hljs-type">int</span>) (((<span class="hljs-type">long</span>) a[i][<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>][j] + (<span class="hljs-type">long</span>) a[i][<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>][j]) % MOD);<br>            &#125;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="10-2、青蛙跳台问题"><a href="#10-2、青蛙跳台问题" class="headerlink" title="10.2、青蛙跳台问题"></a>10.2、青蛙跳台问题</h3><p>和斐波那契相同使用迭代法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <br>            sum = (a + b) % <span class="hljs-number">1000000007</span>;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;  <span class="hljs-comment">//提前两个输出，所以需要输出的是a</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//下面是仿照斐波那契数列编写的，显然上面那一种更为简洁</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>        n = n - <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            a = b;  <span class="hljs-comment">//注意这里先对ab进行修改再计算</span><br>            b = sum;<br>            sum = (a + b) % MOD;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum % MOD;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="11、旋转数组的最小值"><a href="#11、旋转数组的最小值" class="headerlink" title="11、旋转数组的最小值"></a>11、旋转数组的最小值</h3><p>原本是1.2.3.4.5，旋转以后变成3.4.5.1.2，需要输出结果1</p><p>实际上就是两个递增的直线，求二分即可</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208123716838.png" alt="image-20230208123716838"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-comment">//关键在于考虑下面的左右判断情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123; <span class="hljs-comment">//右半部分</span><br>                high = pivot; <span class="hljs-comment">//要找的点肯定在该点的左边</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;  <span class="hljs-comment">//左半部分</span><br>                <span class="hljs-comment">//这里相对于上面为什么要+1的原因在于</span><br>                <span class="hljs-comment">//二分查找最后能扫描到左节点，而不能扫描到右节点</span><br>                low = pivot + <span class="hljs-number">1</span>; <span class="hljs-comment">//要找的点肯定在该点的右边</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high -= <span class="hljs-number">1</span>;<span class="hljs-comment">//减一的原因见上</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="12、矩阵中的路径（TODO手动实现）"><a href="#12、矩阵中的路径（TODO手动实现）" class="headerlink" title="12、矩阵中的路径（TODO手动实现）"></a>12、矩阵中的路径（TODO手动实现）</h3><p>在给定字母矩阵中查找有无特定单词</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230123412549.png" alt="image-20221230123412549"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> board.length, w = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[h][w];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; h; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; w; j++) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, i, j, word, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] != s.charAt(k)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == s.length() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//对于给定的起点，走一步check一圈</span><br>        <span class="hljs-type">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newj = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newi &gt;= <span class="hljs-number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="hljs-number">0</span> &amp;&amp; newj &lt; board[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[newi][newj]) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, newi, newj, s, k + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        result = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13、机器人移动路径（TODO）"><a href="#13、机器人移动路径（TODO）" class="headerlink" title="13、机器人移动路径（TODO）"></a>13、机器人移动路径（TODO）</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103211256983.png" alt="image-20230103211256983"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接进行DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n, k;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m; <span class="hljs-built_in">this</span>.n = n; <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-built_in">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> si, <span class="hljs-type">int</span> sj)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj) + dfs(i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="14-1、剪绳子"><a href="#14-1、剪绳子" class="headerlink" title="14.1、剪绳子"></a>14.1、剪绳子</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230208140108564.png" alt="image-20230208140108564"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据推导得知在一定条件下，尽可能将给定数据按照3分组是最好的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, quotient) * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//比上一题只是多了一个求余操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) rem = (rem * x) % p;<br>            x = (x * x) % p;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(rem * <span class="hljs-number">6</span> % p);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15、二进制中1的个数"><a href="#15、二进制中1的个数" class="headerlink" title="15、二进制中1的个数"></a>15、二进制中1的个数</h3><p>根据<strong>数学性质</strong>进行求解</p><ul><li>这个数学性质也好推导，当数字为n时，n-1恰好相当于将原来的二进制数的最后一个1转换成0，然后再把这个1后面的所有0都变成1，最后做与运算，这个1及它后面的数字当然就全部变成0了</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230151004500.png" alt="image-20221230151004500"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16、快速幂求法"><a href="#16、快速幂求法" class="headerlink" title="16、快速幂求法"></a>16、快速幂求法</h3><p>迭代法思路：实际上就是将指数转换为二进制形式，根据二进制进行求解，并且不断将这个数向右移动</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230175430401.png" alt="image-20221230175430401"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归求法，每一次求幂都转换为求原来的一半</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> quickMul(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//迭代求法，相比于递归算法使用更少的空间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-comment">//对于负指数的操作</span><br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-comment">// 贡献的初始值为 x</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">x_contribute</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-comment">// 在对 N 进行二进制拆分的同时计算答案</span><br>        <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span><br>                ans *= x_contribute;<br>            &#125;<br>            <span class="hljs-comment">// 将贡献不断地平方</span><br>            x_contribute *= x_contribute;<br>            <span class="hljs-comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span><br>            N /= <span class="hljs-number">2</span>;<span class="hljs-comment">//相当于让数字向右移动一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、打印从-1-到最大的-n-位数"><a href="#17、打印从-1-到最大的-n-位数" class="headerlink" title="17、打印从 1 到最大的 n 位数"></a>17、打印从 1 到最大的 n 位数</h3><p>给定数字的位数，打印所有的数，本题唯一需要考虑的在于需要注意int类型的范围的情况（但是本题不需要考虑）</p><h3 id="18、删除链表的结点"><a href="#18、删除链表的结点" class="headerlink" title="18、删除链表的结点"></a>18、删除链表的结点</h3><p>简单删除即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//先处理链表头的情况</span><br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19、正则表达式匹配（TODO）"><a href="#19、正则表达式匹配（TODO）" class="headerlink" title="19、正则表达式匹配（TODO）"></a>19、正则表达式匹配（TODO）</h3><h3 id="20、表示数值的字符串（TODO）"><a href="#20、表示数值的字符串（TODO）" class="headerlink" title="20、表示数值的字符串（TODO）"></a>20、表示数值的字符串（TODO）</h3><p>有限自动状态机的应用</p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221230191442358.png" alt="image-20221230191442358"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();<br>        Map&lt;CharType, State&gt; initialMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_INITIAL);<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INITIAL, initialMap);<br>        Map&lt;CharType, State&gt; intSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INT_SIGN, intSignMap);<br>        Map&lt;CharType, State&gt; integerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_POINT, State.STATE_POINT);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INTEGER, integerMap);<br>        Map&lt;CharType, State&gt; pointMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT, pointMap);<br>        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);<br>        Map&lt;CharType, State&gt; fractionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_FRACTION, fractionMap);<br>        Map&lt;CharType, State&gt; expMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP, expMap);<br>        Map&lt;CharType, State&gt; expSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_SIGN, expSignMap);<br>        Map&lt;CharType, State&gt; expNumberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);<br>        Map&lt;CharType, State&gt; endMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_END, endMap);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> State.STATE_INITIAL;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">CharType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> toCharType(s.charAt(i));<br>            <span class="hljs-keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                state = transfer.get(state).get(type);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> CharType <span class="hljs-title function_">toCharType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_NUMBER;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_EXP;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_POINT;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SIGN;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SPACE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_ILLEGAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        STATE_INITIAL,<br>        STATE_INT_SIGN,<br>        STATE_INTEGER,<br>        STATE_POINT,<br>        STATE_POINT_WITHOUT_INT,<br>        STATE_FRACTION,<br>        STATE_EXP,<br>        STATE_EXP_SIGN,<br>        STATE_EXP_NUMBER,<br>        STATE_END<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>        CHAR_NUMBER,<br>        CHAR_EXP,<br>        CHAR_POINT,<br>        CHAR_SIGN,<br>        CHAR_SPACE,<br>        CHAR_ILLEGAL<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21-、调整数组顺序使奇数位于偶数前面"><a href="#21-、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.、调整数组顺序使奇数位于偶数前面"></a>21.、调整数组顺序使奇数位于偶数前面</h3><ul><li>双指针方法：左右分别标记一个奇数指针和一个偶数指针，遇到对应数据的时候直接移动</li><li>原地移动方法：从左往右找到第一个奇数，然后从右往左找到第一个偶数，交换，重复<ul><li>实际上二者时间空间复杂度相同</li></ul></li><li>自己编写的单指针算法更快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里考虑实际上只使用一个指针应该也可以的吧</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是偶数</span><br>                nums[i] = nums[count];<br>                nums[count] = num;<br>                count--;<br>                i--;<span class="hljs-comment">//换过来的这个数也需要比较</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="22、链表中倒数第N个开始截取"><a href="#22、链表中倒数第N个开始截取" class="headerlink" title="22、链表中倒数第N个开始截取"></a>22、链表中倒数第N个开始截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针即可，这样不必遍历两次，前一个指针先快走N步</span><br> <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">faster</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slower</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            faster = faster.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (faster != <span class="hljs-literal">null</span>) &#123;<br>            faster = faster.next;<br>            slower = slower.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slower;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代方法：走一步编织一次</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next; <span class="hljs-comment">// 暂存后继节点 cur.next</span><br>            cur.next = pre;          <span class="hljs-comment">// 修改 next 引用指向</span><br>            pre = cur;               <span class="hljs-comment">// pre 暂存 cur</span><br>            cur = tmp;               <span class="hljs-comment">// cur 访问下一节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//递归方法（实际上由于递归的原因会导致消耗更多的空间复杂度）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(head, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// 调用递归并返回</span><br>    &#125;<br>    <span class="hljs-comment">//当前传入的这个cur实际上是递归返回后的尾节点（实际上是借助递归使用栈的特性）</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode cur, ListNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> recur(cur.next, cur);  <span class="hljs-comment">// 递归后继节点</span><br>        cur.next = pre;              <span class="hljs-comment">// 修改节点引用指向</span><br>        <span class="hljs-keyword">return</span> res;                  <span class="hljs-comment">// 返回反转链表的头节点</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="25、合并两个排序链表"><a href="#25、合并两个排序链表" class="headerlink" title="25、合并两个排序链表"></a>25、合并两个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单归并思路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prehead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> prehead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                prev.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            prev = prev.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>        prev.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br><br>        <span class="hljs-keyword">return</span> prehead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h3><p>判断一个小树是否为一个大树的子结构(简单递归分析)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">return</span> (A != <span class="hljs-literal">null</span> &amp;&amp; B != <span class="hljs-literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));<br>    &#125;<br>    <span class="hljs-comment">//判断子结构只能从具体两个结点开始</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-comment">//B是A的子结构的前提：B为空或者当前节点对应的结点至少要相同</span><br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h3><ul><li>这里的反转使用的还是原来的结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//将一棵二叉树转为其镜像后输出其根结点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//递归的终点</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//注意一下这两个操作的顺序（肯定要先让底下的结点反转后再自己反转）</span><br>        <span class="hljs-comment">//递归进行该操作</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> mirrorTree(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mirrorTree(root.right);<br>        <br>        <span class="hljs-comment">//实际翻转的操作</span><br>        root.left = right;<br>        root.right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h3><ul><li><strong>递归的本质是提前使用未来的数据</strong>，我不需要在意未来的数据是如何得到的，反正我就是知道，<strong>只需要考虑最最末的问题</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//需要两个参数所以需要重新写一个新的函数</span><br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//只要有一个为null就说明部队称</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前节点对称的前提是该节点是相等的，并且对应的子节点也是对称的</span><br>        <span class="hljs-keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h3><ul><li>模拟法：每当到需要拐弯的边界的时候顺时针转变方向，并且修改其对应的边界（实际上不需要使用完整大小的矩阵保留访问情况，只需要记录边界即可，即下面这种方法的优化方式）</li><li>按层遍历：根据四个坐标，一层层向里面遍历</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20221231134617606.png" alt="image-20221231134617606"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> matrix.length, columns = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows * columns];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = columns - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-comment">//正常打印一行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> left; column &lt;= right; column++) &#123;<br>                order[index++] = matrix[top][column];<br>            &#125;<br>            <span class="hljs-comment">//正常打印一列</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> top + <span class="hljs-number">1</span>; row &lt;= bottom; row++) &#123;<br>                order[index++] = matrix[row][right];<br>            &#125;<br>            <span class="hljs-comment">//只要至少有两行并且至少有两列，就得继续打印</span><br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> right - <span class="hljs-number">1</span>; column &gt; left; column--) &#123;<br>                    order[index++] = matrix[bottom][column];<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> bottom; row &gt; top; row--) &#123;<br>                    order[index++] = matrix[row][left];<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a>30、包含min函数的栈</h3><ul><li>如果只是使用一个min值进行标注的话则无法应对多个相同最小值的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里的相当于存放两层栈，每次添加一个元素都比较当前的最小值放到minStack中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; xStack;<br>    Deque&lt;Integer&gt; minStack;<span class="hljs-comment">//维护的是当前栈中的最小值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        minStack.push(Integer.MAX_VALUE);<span class="hljs-comment">//这里注意需要先加入一个最大值进行维护</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        xStack.push(x);<br>        minStack.push(Math.min(minStack.peek(), x));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        xStack.pop();<br>        minStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> xStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31、栈的弹入和弹出序列判断"><a href="#31、栈的弹入和弹出序列判断" class="headerlink" title="31、栈的弹入和弹出序列判断"></a>31、栈的弹入和弹出序列判断</h3><ul><li>实际上只是对于输入序列的一种模拟，存在一个监视器一直判断是否能够直接弹出栈顶元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pushed.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            stack.push(pushed[i]);<br>            <span class="hljs-comment">//若现在模拟栈中的元素正好是需要的元素，就把这个元素弹出并且检索下一个元素</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;<br>                stack.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-1、从上到下打印二叉树"><a href="#32-1、从上到下打印二叉树" class="headerlink" title="32.1、从上到下打印二叉树"></a>32.1、从上到下打印二叉树</h3><ul><li>实际上就是层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//使用队列进行排序，然后从左到右进行输出</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            ans.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<span class="hljs-comment">//注意判断为空</span><br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>        &#125;<br>        <span class="hljs-comment">//ArrayList不能直接转换成数组，需要自己手动转换</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++)<br>            res[i] = ans.get(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-2、从上到下打印二叉树"><a href="#32-2、从上到下打印二叉树" class="headerlink" title="32.2、从上到下打印二叉树"></a>32.2、从上到下打印二叉树</h3><ul><li>层序遍历的变种：需要按数组层数的不同一行行的输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-comment">//按照二叉树的层进行排序，只有当前层遍历完了才创建新的遍历下一行</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">//这里巧妙的在于使用大小，递减作为计数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="32-3、从上到下打印二叉树"><a href="#32-3、从上到下打印二叉树" class="headerlink" title="32.3、从上到下打印二叉树"></a>32.3、从上到下打印二叉树</h3><ul><li>层序遍历的变种：分层输出并且每层切换输出方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//本来想用反转操作的，但是list无法使用反转</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <br>                <span class="hljs-comment">//其实和原本题目只需要改变这一点逻辑，因为只需要在最最后面输出答案的时候倒着放就可以了</span><br>                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 -&gt; 队列头部</span><br>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 -&gt; 队列尾部</span><br>                <br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33、判断二叉搜索树的后序遍历序列（TODO）"><a href="#33、判断二叉搜索树的后序遍历序列（TODO）" class="headerlink" title="33、判断二叉搜索树的后序遍历序列（TODO）"></a>33、判断二叉搜索树的后序遍历序列（TODO）</h3><ul><li>注意这里只是给定了后序遍历序列而并未给定特定的二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归法求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(postorder[p] &lt; postorder[j]) p++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p;<br>        <span class="hljs-keyword">while</span>(postorder[p] &gt; postorder[j]) p++;<br>        <span class="hljs-keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="hljs-number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//迭代法求解待补充</span><br></code></pre></td></tr></table></figure><h3 id="34、二叉树中和为某一值的路径（TODO）"><a href="#34、二叉树中和为某一值的路径（TODO）" class="headerlink" title="34、二叉树中和为某一值的路径（TODO）"></a>34、二叉树中和为某一值的路径（TODO）</h3><ul><li>深度优先遍历简单应用（路径是指必须要达到叶子结点才行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-comment">//其实不用担心这个path的并发情况，因为这实际上是在一个线程中运行，没有并发问题</span><br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        dfs(root, target);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.offerLast(root.val);<br>        target -= root.val;<br>        <span class="hljs-comment">//只有当为叶子结点并且当前目标值为0时</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; target == <span class="hljs-number">0</span>) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(path));<br>        &#125;<br>        <span class="hljs-comment">//即使是多个递归实际上同一时间也只会找一条线路</span><br>        dfs(root.left, target);<br>        dfs(root.right, target);<br>        <span class="hljs-comment">//并且在深度优先遍历回溯的过程中会自然把path的末尾结点给删掉</span><br>        path.pollLast();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//广度优先遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();<br>    Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;TreeNode, TreeNode&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; queueNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Queue&lt;Integer&gt; queueSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        queueNode.offer(root);<br>        queueSum.offer(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (!queueNode.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queueNode.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> queueSum.poll() + node.val;<br><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (rec == target) &#123;<br>                    getPath(node);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    map.put(node.left, node);<br>                    queueNode.offer(node.left);<br>                    queueSum.offer(rec);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    map.put(node.right, node);<br>                    queueNode.offer(node.right);<br>                    queueSum.offer(rec);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            temp.add(node.val);<br>            node = map.get(node);<br>        &#125;<br>        Collections.reverse(temp);<br>        ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(temp));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h3><ul><li>链表结点不仅有next指针，还有一个random指针指向随机一个结点，要求进行深拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//回溯+hashmap</span><br><span class="hljs-comment">//之所以要使用一个hashmap进行缓存，是因为要保证当一个结点被当做next时，或者被当做random时保证这个结点要是唯一的</span><br><span class="hljs-comment">//由于需要额外的HashMap，所以空间复杂度为O(N)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//内存映射内存，对应的是内存中唯一的node</span><br>    Map&lt;Node, Node&gt; cachedNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Node, Node&gt;();<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果当前的hashmap没有缓存对应的结点</span><br>        <span class="hljs-keyword">if</span> (!cachedNode.containsKey(head)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">headNew</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(head.val);<br>            cachedNode.put(head, headNew);<br>            headNew.next = copyRandomList(head.next);<br>            headNew.random = copyRandomList(head.random);<br>        &#125;<br>        <span class="hljs-comment">//无论怎样最后都会返回这个节点对应的值相同的深拷贝结点</span><br>        <span class="hljs-keyword">return</span> cachedNode.get(head);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//迭代+结点划分</span><br><span class="hljs-comment">//由于不需要额外的hashmap，所以空间复杂度为O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//在每个原结点中间创建一个前位结点的深拷贝结点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next.next) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(node.val);<br>            nodeNew.next = node.next;<br>            node.next = nodeNew;<br>        &#125;<br>        <span class="hljs-comment">//再把深拷贝得到的结点的random都赋值为前位结点的random</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next.next) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> node.next;<br>            nodeNew.random = (node.random != <span class="hljs-literal">null</span>) ? node.random.next : <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//此时的headNew是第一个深拷贝结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">headNew</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head; node != <span class="hljs-literal">null</span>; node = node.next) &#123;<br>            <span class="hljs-comment">//将原来的链表复位</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nodeNew</span> <span class="hljs-operator">=</span> node.next;<br>            node.next = node.next.next;<br>            <span class="hljs-comment">//注意nodeNew.next为null的情况</span><br>            nodeNew.next = (nodeNew.next != <span class="hljs-literal">null</span>) ? nodeNew.next.next : <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> headNew;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="36、二叉搜索数转换成双向链表"><a href="#36、二叉搜索数转换成双向链表" class="headerlink" title="36、二叉搜索数转换成双向链表"></a>36、二叉搜索数转换成双向链表</h3><ul><li>由于性质，二叉搜索树的中序遍历为 <strong>递增序列</strong></li><li>本题实际上就是一个二叉树中序遍历的变体</li><li>中序遍历只是中形式，具体需要做的复杂操作在遍历过程中进行即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   Node pre, head;<span class="hljs-comment">//这里设置在外面</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        dfs(root);<br>        pre.right = head;<br>        head.left = pre;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            pre.right = cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = cur;<br>        &#125;<br>        cur.left = pre;<br>        pre = cur;<br><br>        dfs(cur.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h3><ul><li>深度优先遍历：注意只根据先序遍历或者只根据后序遍历如果有null值的话是可以唯一确定一个二叉树的<ul><li>实际上本题就是通过带null结点的前序遍历，中序遍历，后序遍历（三者之一）得到唯一二叉树</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>   Node pre, head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <br>        dfs(cur.left);<span class="hljs-comment">//1</span><br>        <br>        <span class="hljs-comment">//2</span><br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>) pre.right = cur;<br>        <span class="hljs-keyword">else</span> head = cur;<br>        cur.left = pre;<br>        pre = cur;<br>        <br>        dfs(cur.right);<span class="hljs-comment">//3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="38、字符串排序（TODO）"><a href="#38、字符串排序（TODO）" class="headerlink" title="38、字符串排序（TODO）"></a>38、字符串排序（TODO）</h3><ul><li>给定字符串中涵盖的字母，输出所有可能的字符串(给定元素中可能有重复字母，但输出的时候不能有重复元素)</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230101105032350.png" alt="image-20230101105032350"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先遍历+剪枝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[] c;<br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        <span class="hljs-comment">//c数组被赋值为给定字符串初始值</span><br>        c = s.toCharArray();<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[res.size()]);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x == c.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//字符数组是每一次的结果承载者</span><br>            res.add(String.valueOf(c));      <span class="hljs-comment">// 添加排列方案</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt; c.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(c[i])) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 重复，因此剪枝</span><br>            set.add(c[i]);<br>            swap(i, x);                      <span class="hljs-comment">// 交换，将 c[i] 固定在第 x 位</span><br>            dfs(x + <span class="hljs-number">1</span>);                      <span class="hljs-comment">// 开启固定第 x + 1 位字符</span><br>            swap(i, x);                      <span class="hljs-comment">// 恢复交换</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> c[a];<br>        c[a] = c[b];<br>        c[b] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="39、数组中超过数组长度一半的数字"><a href="#39、数组中超过数组长度一半的数字" class="headerlink" title="39、数组中超过数组长度一半的数字"></a>39、数组中超过数组长度一半的数字</h3><ul><li>具体多种解决方法<ul><li>使用hashmap存储对应的结点出现次数</li><li>对数组进行排序，排序后数组中的最中间的位置一定是数组的众数，即所求</li><li>空间复杂度为O(1)的算法,并且只需要遍历一次:Boyer-Moore 投票算法</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230102144243.jpg" alt="微信图片_20230102144243"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//排序后，数组中间的一定是超过一半的</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];<br>&#125;<br><br><br><br><span class="hljs-comment">//Boyer-Moore 投票算法，需要记住，空间复杂度消耗最小</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//初始情况</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            <span class="hljs-comment">//如果是当前候选数则count++，否则count--</span><br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="40、最小的k个数"><a href="#40、最小的k个数" class="headerlink" title="40、最小的k个数"></a>40、最小的k个数</h3><ul><li>思路总结<ul><li>简单方法：排序然后输出k个数（别用）</li><li>正常方法：使用最小堆，只维护k最小堆，保证空间复杂度为常数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 排除 0 的情况</span><br>            <span class="hljs-keyword">return</span> vec;<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer num1, Integer num2)</span> &#123;<br>                <span class="hljs-keyword">return</span> num2 - num1;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            queue.offer(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; arr.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (queue.peek() &gt; arr[i]) &#123;<br>                queue.poll();<br>                queue.offer(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            vec[i] = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h3><ul><li>使用两个堆，一个大顶堆一个小顶堆，分别进行存储，大顶堆存储小的，小顶堆存储大的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    Queue&lt;Integer&gt; A, B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 小顶堆，保存较大的一半</span><br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x)); <span class="hljs-comment">// 大顶堆，保存较小的一半</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//说明现在是奇数</span><br>        <span class="hljs-comment">//实际上这样操作就把中间那个元素一直推过来推过去</span><br>        <span class="hljs-keyword">if</span>(A.size() != B.size()) &#123;<br>            <span class="hljs-comment">//往A中添加了一个，然后又从A中弹一个给B，相当于只有B增加了</span><br>            A.add(num);<br>            B.add(A.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//说明现在是偶数</span><br>            <span class="hljs-comment">//往B中添加了一个，然后又从B中弹一个给A，相当于只有A增加了</span><br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//判断奇数偶数中位数计算</span><br>        <span class="hljs-keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102145540249.png" alt="image-20230102145540249"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划算法</span><br><span class="hljs-comment">//这里很有趣的一点是，并不是看后面的结果，而是看前面的结果，只要前面的数据能够让我的结果更大就加上</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//前一步只要不是负数我都加上</span><br>            nums[i] += Math.max(nums[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//res是上一步的最大值，num[i]是包含这一步的最大值</span><br>            res = Math.max(res, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43、求1～n这n个整数的十进制表示中1出现的次数"><a href="#43、求1～n这n个整数的十进制表示中1出现的次数" class="headerlink" title="43、求1～n这n个整数的十进制表示中1出现的次数"></a>43、求1～n这n个整数的十进制表示中1出现的次数</h3><ul><li>例如：输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次</li><li>数学推导：详见<a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/">面试题43. 1～n 整数中 1 出现的次数（清晰图解） - 1～n 整数中 1 出现的次数 - 力扣（LeetCode）</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>) res += high * digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>) res += high * digit + low + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> res += (high + <span class="hljs-number">1</span>) * digit;<br>            low += cur * digit;<br>            cur = high % <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="44、数学序列中某一位的数字"><a href="#44、数学序列中某一位的数字" class="headerlink" title="44、数学序列中某一位的数字"></a>44、数学序列中某一位的数字</h3><ul><li>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</li><li>经数学推导可以得到，个位数的长度为10，二位数的长度为90×2，三位数的长度为900×3</li><li>先计算长度得到是几位数，然后根据剩余量计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//注意这里的n是从0开始计数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; count) &#123; <span class="hljs-comment">// 1.</span><br>           <span class="hljs-comment">//这里并没有对其做累加操作，是将给定值和现有值做差</span><br>            n -= count;<br>            digit += <span class="hljs-number">1</span>;<br>            start *= <span class="hljs-number">10</span>;<br>            count = digit * start * <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> start + (n - <span class="hljs-number">1</span>) / digit; <span class="hljs-comment">// 2.</span><br>        <span class="hljs-keyword">return</span> Long.toString(num).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 3.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="45、把数组排成最小的数"><a href="#45、把数组排成最小的数" class="headerlink" title="45、把数组排成最小的数"></a>45、把数组排成最小的数</h3><ul><li>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</li><li>实际上就是一个对给定排序规则然后对数据进行排序的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//题目限定是非负整数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            strings[i] = String.valueOf(nums[i]);<br>        &#125;<br>    <span class="hljs-comment">//注意这里一定要重新更改排序法则，直接使用字典序排序是不合理的</span><br>        Arrays.sort(strings, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> (o1 + o2).compareTo(o2 + o1);<span class="hljs-comment">//简单比较两个字符串前后的大小</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            stringBuilder.append(strings[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="46、数字翻译为字符串"><a href="#46、数字翻译为字符串" class="headerlink" title="46、数字翻译为字符串"></a>46、数字翻译为字符串</h3><ul><li>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法</li><li>复杂版青蛙跳而已</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103181538332.png" alt="image-20230103181538332"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//y是移除最后一位，而x没有进行赋初值操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, x, y = num % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//注意这里num先除了个，所以这里的x是倒数第二位数</span><br>            num /= <span class="hljs-number">10</span>;<br>            x = num % <span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * x + y;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (tmp &gt;= <span class="hljs-number">10</span> &amp;&amp; tmp &lt;= <span class="hljs-number">25</span>) ? a + b : a;<br>            <span class="hljs-comment">//b是不带新数的情况</span><br>            b = a;<br>            <span class="hljs-comment">//a是带新数的情况</span><br>            a = c;<br>            y = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="47、礼物的最大价值"><a href="#47、礼物的最大价值" class="headerlink" title="47、礼物的最大价值"></a>47、礼物的最大价值</h3><ul><li>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102152018242.png" alt="image-20230102152018242"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划转移方程的基本使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) grid[i][j] += grid[i][j - <span class="hljs-number">1</span>] ;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) grid[i][j] += grid[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="hljs-number">1</span>], grid[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="48、最长不含重复字符的子字符串"><a href="#48、最长不含重复字符的子字符串" class="headerlink" title="48、最长不含重复字符的子字符串"></a>48、最长不含重复字符的子字符串</h3><ul><li>自己很简单想到的思路：使用hashmap判断有无重叠，使用hashmap维护对应字符最后出现的下标，并且更新当前滑动数组的左边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//这里不能只使用set作为标记，因为需要使用map来保存其前一个位置</span><br>        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<span class="hljs-comment">//注意这里的ij是左右指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span>(dic.containsKey(s.charAt(j)))<br>                i = Math.max(i, dic.get(s.charAt(j))); <span class="hljs-comment">// 更新左指针 i</span><br>            dic.put(s.charAt(j), j); <span class="hljs-comment">// 哈希表记录</span><br>            res = Math.max(res, j - i); <span class="hljs-comment">// 更新结果,这里不需要额外加一的原因是此时i和j对应的字符相同，需要剔除一个</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="49、丑数"><a href="#49、丑数" class="headerlink" title="49、丑数"></a>49、丑数</h3><ul><li>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103115942773.png" alt="image-20230103115942773"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据丑数的性质进行判断,这里注意 1 也是丑数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<br>            <span class="hljs-comment">//三个数之间求最小值</span><br>            dp[i] = Math.min(Math.min(n2, n3), n5);<br>            <span class="hljs-keyword">if</span>(dp[i] == n2) a++;<br>            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;<br>            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="50、第一个只出现一次的字符"><a href="#50、第一个只出现一次的字符" class="headerlink" title="50、第一个只出现一次的字符"></a>50、第一个只出现一次的字符</h3><ul><li>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单hashmap应用，使用LinkedHashMap的原因是有序哈希表中的键值对是 按照插入顺序排序 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 11 的字符”。哈希表是 去重 的，即哈希表中键值对数量 \leq≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] sc = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : sc)<br>            dic.put(c, !dic.containsKey(c));<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;<br>           <span class="hljs-keyword">if</span>(d.getValue()) <span class="hljs-keyword">return</span> d.getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="51、数组中的逆序对"><a href="#51、数组中的逆序对" class="headerlink" title="51、数组中的逆序对"></a>51、数组中的逆序对</h3><ul><li>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103210011592.png" alt="image-20230103210011592"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>        merge(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            merge(nums, left, mid);<br>            merge(nums, mid + <span class="hljs-number">1</span>, right);<br>            mergeSort(nums, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] temparr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> left, temp2 = mid + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid &amp;&amp; temp2 &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[temp1] &lt;= nums[temp2]) &#123;<br>                temparr[index++] = nums[temp1++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//用来统计逆序对的个数</span><br>                count += (mid - temp1 + <span class="hljs-number">1</span>);<br>                temparr[index++] = nums[temp2++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把左边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid) &#123;<br>            temparr[index++] = nums[temp1++];<br>        &#125;<br>        <span class="hljs-comment">//把右边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp2 &lt;= right) &#123;<br>            temparr[index++] = nums[temp2++];<br>        &#125;<br>        <span class="hljs-comment">//把新数组中的数覆盖nums数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; temparr.length; k++) &#123;<br>            nums[k + left] = temparr[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="52、两个链表的第一个公共结点"><a href="#52、两个链表的第一个公共结点" class="headerlink" title="52、两个链表的第一个公共结点"></a>52、两个链表的第一个公共结点</h3><ul><li>双指针法：实际上移动的过程就相当于补全两者的距离，时间复杂度为O（M+N）</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102165500571.png" alt="image-20230102165500571"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//这里不用担心需要遍历多遍的问题，由于之前落后的会更快的抵达，所以最多只要两者更长的遍历即可</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53、统计在排序数组中特定数字出现的次数"><a href="#53、统计在排序数组中特定数字出现的次数" class="headerlink" title="53、统计在排序数组中特定数字出现的次数"></a>53、统计在排序数组中特定数字出现的次数</h3><ul><li>简单二分法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这里考虑过如果只用一次二分法找到任意一个target然后左右扩展</span><br><span class="hljs-comment">//但是如果在相同的元素极多的情况下，这种方法可能退化成全表扫描</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> rightIdx - leftIdx + <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> lower)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>, ans = nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-2、缺失的数字"><a href="#53-2、缺失的数字" class="headerlink" title="53.2、缺失的数字"></a>53.2、缺失的数字</h3><ul><li>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单二分遍历（数字和下标应该正好对应，如果不对应则说明在左边）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="54、二叉树的第K大结点"><a href="#54、二叉树的第K大结点" class="headerlink" title="54、二叉树的第K大结点"></a>54、二叉树的第K大结点</h3><ul><li>中序遍历然后的第K即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//中序遍历,正序赋值数组</span><br>        inOrder(root);<br>        <span class="hljs-comment">//寻找第k大的数，输出</span><br>        <span class="hljs-keyword">return</span> arr.get(arr.size()-k);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrder(root.left);<br>        arr.add(root.val);<br>        inOrder(root.right);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="55、二叉树的深度"><a href="#55、二叉树的深度" class="headerlink" title="55、二叉树的深度"></a>55、二叉树的深度</h3><ul><li>深度优先算法和广度优先算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//BFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) tmp.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) tmp.add(node.right);<br>            &#125;<br>            queue = tmp;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//判断最大深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>            <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-comment">//最小深度的计算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs_depth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs_depth(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs_depth(node.right);<br>        <span class="hljs-comment">//注意对于左右结点为null的情况，如果其中有一个为null，那么其结果就是0，会干扰Math.min()的计算</span><br>        <span class="hljs-keyword">return</span> node.left == <span class="hljs-literal">null</span> || node.right == <span class="hljs-literal">null</span> ? left + right + <span class="hljs-number">1</span> : Math.min(left,right) + <span class="hljs-number">1</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="55-2、判断平衡二叉树"><a href="#55-2、判断平衡二叉树" class="headerlink" title="55.2、判断平衡二叉树"></a>55.2、判断平衡二叉树</h3><ul><li>注意只是平衡二叉树而不是二叉搜索树，左右不一定有序</li><li>平衡二叉树定义：如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树</li><li>判断依据： <strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1</li><li>注意通过绘图来理解算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> recur(root.left);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> recur(root.right);<br>        <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//只要有一个子结构返回  -1 整体就能判断二叉树不平衡</span><br>        <span class="hljs-comment">//如果左右只要相差不违规就正常返回</span><br>        <span class="hljs-keyword">return</span> Math.abs(left - right) &lt; <span class="hljs-number">2</span> ? Math.max(left, right) + <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-1、数组中数字出现的次数"><a href="#56-1、数组中数字出现的次数" class="headerlink" title="56.1、数组中数字出现的次数"></a>56.1、数组中数字出现的次数</h3><ul><li>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序<strong>找出这两个只出现一次的数字</strong>。要求时间复杂度是O(n)，空间复杂度是O(1)。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102172743293.png" alt="image-20230102172743293"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//利用异或性质（相同的数异或为0）</span><br><span class="hljs-comment">//注意这里需要重新对数组中的数组逐一再遍历一遍                  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)               <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) == <span class="hljs-number">0</span>)               <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//跳出的时候(n &amp; m) == 1 ，即两个数的位置数字不相同</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums) &#123;              <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>((num &amp; m) != <span class="hljs-number">0</span>) x ^= num;  <span class="hljs-comment">// 4. 当 num &amp; m != 0   这里就算和其他数字异或了也无所谓，因为其他数字都是双数，最后的结果都会是0</span><br>            <span class="hljs-keyword">else</span> y ^= num;                <span class="hljs-comment">// 4. 当 num &amp; m == 0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;x, y&#125;;          <span class="hljs-comment">// 5. 返回出现一次的数字</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-2、数组中数字出现的次数"><a href="#56-2、数组中数字出现的次数" class="headerlink" title="56.2、数组中数字出现的次数"></a>56.2、数组中数字出现的次数</h3><ul><li>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</li><li>只需要统计所有位的出现次数然后求余即可</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230103164448982.png" alt="image-20230103164448982"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//注意这里的位数实际上是相反运算的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//java中的int占据4个字节</span><br>        <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//注意常数次的位运算操作的时间复杂度为O(1)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>                counts[j] += num &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//  &gt;&gt; 表示右移，如果该数为正，则高位补0，若为负数，则高位补1</span><br>                <span class="hljs-comment">//  &gt;&gt;&gt;  运算符所作的是无符号的位移处理，它不会将所处理的值的最高位视为正负符号，</span><br>                <span class="hljs-comment">//所以作位移处理时，会直接在空出的高位填入0</span><br>                num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            res &lt;&lt;= <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//左移后补0，所以只要count中的该位置为1，即为1</span><br>            res |= counts[<span class="hljs-number">31</span> - i] % m;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="57-1、和为s的两个数"><a href="#57-1、和为s的两个数" class="headerlink" title="57.1、和为s的两个数"></a>57.1、和为s的两个数</h3><ul><li>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针法（简单推导可知，该种情况不会漏过解）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span>(s &lt; target) i++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; target) j--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums[i], nums[j] &#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="57-2、和为s的连续正数序列"><a href="#57-2、和为s的连续正数序列" class="headerlink" title="57.2、和为s的连续正数序列"></a>57.2、和为s的连续正数序列</h3><ul><li>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102190117234.png" alt="image-20230102190117234"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//滑动窗口（实际上应该是通过列式子计算效率更高，但是滑动窗口更合适作为通解）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>, s = <span class="hljs-number">3</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-comment">//注意下面是两个if，第一个if就算相等执行完了也需要进行滑动窗口的操作</span><br>            <span class="hljs-keyword">if</span>(s == target) &#123;<br>                <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[j - i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++)<br>                    ans[k - i] = k;<br>                res.add(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= target) &#123;<br>                s -= i;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>                s += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意ArrayList转为数组的参数</span><br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="58、翻转单词顺序"><a href="#58、翻转单词顺序" class="headerlink" title="58、翻转单词顺序"></a>58、翻转单词顺序</h3><ul><li>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”</li><li>切割+倒序输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针法：适用于不能使用spilt的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, i = j;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//倒序剪切</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 搜索首个空格</span><br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 添加单词</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span><br>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//适用于使用split的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        String[] strs = s.trim().split(<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 删除首尾空格，分割字符串</span><br>        <span class="hljs-comment">//注意split的结果，如果对于&quot;   a good     example   &quot;  进行split</span><br>        <span class="hljs-comment">//结果为[&quot;a&quot;, &quot;good&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;example&quot;]  即单词中间有n个空格就会分割出n-1个空格</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒序遍历单词列表</span><br>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 遇到空单词则跳过</span><br>            res.append(strs[i] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 将单词拼接至 StringBuilder</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串，删除尾部空格，并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="58-2、左旋转字符串"><a href="#58-2、左旋转字符串" class="headerlink" title="58.2、左旋转字符串"></a>58.2、左旋转字符串</h3><ul><li>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适用于能使用字符串函数的情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//简单拼接</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//注意这里如果要求不允许使用StringBuilder，使用string会导致每次字符串拼接都需要创建一个新的字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; n + s.length(); i++)<br>            res.append(s.charAt(i % s.length()));<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）"><a href="#59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）" class="headerlink" title="59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）"></a>59、滑动窗口的最大值（是指窗口内的Max，而且要输出每一次滑动的最大值）</h3><ul><li><strong>本题难点：</strong> 滑动窗口的长度是固定值，如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k） 降低至 O(1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当然可以直接使用优先队列，但是优先队列会导致一定开销</span><br><span class="hljs-comment">//这里使用单调队列进行实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//注意这里使用LinkedList实现</span><br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//需要输出的结果值</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//注意i的初始值为负数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span> - k; j &lt; nums.length; i++, j++) &#123;<br>            <span class="hljs-comment">// 删除 deque 中对应的 nums[i-1]（只有i&gt;0的情况下才能说明滑动窗口已经撑满了）</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>])<br>                deque.removeFirst();<br>            <br>            <span class="hljs-comment">// 保持 deque 递减</span><br>            <span class="hljs-comment">//注意是倒着去除最小值</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])<br>                deque.removeLast();<br>            deque.addLast(nums[j]);<br>            <br>            <span class="hljs-comment">// 记录窗口最大值（只有i&gt;0的情况下才能说明滑动窗口已经撑满了）</span><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)<br>                res[i] = deque.peekFirst();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59-2、队列当中的最大值"><a href="#59-2、队列当中的最大值" class="headerlink" title="59.2、队列当中的最大值"></a>59.2、队列当中的最大值</h3><ul><li>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//和上一题一样，关键在于如何保证获取队列中的最大值的函数是常数级别的</span><br><span class="hljs-comment">//使用单调双端队列来完成</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    Queue&lt;Integer&gt; queue;<br>    Deque&lt;Integer&gt; deque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//存储单调队列</span><br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> : deque.peekFirst();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        queue.offer(value);<br>        <span class="hljs-comment">//保持单调队列中的递减，将单调队列中所有小于当前值的都弹出</span><br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)<br>            deque.pollLast();<br>        deque.offerLast(value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(queue.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里很巧妙的一点是没有进行循环判断，而是只对队列中第一个元素判断</span><br>        <span class="hljs-comment">//因为两个队列实际上是相对有序的，弹出的这个元素只有可能是最大值或者是已经在单调队列中抛弃的值</span><br>        <span class="hljs-comment">//不可能是次大值，因为单调队列中是相对有序的，次大值一定要在最大值出现后才能出现</span><br>        <span class="hljs-keyword">if</span>(queue.peek().equals(deque.peekFirst()))<br>            deque.pollFirst();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="60、n个骰子对应点数和的概率"><a href="#60、n个骰子对应点数和的概率" class="headerlink" title="60、n个骰子对应点数和的概率"></a>60、n个骰子对应点数和的概率</h3><ul><li>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</li><li>首先如果考虑暴力求解由于每个骰子都有6种情况，所以结果是指数级的，时间复杂度过高</li><li>所以应该寻找规律通过递推法实现</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102195623876.png" alt="image-20230102195623876"></p><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102195600889.png" alt="image-20230102195600889"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] dicesProbability(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-comment">//初始值都是六分之一</span><br>        Arrays.fill(dp, <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">//这里的个数是由于i个骰子，最低即为i    （6 * i - i + 1 = 5 * i + 1）</span><br>            <span class="hljs-type">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; dp.length; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++) &#123;<br>                    tmp[j + k] += dp[j] / <span class="hljs-number">6.0</span>;<br>                &#125;<br>            &#125;<br>            dp = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="61、扑克牌中的顺子"><a href="#61、扑克牌中的顺子" class="headerlink" title="61、扑克牌中的顺子"></a>61、扑克牌中的顺子</h3><ul><li>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0(输入的就是0) ，可以看成任意数字。注意A是1而不是14（输入的就是1）</li><li>实际上就是输出0-13中的任意五个数，其中0可以被替代成任何数，判断这五个数是否连续</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">joker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当这个数组最好是有序，而给定数组不是有序的时候可以先进行数组排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++; <span class="hljs-comment">// 统计大小王数量</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若有重复，提前返回 false</span><br>        &#125;<br>        <span class="hljs-comment">//因为排序过了，所以判断顺子很简单，只需要看差值就可以</span><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="62、圆圈中最后剩下的数字"><a href="#62、圆圈中最后剩下的数字" class="headerlink" title="62、圆圈中最后剩下的数字"></a>62、圆圈中最后剩下的数字</h3><ul><li>经典约瑟夫环问题</li></ul><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102202109635.png" alt="image-20230102202109635"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            x = (x + m) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="63、股票的最大利润"><a href="#63、股票的最大利润" class="headerlink" title="63、股票的最大利润"></a>63、股票的最大利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-comment">//cost是遍历到price时能够使用的最小金额</span><br>            cost = Math.min(cost, price);<br>            <span class="hljs-comment">//profit是遍历到price之前的最大利润</span><br>            profit = Math.max(profit, price - cost);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="64、计算1到n的和"><a href="#64、计算1到n的和" class="headerlink" title="64、计算1到n的和"></a>64、计算1到n的和</h3><ul><li>傻篮子题目，不让用乘除还不让用判断，结果最优解使用位运算模拟乘除</li></ul><h3 id="65、位运算实现加法"><a href="#65、位运算实现加法" class="headerlink" title="65、位运算实现加法"></a>65、位运算实现加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>            a = a ^ b;<br>            b = carry;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="66、构建乘积数组"><a href="#66、构建乘积数组" class="headerlink" title="66、构建乘积数组"></a>66、构建乘积数组</h3><p><img src="D:\学习文件\计算机学习\计算机笔记\图片\image-20230102204013728.png" alt="image-20230102204013728"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算对应i位不算入乘法的乘积结果</span><br><span class="hljs-comment">//实际上本题是一个动态规划问题，在于如何最大化利用中间结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//先算左边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//后算右边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= a[i + <span class="hljs-number">1</span>];<br>            b[i] *= tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="67、把字符串转化成整数"><a href="#67、把字符串转化成整数" class="headerlink" title="67、把字符串转化成整数"></a>67、把字符串转化成整数</h3><ul><li>思路：去掉字符串开头的空格，判断负数正数，然后使用temp作为中介，循环读取并扩大10倍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strToInt</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">char</span>[] c = str.trim().toCharArray();<br>        <span class="hljs-keyword">if</span>(c.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) sign = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>) i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; c.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(c[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>) <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>            res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign * res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="68-1、二叉搜索树的最近公共祖先"><a href="#68-1、二叉搜索树的最近公共祖先" class="headerlink" title="68.1、二叉搜索树的最近公共祖先"></a>68.1、二叉搜索树的最近公共祖先</h3><ul><li>根据二叉树的性质实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//如果两个结点一左一右，那么当前节点就一定是其最近公共祖先（注意如果其中一个结点已经是当前root了，那么也直接返回）</span><br>            <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="hljs-comment">// p,q 都在 root 的右子树中</span><br>                root = root.right; <span class="hljs-comment">// 遍历至右子节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="hljs-comment">// p,q 都在 root 的左子树中</span><br>                root = root.left; <span class="hljs-comment">// 遍历至左子节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="68-2、普通二叉树的最近公共祖先"><a href="#68-2、普通二叉树的最近公共祖先" class="headerlink" title="68.2、普通二叉树的最近公共祖先"></a>68.2、普通二叉树的最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">//如果其中一个结点已经是当前root了，那么直接返回</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-comment">//如果能走到注释这一步，就说明左右都有数据返回，说明当前节点就是最近公共祖先</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题相关总结"><a href="#面试题相关总结" class="headerlink" title="面试题相关总结"></a>面试题相关总结</h1><h2 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h2><h3 id="java基础知识相关"><a href="#java基础知识相关" class="headerlink" title="java基础知识相关"></a>java基础知识相关</h3><ul><li><p>java和c++对比</p></li><li><p><strong>java和go对比</strong></p><ul><li><a href="https://blog.csdn.net/weixin_70730532/article/details/126405302">(51条消息) Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)_go java_Java烟雨的博客-CSDN博客</a></li><li>性能：这个是java和go之间对比必须聊到的一个话题，性能一直是java开发经常吐槽的地方。在串行的业务下，java的性能就比Go差，并发业务下，java更比go差远了。这个可能Go比较偏向于C，C++的缘故吧，go的性能可以媲美c，c++。</li><li>多线程：Go就是为多线程而生的，语法直接支持多线程，使用go语法即可使用多线程。在多线程逻辑实现方面Go也比java更清晰，更简单，这个就是后发语言的优势了，不知道kotlin能不够弥补这个缺点。在性能方面，Go多线程也是碾压java，Go协程相对于传统操作系统中的线程 (thread) 是非常轻量级的，所以Go在多线程方面是比java又快内存占用又小。</li><li>生态：这个是java的最大优势，现在go还处于发展阶段，每个新版本出来大家都要抢着升级，因为新功能太重要了，不用不行。就比如包管理功能，从go vendor到go module，都没有java maven强大，但是都不得不用。java新版本出来了，可能不见得会去升级，好多公司现在还在用jdk1.6，因为该有的功能java都已经有了，没必要再去赶潮流。还有java的spring全家桶，虽然go没有spring，不过好在go的web模块功能也还比较强大，虽然没有spring系列方便，但是也足够使用了。</li><li>编译，部署：这个对于java来说可能是最轻松的事了吧，在之前的互联网公司的时候，从来没有碰到过部署方面难题，更不用说编译了，本地编译ok，服务器一定更加ok，然后部署放到类似于阿里云这类的云容器上面，一键上线轻轻松松。但是go就不一样了，编译go如同编译C++一样，不同操作系统需要交叉编译，由于依赖服务器的一些环境，所以本地还运行不了Go程序，没办法本地debug，部署更是如同打仗一般，需要写很多python脚本来将编译构建之后部署至docker,k8s上</li></ul></li><li><p>Java的跨平台的机制是什么？</p><ul><li>java代码得到的class文件相同，不同平台使用各自对应的jvm进行解读class文件</li></ul></li><li><p>String类型不可修改，为什么呢？</p><ul><li>底层实现逻辑：在jdk8时底层为char[]，在jdk9的时候底层为byte[]</li><li>数组长度一旦声明则不可改变，字符串一旦声明则不可改变，改变的只是引用内存指向</li><li>不可修改的意义：<ul><li>方便实现字符串对象池，如果String可变，那么对象池就需要考虑何时深浅拷贝字符串的问题了</li><li>更方便缓存hashCode ，作为key时可以更高效的保存到hashmap中</li><li>线程安全，就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141317504.png" alt="856b9a63a67a4475ae85f87499dd1aa9"></li></ul></li><li><p>字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？  非要改String类型，能改的到吗？  new一个String对象，是放在哪里的？ TODO</p></li><li><p>StringBuilder和StringBuffer有什么区别</p><ul><li><p>最简单的解释：Buffer是线程安全的，Builder是线程不安全的</p></li><li><p>二者的相同点</p><ul><li>都继承AbstractStringBuilder这个抽象类，实现了CharSequence接口</li><li>其append方法都是调用了父类AbstractStringBuilder的append(String str)方法</li><li>初始容量都是16并且扩容机制也是相同的（”旧容量*2+2”）</li><li>底层都是用char[]字符数组实现，且字符数组都是可变的</li></ul></li><li><p>二者的不同点</p><ul><li><p>Buffer是线程安全的，Builder是线程不安全的</p></li><li><p>StringBuffer从JDK1.0就有了，StringBuilder是JDK5.0才出现</p></li><li><p>StringBuffer比StringBuilder多了一个toStringCache字段，用来在toString方法中进行缓存，每次append操作之前都先把toStringCache设置为null，若多次连续调用toString方法，可避免每次Arrays.copyOfRange(value, 0, count)操作，节省性能</p></li><li><p>由于StringBuilder没有考虑同步，在单线程情况下，StringBuilder的性能要优于StringBuffer</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>       toStringCache = <span class="hljs-literal">null</span>;<br>       <span class="hljs-built_in">super</span>.append(str);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>           toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p>反射机制有了解吗？反射创建对象和new创建对象有什么区别？  反射和new的性能哪个更高一点？</p></li><li><p>设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）</p></li><li><p>hashmap的底层结构</p></li><li><p>字符串相关</p><ul><li><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</li><li>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化</li><li>字符串常量池的实现是基于一个hashMap实现的，其长度有个常量值（可以通过参数修改<code>-XX:StringTableSize=99991</code>）如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降（因为要一个一个找）<ul><li>StringTableSize含义：Number of buckets in the interned String table<br>String.intern()被调用时会往Hashtable插入一个String（若该String不存在），这里的Table就是StringTable，此参数就是这个StringTable的大小<br>若此参数设置过小，明显的问题就是过多的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>碰撞，造成在查找字符串时比较消耗CPU资源<br>JDK1.6起，当冲突次数超过100次会自动rehash，即便如此，若此参数设置过小会导致不断的rehash，依然会过度消耗CPU资源，建议将此参数设置的值稍大一些，以减少hash冲突</li></ul></li></ul></li><li><p>HashMap</p><ul><li>HashMap的put操作的流程</li></ul></li><li><p>HashMap扩容流程</p><ul><li><a href="https://zhuanlan.zhihu.com/p/258347168">从基础到实践，一文带你看懂HashMap - 知乎 (zhihu.com)</a></li></ul></li><li><p>TreeMap和HashMap的区别</p><ul><li><a href="https://blog.csdn.net/dghehe/article/details/125474352">(51条消息) TreeMap和HashMap的区别_东莞呵呵的博客-CSDN博客_treemap和hashmap区别</a></li></ul></li><li><p>java集合（存储结构、使用场景、和List的区别，线程安全的Map）</p></li><li><p>讲讲创建线程的方式</p><ul><li><a href="https://blog.csdn.net/clear_0217/article/details/122736610">线程的创建方式_clear0217的博客-CSDN博客_线程的创建方式</a></li></ul></li><li><p>runnable接口和callable接口除了区别</p><ul><li>Callable规定的方法是call(),Runnable规定的方法是run().</li><li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值得</li><li>call方法可以抛出异常，run方法不可以</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li></ul></li><li><p>FutureTask的方法（只知道get）</p></li><li><p>浅拷贝和深拷贝</p><ul><li>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li><li>浅拷贝：变量保存的不是对象本身,是指向对象的地址，此时改变对象本身的内容,其他变量显示内容也会改变；如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li><li>浅拷贝两者指向同一元素，深拷贝两者互不影响</li></ul></li><li><p>异常类</p></li><li><p>try catch finally执行顺序</p></li><li><p>synchronized关键字、锁升级</p></li><li><p>面向对象SOLID原则：单一功能，开闭，里氏替换、接口隔离、依赖反转</p><ul><li><a href="https://blog.csdn.net/LiJiVV/article/details/112004467">(51条消息) 面向对象设计原则（SOLID）_蝎子莱布莱的博客-CSDN博客_面向对象设计的solid原则</a></li></ul></li><li><p>对于hash冲突，有什么解决办法吗？</p></li><li><p>怎么设计一个hash函数？（直接按照HashMap的hash思想说了一遍）</p></li><li><p>TreeMap和HashMap的查询效率分别是什么情况？</p><ul><li>[<a href="https://www.bbsmax.com/A/QW5YwyANzm/">Java] 多个Map的性能比较（TreeMap、HashMap、ConcurrentSkipListMap） (bbsmax.com)</a></li></ul></li><li><p>jdk19相关</p></li><li><p>常用在java集合类中的fastfail机制</p><ul><li><a href="https://blog.csdn.net/xiaoyuan_27/article/details/122077946">(49条消息) fail-fast 快速失败机制_Z_sh的博客-CSDN博客_快速失败机制</a></li></ul></li><li><p>java初始化原则：</p><ul><li><p>①静态对象（变量）优先于非静态对象（变量）初始化；</p><p>②父类优先于子类进行初始化；</p><p>③按照成员变量的定义顺序进行初始化；</p></li></ul></li></ul><h3 id="jvm相关"><a href="#jvm相关" class="headerlink" title="jvm相关"></a>jvm相关</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184312672.png" alt="image-20221120141317504"></p><ul><li><p>JVM内存是怎么管理的？</p></li><li><p>jvm调优常用参数</p></li><li><p>GC一般在什么时候触发？</p><ul><li><p>MinorGC触发</p><ul><li><p><strong>Allocation Failure：</strong> 分配对象失败，空间不足.</p></li><li><p><strong>Survivor 区满了</strong>，需要拷贝</p></li></ul></li><li><p>FullGC触发</p><ul><li><p><strong><code>System.gc()</code>被调用</strong>并且没有指定关闭显示GC，就是没有指定-XX:+DisableExplicitGC这个JVM flag</p></li><li><p><strong>老年代也满了</strong></p></li><li><p><strong>堆外内存满了</strong>，例如metaspace，代码即时编译缓存，直接内存，mmap内存</p></li><li><p><strong>gc 担保失败</strong>，请参考：-XX:-HandlePromotionFailure</p></li></ul></li></ul></li><li><p>调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？如果不是，是什么机制来保障的（finalize）（是想要回答二次标记问题）</p><ul><li>其实基本没什么机会用得到这个命令System.gc(), 因为这个命令只是建议JVM安排GC运行, 还有可能完全被拒绝。 GC本身是会周期性的自动运行的,由JVM决定运行的时机,而且现在的版本有多种更智能的模式可以选择,还会根据运行的机器自动去做选择,就算真的有性能上的需求,也应该去对GC的运行机制进行微调,而不是通过使用这个命令来实现性能的优化</li><li>频繁GC会导致服务器的资源被消耗殆尽程序卡顿，根据不同的垃圾收集器会造成不同的STW时间</li><li>Java语言规范并不保证finalize方法会被及时地执行，因为JVM通常在单独的低优先级线程中完成finalize的执行，而且根本不会保证它们会被执行</li><li>继承自object的finalize()它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以建议完全可以忘掉Java语言里面的这个方法</li></ul></li><li><p>高并发下的内存管理（海量并发线程创建了许多对象导致无法处理）</p><ul><li>优化代码中的处理请求的业务逻辑，尽 量少创建一次性对象，特别是内存占用大的对象。比如让 Request 对象在业务流程中一直传递下去，而不是每执行一个步骤，就创建一个内存和 Request 相似的新对象。</li><li>对于需要频繁的使用，或者占用内存较大的对象，可以考虑自行回收并重用这些对象。可以为这些对象加了一个对象池，收到请求后，在对象池内申请一个对象，使用完放回对象池。反复使用，避免频繁触发垃圾回收。</li></ul></li><li><p>Java有了GC之后还会有内存泄漏问题吗？</p><ul><li>静态集合类泄漏</li><li>单例对象由于持有对外部的引用而造成泄漏</li><li>连接：数据库网络IO等连接没有显示调用close关闭</li><li>监听器：在释放对象的时候没有删除对应监听器（实际上应该是所有的发布订阅模型都会存在这个问题）<ul><li>可以使用弱引用（其他引用使用同理）来不太好的解决这种问题 WeakReference<String> weakReference &#x3D; new WeakReference&lt;&gt;(str1); </li><li>同样对于比较重要或者比较限制的资源需要及时的释放资源来保证运行</li></ul></li></ul></li><li><p>哪些可以作为GC Roots？</p><ul><li><p>总结：GC Roots即运行过程中必不可少的部分</p><ul><li><strong>本地变量表，静态变量，常量，本地方法（引用的对象），jvm内部对象，同步锁的对象，反应jvm内部的对象</strong></li></ul></li><li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p></li><li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</p></li><li><p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</p></li><li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</p></li><li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。</p></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li></ul></li><li><p>jvm内存模型</p><ul><li>详见jvm笔记</li></ul></li><li><p>方法区，元空间，永久代辨析</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184550382.png" alt="image-20221126184312672"></li><li>方法区是抽象概念，而元空间和永久代是在不同版本时对于方法区的实现</li></ul></li><li><p>元空间</p><ul><li><p>使用本地内存存储元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题 </p></li><li><p>回收元空间的时机分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。</p></li></ul></li><li><p>哪些地方会发生内存溢出（除了PC其他都会溢出）</p><ul><li><p>1、方法区溢出</p><p>第一种原因：上线的时候MetaSpace区域直接用默认的参数，即根本不设置其大小，这会导Meta</p><p>Space区域可能才几十M而已或者设置的比较小，此时对于一个稍微大型系统，因为他有很多自己的类，还依赖了很多外部jar包的类，MetaSpace空间很容易不够的。</p><p>第二种原因：就是很多人开发系统代码都会用一些cglib之类的技术动态生成一些类，一旦代码没有控制好，导致生成的类过多的时候，就很容易MetaSpace给塞满，进而引起内存溢出。</p><p>2、虚拟机栈&#x2F;本地方法栈溢出<br>（1）StackOverflowError：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常。最常见的场景就是方法无限递归调用。<br>（2）OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError。<br>虚拟机中可以供栈占用的空间≈可用物理内存 - 最大堆内存 - 最大方法区内存，比如一台机器内存为 4G，系统和其他应用占用 2G，虚拟机可用的物理内存为 2G，最大堆内存为 1G，最大方法区内存为 512M，那可供栈占有的内存大约就是 512M，假如我们设置每个线程栈的大小为 1M，那虚拟机中最多可以创建 512个线程，超过 512个线程再创建就没有空间可以给栈了，就报 OutOfMemoryError 异常了。</p><p>3、堆内存溢出<br>（1）内存中加载的数据过多如一次从<strong>数据库</strong>中取出过多数据；集合对对象引用过多且使用完后没有清空；代码中存在死循环或循环产生过多重复对象；堆内存分配不合理；网络连接问题、数据库问题等。<br>（2）系统承载高并发请求，因为请求量过大，导致大量的对象都是存活的，所以要放入新的对象放不下了，此时就会引起内存溢出系统崩溃；<br>（3）系统有泄漏的问题，就是莫名其妙产生了很多对象，结果对象都是存活的，没有及时取消他们的引用，导致触发GC还是无法回收，此时只能引发内存溢出，因为实在是放不下更多的对象了。</p><p>4、本机直接内存溢出<br>本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但 Java 中用到 NIO 相关操作时（比如 ByteBuffer 的 allocteDirect 方法申请的是本机直接内存），也可能会出现内存溢出的异常</p></li></ul></li><li><p>string常量池在哪</p><ul><li>位于方法区中，根据java版本的不同，在java7之前存放在永久代中，在java7后将其移动到java堆中</li></ul></li><li><p>字面量和符号引用的区别</p><ul><li>符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够在使用的时候无歧义的定位到对应目标即可，例如在class文件中常以CONSTANT_Class_info等变量的形式出现</li><li>字面量就是对应赋值操作中的常量值，如”abc”,1等</li></ul></li><li><p>JVM广义上的常量池分类</p><ul><li><p>1.类文件常量池</p><pre><code class="hljs">     我们写的每一个Java类被编译后，就会形成一份class文件（每个class文件都有一个class常量池）。 class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)   字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;   符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。</code></pre><ol start="2"><li>运行时常量池</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">运行时常量池（Runtime <span class="hljs-keyword">Constant</span> Pool）是方法区的一部分。jdk1<span class="hljs-number">.8</span>以前存在于永久代，jdk1<span class="hljs-number">.8</span>之后存在于元空间。静态常量池中的内容，在类加载后会被存放到方法区的运行时常量池中。运行时常量池相对于<span class="hljs-keyword">Class</span>文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入<span class="hljs-keyword">Class</span>文件中静态常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。<br></code></pre></td></tr></table></figure><p>3.字符串常量池</p><pre><code class="hljs">    字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。字符串常量池的存在使JVM提高了性能和减少了内存开销。    字符串常量池可以理解为是分担了部分运行时常量池的工作。和其他的对象分配一样，字符串耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能，为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化，为字符串开辟一个字符串常量池，类似于缓存区。实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用。    加载时，对于class文件的静态常量池，字符串字面量会进入到当前类的运行时常量池，但不会立即进入全局的字符串常量池（即在字符串常量池中并没有相应的引用，在堆中也没有对应的对象产生），字符串常量池是lazy resolve的，在第一次引用该项的ldc指令被第一次执行到的时候才会resolve，但这个过程我们可以不关注。可以认为当类加载完成后，运行代码String str1=&quot;abc&quot;或String str2=new String(“abc”)时，字面量“abc”已经存在于字符串常量池。jdk7字符串常量池以后存在于堆中</code></pre></li></ul></li><li><p>JMM</p><ul><li><a href="https://blog.csdn.net/ChineseSoftware/article/details/119212455">Java 内存模型(Java Memory Model)_hfnjfudnnr的博客-CSDN博客</a></li><li>定义：JMM 是Java内存模型（ Java Memory Model）。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范，是和多线程相关的一组规范。<strong>通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式</strong>方需要每个JVM 的实现都要遵守这样的规范，有了JMM规范的保障，并发程序运行在不同的虚拟机上时，得到的程序结果才是安全可靠可信赖的</li><li>详细定义见JVM书599</li></ul></li><li><p>GC日志（尝试阅读）（TODO 深入理解虚拟机4，5章）</p><ul><li><a href="https://zhuanlan.zhihu.com/p/267388951">JVM实战：GC日志解析 - 知乎 (zhihu.com)</a></li></ul></li><li><p>类加载相关：</p></li><li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183754754.png" alt="image-20221126185026711"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/856b9a63a67a4475ae85f87499dd1aa9.png" alt="image-20221126183754754"></p><ul><li><p>加载（loading）</p><ul><li>加载是读取class文件（网络，动态生成等），并将其转换为某种静态数据结构存储在<strong>方法区</strong>中，并在<strong>堆</strong>中生成一个便于用户调用的java.lang.Class类型对象的过程</li></ul></li><li><p>验证：</p><ul><li>进行文件格式验证，元数据，字节码验证，符号引用验证等（这些行为是在整个运行期间都存在的），保证安全性</li></ul></li><li><p>准备：</p><ul><li>进行相关赋值操作</li></ul></li><li><p>解析：</p><ul><li>将符号引用替换成直接引用</li><li>动态解析：如果引用的B类是一个接口，而其实现是C或者D，那么就将其暂且搁置，直到真正调用其实现类的时候，才将A的符号引用转变为对C和D的直接引用</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183648553.png" alt="image-20221126184550382"></p></li><li><p>初始化：</p><ul><li>判断代码中是否存在主动的类的资源初始化操作（不同于对象的初始化操作，对象的初始化只有在显式调用new时才会进行），如果有则进行执行</li></ul></li><li><p>使用</p></li><li><p>类卸载</p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221129145421079.png" alt="image-20221126185238672"></p></li><li><p>java代码执行流程</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185026711.png" alt="image-20221126183648553"></li></ul></li><li><p><strong>栈上替换，方法内联，代码缓存</strong></p><ul><li><a href="https://blog.csdn.net/justinzengTM/article/details/114255737">(49条消息) 栈上替换、方法内联和代码缓存_大力海棠的博客-CSDN博客_栈上替换</a></li></ul></li><li><p>对象头相关</p><ul><li><a href="https://juejin.cn/post/6844903832833490957">Java对象在内存的结构 - 掘金 (juejin.cn)</a></li></ul></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li><p>Redis和大型数据库有什么区别？</p><ul><li><a href="https://blog.csdn.net/agonie201218/article/details/123656539"> Redis的优势和特点</a></li></ul></li><li><p>Redis高效的原因</p><ul><li><a href="https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw">为什么单线程的 Redis 如何做到每秒数万 QPS ？ (qq.com)</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></li></ul></li><li><p>redis雪崩、穿透、击穿的原因和解决方案</p><ul><li>小林code</li></ul></li><li><p>redis的常见数据类型及应用场景</p><ul><li>小林code</li></ul></li><li><p>LPOP 和 BLPOP 的区别</p><ul><li>LPOP命令如果遇到列表中的数据为空时，则直接返回空值</li><li>BLPOP 命令可以弹出指定列表中的头部的元素，若所有的列表均不存在或者为空，则阻塞等待</li></ul></li><li><p>Redis 消息队列和 MQ 的区别</p><ul><li><p><strong>可靠消费</strong></p><ul><li>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理</li><li>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费</li></ul></li><li><p><strong>可靠发布</strong></p><ul><li><p>Reids：不提供，需自行实现，Redis的消息队列，如果在从队列pop出去的时候，worker处理失败的话，数据不会回到队列中，需要从业务中手动把失败的处理数据push到队列中；</p></li><li><p>RabbitMQ：具有发布确认功能，保证消息被发布到服务器RabbitMQ有一个消息确认机制来保证消息的不丢失：</p><ul><li>客户端从队列中取出消息之后，可能需要一段时间才能处理完成，如果在这个过程中，客户端出错了，异常退出了，而数据还没有处理完成，那么非常不幸，这段数据就丢失了，因为RabbitMQ默认会把此消息标记为已完成，然后从队列中移除。</li><li>消息确认是客户端从RabbitMQ中取出消息，并处理完成之后，会发送一个ack告诉RabbitMQ，消息处理完成，当RabbitMQ收到客户端的获取消息请求之后，或标记为处理中，当再次收到ack之后，才会标记为已完成，然后从队列中删除。当RabbitMQ检测到客户端和自己断开链接之后，还没收到ack，则会重新将消息放回消息队列，交给下一个客户端处理，保证消息不丢失，也就是说，RabbitMQ给了客户端足够长的时间来做数据处理。</li></ul></li></ul></li><li><p><strong>高可用</strong></p><ul><li>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案</li><li>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作</li></ul></li><li><p><strong>持久化</strong></p><ul><li>Redis：将整个Redis实例持久化到磁盘</li><li>RabbitMQ：队列，消息，都可以选择是否持久化</li></ul></li><li><p><strong>消费者负载均衡</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：根据消费者情况，进行消息的均衡分发</li></ul></li><li><p><strong>队列监控</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）</li></ul></li><li><p><strong>流量控制</strong></p><ul><li>Redis：不提供，需自行实现</li><li>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性</li></ul></li><li><p><strong>总结</strong></p><ul><li>redis： 轻量级，低延迟，高并发，低可靠性；</li><li>rabbitmq：重量级，高可靠，异步，不保证实时；</li><li><strong>rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。</strong></li></ul></li></ul></li><li><p>原生Redis分布式锁有什么问题，怎么解决（TODO 分布式锁的实现）</p></li><li><p>Redis持久化机制</p><ul><li>小林code</li></ul></li><li><p>Redis键过期策略</p><ul><li>小林code（Redis 过期删除策略和内存淘汰策略有什么区别？）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185238672.png" alt="image-20221129145421079"></p></li><li><p>Redis的数据一致性（主备复制）怎么做的？</p><ul><li>小林code</li></ul></li><li><p>（TODO 集群网课）项目是单机还是多机架构？你怎么认为Redis的集群模式？为什么要有集群？</p><ul><li>小林code</li></ul></li><li><p>initServer 启动服务，另外一个就是 aeMain 事件循环</p></li><li><p>SDS（简单动态字符串）</p></li><li><p><strong>quicklist</strong> </p></li><li><p>Redis缓存更新的策略（读写策略出现问题往往是A线程执行的操作把B线程包裹住了）</p><ul><li><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路 | 酷 壳 - CoolShell</a></li><li>小林code相关</li><li>一致性要求低时（一般不会单纯使用这种方式）：使用Redis自带的内存淘汰机制</li><li>一致性要求高时：主动更新，并采用超时剔除兜底方案<ul><li><p>读操作</p><ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库并写入缓存，并设置其超时时间</li></ul></li><li><p>写操作</p><ul><li><strong>先写入数据库然后再删除缓存</strong>（并不写入缓存，只是删除缓存）</li><li><strong>确保数据库和缓存操作的原子性</strong></li></ul></li></ul></li></ul></li><li><p><strong>IO多路复用总结：</strong>(epoll用于Redis，Nginx，JavaNIO（基于Linux）)</p><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/410316787">深入理解 Linux 的 epoll 机制及epoll原理 - 知乎 (zhihu.com)</a></p><ul><li><p>epoll_create：创建一个 epoll 对象</p></li><li><p>epoll_ctl：向 epoll 对象中添加要管理的连接</p></li><li><p>epoll_wait：等待其管理的连接上的 IO 事件</p></li></ul></li><li><p>Select</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141809023.png" alt="image-20221125161407202"></li></ul></li><li><p>Poll</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165519514.png" alt="image-20221125162139212"></li></ul></li><li><p>Epoll</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165600678.png" alt="image-20221125162858367"></li></ul></li><li><p>epool快速的关键</p><ul><li>内部管理 fd 使用了高效的红黑树结构管理，做到了增删改之后性能的优化和平衡；</li><li>epoll 池添加 fd 的时候，调用 file_operations-&gt;poll ，把这个 fd 就绪之后的回调路径安排好。通过事件通知的形式，做到最高效的运行；</li><li>epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；</li></ul></li><li><p>布隆过滤器</p><ul><li><a href="https://blog.csdn.net/qq_41125219/article/details/119982158">(53条消息) 布隆(Bloom Filter)过滤器——全面讲解，建议收藏_李子捌的博客-CSDN博客</a></li><li><a href="http://c.biancheng.net/redis/bloom-filter.html">Redis布隆过滤器（原理+图解） (biancheng.net)</a></li><li><a href="https://www.bilibili.com/video/BV1zK4y1h7pA/?spm_id_from=333.337.search-card.all.click&vd_source=9a4f938fc995660b06355915cb8675cb">程序员都必须会的技术，面试必备【布隆过滤器详解】，Redis缓存穿透解决方案_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV14K411c7Yo/?spm_id_from=333.999.0.0&vd_source=9a4f938fc995660b06355915cb8675cb">面试阿里，竟然给了我一窝鸟蛋，让我用鸟蛋讲布谷鸟过滤器，这是什么鬼？_哔哩哔哩_bilibili</a></li></ul></li></ul></li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li><p>编码的时候，会做网络序转换，为什么要做这个转换呢？</p><ul><li>由于不同的系统对应的大小端不同需要进行转换，并且使用小端能够更好的进行部分计算机运算</li><li>大小端模式：</li><li><a href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">大端与小端的比较</a></li><li>大端实际上就是按照内存地址递增的方向顺序存储，小端即反向存储对应结构</li><li>网络传输字节序<ul><li>TCP&#x2F;IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化</li></ul></li><li>常见的处理器大小端模式<ul><li>x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian</li><li>Motorola 6800，Motorola 68000，PowerPC 970，System&#x2F;370，SPARC（除V9外）等处理器为Big endian</li><li>ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的</li></ul></li><li>判断大小端的程序写法<ul><li>给定一个int类型的数字num值为1<br>如果是大端字节序，则在内存中存储方式为 0000 0000    0000 0000   0000 0000    0000 0001<br>如果是小端字节序，则在内存中存储方式为   0000 0001    0000 0000   0000 0000    0000 0000<br>要判断它们，我们可以只取出第一个字节，如果是0，则是大端；如果是1，则是小端</li></ul></li></ul></li><li><p>多级cache</p><ul><li><p><a href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell</a>(写的非常好)</p></li><li><p><a href="https://blog.csdn.net/m0_38017860/article/details/122988861">(缓存一致性协议-MESI_小盒子的技术分享的博客-CSDN博客</a>(关于MESI的使用)</p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162858367.png" alt="image-20221120141809023"></p><ul><li><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存</p><p>读取数据过程。就像数据库缓存一样，首先在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，向内存要数据。一次次地未命中，代表取数据消耗的时间越长。</p></li><li><p>CPU缓存(cache)是由很多个Cache line组成的。Cache line是CPU缓存和主存交换数据的最小单位，Cache line大小是固定的，通常为64Byte</p></li><li><p>当数据大小超过Cache line的固定大小时，就没法用缓存一致性协议了，会转而使用总线加锁</p></li><li><p>缓存一致性（MESI）协议</p><ul><li>缓存一致性协议提供了一种高效的内存数据管理方案，它<strong>只会对单个缓存行（缓存行是缓存中数据存储的基本单元）的数据进行加锁，不会影响到内存中其他数据的读写</strong></li><li>缓存一致性协议有MSI，MESI，MOSI，Synapse，Firefly及DragonProtocol等</li><li>其中MESI分别代表缓存行数据所处的四种状态，通过这四种状态的切换，来管理缓存数据。可以使用2bit进行表示<ul><li>M修改（Modefiy）：该缓存行有效， 数据被修改了，和内存中的数据不一样，数据只存在于本缓存行中</li><li>E独享（Exclusive）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据只存在本缓存行中</li><li>S共享（Shared）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据同时存在于其他缓存中</li><li>I无效（Invalid）：该缓存行数据无效</li></ul></li><li>MESI协议总结<ul><li>当CPU进行写操作时，如果发现操作的变量是共享变量，则会发出信号通知其他的CPU将该变量的缓存行置为无效状态，此时其他的CPU需要读取这个变量时，发现自己缓存中是无效的就会从内存中重新读取数据来保证一致性<ul><li>所谓同步化是使用监听（嗅探）其他cpu对该缓存行对应主内存地址的读取操作来实现同步</li></ul></li><li>其正常运行依赖于以下两点<ul><li>读取数据时，其他CPU缓存行如果修改了数据，需要先把修改的数据写入主存中</li><li>当修改数据时，其他CPU中缓存行都必须失效</li></ul></li><li>由于缓存行的形式，可能同时存在多个核需要修改的值存放在同一缓存行的情况，这时就会由于两个核都竞相写入这个缓存行并且导致其他核中缓存无效的重复操作，故需要进行把缓存行中仅存储目标变量，其余空间采用“无用”数据填充补齐64字节</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162139212.png" alt="image-20221122165519514"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165542010.png" alt="image-20221122165542010"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161659369.png" alt="image-20221122165600678"></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165626261.png" alt="image-20221122165626261"></li><li>AMD的Opteron处理器使用从MESI中演化出的MOESI协议，O(Owned)是MESI中S和M的一个合体，表示本Cache line被修改，和内存中的数据不一致，不过其它的核可以有这份数据的拷贝，状态为S</li><li>Intel的core i7处理器使用从MESI中演化出的MESIF协议，F(Forward)从Share中演化而来，一个Cache line如果是Forward状态，它可以把数据直接传给其它内核的Cache，而Share则不能</li><li>每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li><li>嗅探所导致的问题：<strong>总线风暴</strong>，由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值</li><li>嗅探本身其实就是缓存一致性的一种实现<ul><li><strong>每个处理器内核都会监听在CPU总线上传播的数据，并检查自己的缓存值是否已过期；如果处理器发现自己缓存行对应的内存地址已被修改，就会将当前处理器的缓存行设置为无效状态当处理器对这个数据进行修改操作时，会重新从主内存中把数据读取到处理器的缓存中。</strong></li></ul></li></ul></li></ul></li><li><p><strong>DMA</strong>  <strong>直接内存访问（Direct Memory Access）</strong></p><ul><li><strong>总结：</strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务（聪明的CPU让DMA去做搬运数据等脏活累活，直到干完活后才通知CPU过来做从内核缓冲区到用户缓冲区这样高难度的工作）</li><li>每个 I&#x2F;O 设备都有自己的 DMA 控制器</li><li>小林code</li></ul></li><li><p>零拷贝及IO优化</p><ul><li>小林code操作系统第九章</li><li><strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong></li><li>零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</li><li>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I&#x2F;O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能</li></ul></li><li><p>PageCash相关</p><ul><li>小林code操作系统第九章</li><li>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题</li><li>在高并发的场景下，针对大文件的传输的方式，应该使用<strong>「异步 I&#x2F;O + 直接 I&#x2F;O」</strong>来替代零拷贝技术。</li></ul></li><li><p>两层循环，循环次数多的放内层还是外层</p><ul><li>结论：存在嵌套循环时，大循环写里面，小循环写外面</li><li>原因：外层的循环次数正比于预测错误的次数，为了尽可能的降低预测错误的次数，故将外层循环次数降低</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164538597.png" alt="image-20221117183934578"></li></ul></li><li><p><strong>命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，PTY区别辨析</strong></p><ul><li><a href="https://segmentfault.com/a/1190000016129862">linux - 命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？ - PRIN 的专栏 - SegmentFault 思否</a></li><li><a href="https://segmentfault.com/a/1190000009082089">Linux TTY&#x2F;PTS概述 - Linux程序员 - SegmentFault 思否</a></li></ul></li><li><p><strong>TLB和Cache的区别</strong></p><ul><li>[TLB 和 cache 辨析 | feng 言 feng 语 (feng-qi.github.io)](<a href="https://feng-qi.github.io/2017/01/06/tlb-and-cache/#:~:text=TLB">https://feng-qi.github.io/2017/01/06/tlb-and-cache/#:~:text=TLB</a> 和 CPU cache 都是起到对系统的关键操作（或者说耗时操作）进行加速的作用， 具体来说就是： TLB,缓存了常用的页表项，减少了虚拟地址到物理地址转换的耗时。 CPU cache 缓存了常用的内存数据，减少了访问内存的耗时。 或者说它们都减少了相应的耗时操作。 从某些方面来说，他们都是一种缓存，只不过 它们缓存的是不同的东西。)</li></ul></li><li><p>申请的内存并不会立马和物理内存产生映射，只有在需要使用时，才对使用的<strong>部分</strong>进行真实映射</p><ul><li>TODO判断是否是部分映射</li></ul></li><li><p>并且如果在开启swap的情况下，即使申请了比物理内存更大的空间也可以申请成功</p></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230227221821339.png" alt="image-20230227221821339"></p><ul><li><p>具体的磁盘调度算法可以在linux中进行修改</p><ul><li><a href="https://blog.csdn.net/zhang123456456/article/details/82345712">(53条消息) linux之 修改磁盘调度算法_张冲andy的博客-CSDN博客_修改磁盘调度算法</a></li></ul></li><li><p><strong>CPU频率相关</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/30582175">讲了这么多年的CPU频率，到底是什么？ - 知乎 (zhihu.com)</a></li><li>频率实际上就是一秒钟CPU的时钟周期数</li><li>时钟周期可以看做是CPU世界里的基本事件衡量单位，为了便于人理解才换算成频率</li></ul></li><li><p>SMP，NUMA相关</p><ul><li><a href="https://zhuanlan.zhihu.com/p/448678348">计算机基础知识：smp、numa、对称多处理系统 - 知乎 (zhihu.com)</a></li></ul></li><li><p><strong>IO，NIO，BIO总结</strong></p><ul><li><p><a href="https://juejin.cn/post/7184673497065455677?share_token=24e1c16d-c1a2-4dd0-b725-11209e12c146#heading-1">IO、NIO、BIO傻傻分不清吗，让我对象告诉你~~ - 掘金 (juejin.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/23488863">Java NIO浅析 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1376675">Java核心（五）深入理解BIO、NIO、AIO - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I&#x2F;O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p></li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li><p>TODO 网络数据传输解析全过程</p></li><li><p>ICMP协议，有了解吗？</p><ul><li>ICMP是（Internet Control Message Protocol）Internet控制报文协议</li><li>主要功能（Ping）<ul><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ul></li></ul></li><li><p>HTTP和HTTPS的区别是什么？</p><ul><li><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&utm_relevant_index=1"> HTTP和HTTPS协议，看一篇就够了_会飞的狗~的博客-CSDN博客</a></li><li><a href="https://tyler-zx.blog.csdn.net/article/details/80969419?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&utm_relevant_index=1"> HTTP 和 HTTPS 的区别（面试常考题）_Tyler_Zx的博客-CSDN博客_http和https区别</a></li></ul></li><li><p>http版本相关</p><ul><li><p>HTTP0.9</p><ul><li>最早版本是<code>1991</code>年发布的<code>0.9</code>版。该版本极其简单，只有一个命令<code>GET</code>。协议规定，服务器只能回应<code>HTML</code>格式的字符串，不能回应别的格式。服务器发送完毕，就关闭TCP连接</li></ul></li><li><p>HTTP1.0</p><ul><li>除了<code>GET</code>，还引入了<code>POST</code>和<code>HEAD</code>方法，丰富了浏览器与服务器的互动手段。此时不仅可以传输文字，还能传输图像、视频、二进制文件。<code>HTTP/1.0</code> 版的主要缺点是，每个<code>TCP</code>连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接（短连接）</li></ul></li><li><p>HTTP1.1</p><ul><li>默认使用长链接，支持管道化，不必等前一个请求响应才发出第二个请求，还提供了与身份认证、状态管理和 <code>Cache</code> 缓存等机制相关的请求头和响应头此外，还新增了五种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code>，并且增加了host字段</li></ul></li><li><p>HTTP2</p><ul><li>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</li><li>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分</li><li>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率</li><li>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li><li>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</li></ul></li><li><p>HTTP3</p><ul><li>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP</li></ul></li></ul></li><li><p>数字证书使用了什么机制？  数字证书为什么可以被创建？</p><ul><li><a href="https://www.bilibili.com/video/BV15P4y1S7Jw/?spm_id_from=333.337.search-card.all.click&vd_source=9a4f938fc995660b06355915cb8675cb">【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】_哔哩哔哩_bilibili</a></li></ul></li><li><p>http的三次握手四次挥手</p><ul><li>小林code</li></ul></li><li><p>http的几种常见状态码</p><ul><li><a href="https://blog.csdn.net/DGMM_/article/details/120641072">常见的http状态码有哪些_呆瓜瓜瓜的博客-CSDN博客_http状态码</a></li></ul></li><li><p>http长连接</p><ul><li><a href="https://blog.csdn.net/hyxhbj1/article/details/124904092"> HTTP 长连接原理_Leo90567的博客-CSDN博客</a></li></ul></li><li><p>SSL协议和TLS协议</p><ul><li><p><strong>SSL 和 TLS 没有太大的区别。</strong></p><p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p></li></ul></li><li><p>浏览器解析页面的过程（TODO 进一步细化到ARP层）</p><ul><li>在地址栏中输入URL</li><li>对输入的URL进行DNS解析，获取目标服务器IP地址，优先浏览器DNS缓存查询&gt;本地host文件查询，如没有则进行递归或迭代查询，本地区的域名服务器&gt;根DNS域名服务器&gt;顶级域名服务器&gt;依次向下</li><li>像目标IP发送http请求</li><li>建立tcp链接</li><li>接受返回数据</li><li>浏览器渲染线程解析html文件，方向由上至下</li><li>解析HTML文件标签对并渲染</li><li>（从dhcp，到dns解析，到http，到tcp，到arp，到nat、到局域网，因特网，我很详细地说了）</li><li>详见小林code</li></ul></li><li><p>TCP模型、流量控制、拥塞控制</p></li><li><p>tcp如何实现可靠传输</p></li><li><p>tcp和udp区别</p></li><li><p>如何基于udp实现可靠传输</p><ul><li>小林code</li><li>TCP的缺点：<a href="https://mp.weixin.qq.com/s/9kHoRk6QIYOFUR_PCmHY6g">TCP 就没什么缺陷吗？ (qq.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/405387352">https://zhuanlan.zhihu.com/p/405387352</a></li><li>不应该考虑如何在应用层实现TCP的特点（那样不如直接使用TCP），而是要强调UDP的特点</li></ul></li><li><p>CDN相关</p><ul><li><a href="https://cloud.tencent.com/developer/article/1779335">什么是CDN？它解决了什么难题？5分钟让你明明白白！ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul></li><li><p>cookie，session，token相关</p><ul><li><a href="https://zhuanlan.zhihu.com/p/63061864">彻底理解cookie，session，token - 知乎 (zhihu.com)</a></li><li>类似session无法共享的问题都可以通过创建一个中间层如Redis，让所有的服务器在获取session的时候都向Redis请求</li><li>token的作用并不是保证身份不会被盗用，而是保证传递的数据不能被修改，由于token中自带了对应的签名，当获取到token后，服务器端只需要再对token本身计算一次，如果计算结果和传递的token中的签名一致则说明数据没有被修改过</li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><p>线程、进程和协程</p><ul><li><a href="https://blog.csdn.net/qq_39304851/article/details/119975280">进程、线程、协程_Pinker_Q的博客-CSDN博客_进程 线程 协程</a></li><li>早期操作系统只有进程这个唯一的执行体，而现在出现了<strong>进程内的执行体</strong>（线程和协程）</li><li>进程是<strong>资源分配</strong>（内存，显卡，磁盘）的最小单位，线程是<strong>程序执行</strong>(cpu调度)的最小单元</li></ul></li><li><p>线程上下文切换的开销</p><ul><li>直接开销：操作系统保存恢复上下文（CPU寄存器值，程序计数器值）所需的开销； 线程调度器调度线程的开销</li><li>间接开销：处理器高速缓存重新加载的开销；上下文切换可能导致整个一级高速缓存中的内容被冲刷，即被写入到下一级高速缓存或主存</li></ul></li><li><p>进程和协程之间的互斥</p></li><li><p>PV操作相关</p></li><li><p>多核对于多线程的分配</p><ul><li>同一个核上同时只会有一个线程在跑，线程本身由操作系统调度，操作系统会根据线程的优先级等内容为线程分配时间片，如果所属时间片用完操作系统会将该线程的上下文保存起来，然后把另外的线程选一个将上下文推到栈内，然后切换到对应代码块执行代码</li><li>所以运行态线程多的情况下，需要一小部分cpu用于线程的上下文切换，而且还有执行上下文切换时的内核态和用户态的切换开销</li><li>一个核同一时间只能执行一条线程，所以不能盲目的增加线程，当线程过多时，CPU核快速切换线程也会导致效率下降</li><li>针对不同情况选择不同的线程数，对于计算密集型线程，为了尽可能保证每一个核都被利用，需要将线程数和核心数相统一，对于IO密集型线程，则可以相对创建更多的线程来处理（因为io占用了很长时间导致CPU没有使用很久）</li><li>多线程的话会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，但方便的同时会造成变量值的混乱，所以要通过线程锁来限制线程的执行</li></ul></li><li><p>线程安全队列的设计</p></li><li><p>io密集型和计算密集型分别适合多线程还是多进程</p></li><li><p>mysql以及java里面的乐观锁和悲观锁</p><ul><li><strong>悲观锁</strong>认为出现并发的概率很大，所以一旦线程拥有了锁就不允许其他线程获取</li><li><strong>乐观锁</strong>相对而言更宽泛，不对数据进行加锁操作，只是在数据提交的时候进行校验来判断是否产生冲突，常使用版本(version)或时间戳(timestamp)来实现，其中，版本最为常用</li><li>乐观锁适用于读多写少的场景，可以省去频繁加锁、释放锁的开销，提高吞吐量</li><li>在写比较多的场景下，乐观锁会因为版本不一致，不断重试更新，产生大量自旋，消耗 CPU，影响性能。这种情况下，适合悲观锁</li></ul></li><li><p>进程的通信方式（由于每个进程资源是独立的（地址空间和数据空间），就要在操作系统层面进行通信，如管道，队列，信号等）</p><ul><li><p>管道：管道是最简单，效率最差的一种通信方式。</p><ul><li>管道本质上就是内核中的一个缓存，当进程创建一个管道后，Linux会返回两个文件描述符，一个是写入端的描述符，一个是输出端的描述符，可以通过这两个描述符往管道写入或者读取数据。如果想要实现两个进程通过管道来通信，则需要让创建管道的进程fork子进程，这样子进程们就拥有了父进程的文件描述符，这样子进程之间也就有了对同一管道的操作。</li><li>缺点：半双工通信，一条管道同时只能一个进程写</li></ul></li><li><p>消息队列：数据会被分为一个一个的数据单元，称为消息体，消息发送方和接收方约定好消息体的数据类型，不像管道是无格式的字节流类型，这样的好处是可以边发送边接收，而不需要等待完整的数据</p><ul><li>缺点：1、数据单元的大小有限，队列中的数据单元数量也有限 2、消息队列通信过程中存在用户态和内核态之间的数据拷贝问题。进程往消息队列写入数据时，会发送用户态拷贝数据到内核态的过程，同理读取数据时会发生从内核态到用户态拷贝数据的过程</li></ul></li><li><p>共享内存：共享内存解决了消息队列存在的内核态和用户态之间数据拷贝的问题</p><ul><li>现代操作系统对于内存管理采用的是虚拟内存技术，也就是说每个进程都有自己的虚拟内存空间，虚拟内存映射到真实的物理内存。共享内存的机制就是，不同的进程拿出一块虚拟内存空间，映射到相同的物理内存空间。这样一个进程写入的东西，另一个进程马上就能够看到，不需要进行拷贝</li></ul></li><li><p>信号量：实际上是通过对信号量PV的限定来制约对共享内存的读写限制</p></li><li><p>信号：系统提供的信号用于响应各种事件可以通过kill -l命令查看，例如如下操作</p><ul><li>如果是运行在shell终端的进程，可以通过键盘组合键来给进程发送信号，例如使用Ctrl+C产生SIGINT信号，表示终止进程。</li><li>如果是运行在后台的进程，可以通过命令来给进程发送信号，例如使用kill -9 PID产生SIGKILL信号，表示立即结束进程</li></ul></li><li><p>Socket：跨网络与不同的主机进行通信，也可以用于本机通信，Socket是操作系统提供给程序员操作网络的接口，根据底层不同的实现方式，通信方式也不同，存在TCP的Socket通信和UDP的Sock通信</p><ul><li><p>TCP<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230108120131773.png" alt="image-20221118161635079"></p></li><li><p>UDP</p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184605349.png" alt="image-20221118161659369"></p></li></ul></li></ul></li><li><p>TLB</p></li><li><p>进程切换，会刷新TLB吗</p></li><li><p>多核CPU里面，多个线程对缓存的数据操作，会出现什么问题？怎么解决？怎么保证数据的一致性</p></li><li><p>CAS是从乐观的角度出发，尝试用新值更新内存值，更新时会判断内存值是否被别人修改过，如果没有则直接更新。如果被修改过，则重新获取最新值再继续尝试更新，直到更新成功为止，所以CAS方式也称自旋锁</p><ul><li><a href="https://blog.csdn.net/user2025/article/details/109274018">CAS锁机制（无锁、自旋锁、乐观锁、轻量级锁）_</a></li></ul></li><li><p>synchronized跟Lock的区别</p></li><li><p>current包下的其他类</p></li><li><p>线程同步的方式</p></li><li><p>数据的线程安全了解吗？什么是线程安全问题？怎么解决</p></li><li><p>volatile修饰的变量在多个线程同时执行自增操作会发生什么？怎么解决</p><ul><li><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)</a></li><li>volatile保证了可见性和有序性，其原理如下分析<ul><li><p><strong>字节码层面</strong></p><ul><li><p>使用<strong>ACC_VOLATILE</strong>标识，使得后续操作通过判断该标识符来进行操作</p></li><li><p>具体代码如下，看得出其不能保证原子性，因为在读取和写入两个操作之间并不是原子性的</p><ul><li><p>getfield 获取原始值</p></li><li><p>iconst_1 将值入栈</p></li><li><p>iadd 进行加 1 操作</p></li><li><p>putfield 把 iadd 后的操作写回主内存</p></li></ul></li></ul></li><li><p><strong>JVM层面：</strong></p><ul><li>基于内存屏障（或者说是在JMM的层面上）<ul><li><p>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</p></li><li><p>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量</p></li></ul></li></ul></li><li><p><strong>汇编层面：</strong></p><ul><li>Load屏障，是x86上的”ifence“指令，在其他指令前插入ifence指令，<strong>可以让高速缓存中的数据失效，强制当前线程从主内存里面加载数据</strong></li><li>Store屏障，是x86的”sfence“指令，在其他指令后插入sfence指令，<strong>能让当前线程写入高速缓存中的最新数据，写入主内存，让其他线程可见。</strong></li><li>使用lock指令<ul><li>lock前缀，会保证某个处理器对共享内存（一般是缓存行cacheline）的独占使用（MESI协议）。它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。通过独占内存、使其他处理器缓存失效，达到了“指令重排序无法越过内存屏障”的作用，即在每次更改volatile变量的指令前面都添加lock指令，<strong>使得将当前处理器缓存行的数据写回到系统内存并且这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</strong></li></ul></li></ul></li><li><p><strong>特性总结</strong></p><ul><li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</li><li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</li><li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li><li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</li><li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li><li>volatile可以使得long和double的赋值是原子的。</li><li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li></ul></li></ul></li></ul></li><li><p>ThreadLocal发生内存泄漏的原因，线程结束之后是怎么样的</p></li><li><p>进程线程、协程区别（我很详细的说了，从os的底层实现到go的gmp模型）</p></li><li><p>线程池相关</p><ul><li><p>参数</p></li><li><p>执行过程</p></li><li><p>工作流程</p></li><li><p>拒绝策略<a href="https://blog.csdn.net/alan_liuyue/article/details/120995601">(51条消息) 线程池-四种拒绝策略总结_尘光掠影的博客-CSDN博客_线程池拒绝策略</a></p><ul><li><strong>AbortPolicy</strong> - 抛出异常，中止任务。抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行</li><li><strong>CallerRunsPolicy</strong> - 使用调用线程执行任务。当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><strong>DiscardPolicy</strong> - 直接丢弃，其他啥都没有，只是单纯抛弃任务并没有抛出异常的效果</li><li><strong>DiscardOldestPolicy</strong> - 丢弃队列最老任务，添加新任务。当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li></ul></li><li><p><strong>场景</strong>：四种拒绝策略都是有损的，如何优化。</p></li><li><p>i++和++i哪个线程不安全，为什么（深入再考虑一下静态变量的情况，静态变量到变量表的赋值过程，经操作证明对于静态变量而言，两者都是线程不安全的）</p></li><li><p>都是线程不安全的，两者本质在于先将在局部变量表中的读取和加载到操作数栈上的顺序</p></li><li><p>i++情况</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164514248.png" alt="image-20221118164514248"></li></ul></li><li><p>++i情况</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221117183934578.png" alt="image-20221118164538597"></li></ul></li></ul></li><li><p>线程的生命周期</p><ul><li><a href="https://www.cnblogs.com/lingstar/p/16529674.html">线程的生命周期 - 星余明 - 博客园 (cnblogs.com)</a></li><li>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120175358122.png" alt="image-20230108120131773"></li></ul></li><li><p>线性一致性是什么</p></li></ul><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul><li>并发和并行的区别<ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li></ul></li><li>汇编文件的lock前缀，内存屏障，MESI设计，MESI与volatile的关系，MESI优化队列，总线锁与缓存锁，总线风暴</li></ul><h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><ul><li><p>数据库的四种隔离级别</p></li><li><p>索引</p><ul><li><p>聚集索引</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184621739.png" alt="image-20221124184605349"></li></ul></li><li><p>非聚集索引</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163119964.png" alt="image-20221124184621739"></li></ul></li></ul></li><li><p>事务</p></li><li><p>锁</p></li><li><p>字符集相关</p><ul><li>mysql, mysqladmin, mysqlcheck, mysqlimport, and mysqlshow 这些客户端工具都有一个默认的字符集，MySQL 5.7 是 latin1 ，MySQL 8.0为 utf8mb4 ；</li><li>每个客户端工具都会检测操作系统的字符集，比如Linux系统LANG环境变量的值，如果MySQL支持操作系统的字符集，就会使用操作系统的（这里支持包括不完全精确匹配时，OS字符集将映射到最接近的MySQL字符集）；如果不支持，就使用客户端默认字符集</li><li>Latin1是<a href="https://baike.baidu.com/item/ISO-8859-1?fromModule=lemma_inlink">ISO-8859-1</a>的别名，有些环境下写作Latin-1。ISO-8859-1编码是单<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318?fromModule=lemma_inlink">字节</a>编码，向下兼容<a href="https://baike.baidu.com/item/ASCII?fromModule=lemma_inlink">ASCII</a>，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>，0xA0-0xFF之间是文字符号</li></ul></li><li><p>联合索引，最左匹配法则</p><ul><li><a href="https://blog.csdn.net/sinat_41917109/article/details/88944290?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&utm_relevant_index=2">Mysql最左匹配原则_Summersadness8的博客-CSDN博客</a></li><li><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li></ul></li><li><p>更新 MySQL 时失败如何处理</p></li><li><p>模糊查询索引失效的情况</p></li><li><p>什么情况下索引会失效</p></li><li><p>索引缺点？？</p></li><li><p>模糊查询用%哪种情况会失效</p></li><li><p>inner join、left join、right join</p></li><li><p>怎么避免笛卡尔积，判断条件用哪个关键字</p></li><li><p>SQL优化</p></li><li><p>最左前缀</p></li><li><p>如何设计表</p></li><li><p>行锁和表锁是什么？行锁怎么实现的？</p></li><li><p>SQL的执行计划了解吗？（SQL执行顺序？哦哦是explain）</p></li><li><p>mysql的读写锁了解吗？（一时间没反应过来，直到面试官说共享排他才想起来）什么时候会触发排它锁</p></li><li><p>mysqldump导出sql文件和Navicat导出SQL文件的区别</p><ul><li>mysqldump导出的sql文件中会把尽可能多的数据放到一条“insert”语句中，而navicat导出的sql文件每条“insert”语句只对应一条数据，mysqldump导出的sql文件效率更高</li></ul></li><li><p>MySQL的索引为什么不设计成Hash？</p><ul><li>根本原因在于hash本身只能适用于等值运算和重复数据的影响<ul><li>Hash 索引仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</li><li>Hash 索引无法进行数据的排序操作</li><li>Hash 索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用</li><li>Hash 索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果</li><li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</li></ul></li></ul></li><li><p>安全等于可以用来判断null ， <code>&lt;=&gt;</code> 可以用来对 NULL 进行判断，两者都为 NULL 时返回值为 1</p></li><li><p><strong>orm框架相关</strong></p><ul><li><strong>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</strong>。<a href="https://so.csdn.net/so/search?q=ORM%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">ORM框架</a>是连接数据库的桥梁，只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。</li><li>当我们实现一个应用程序时（不使用O&#x2F;R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存、删除、读取对象信息，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射</li></ul></li></ul><h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><ul><li><p>grpc</p><ul><li><a href="https://blog.csdn.net/kevin_tech/article/details/120681720">什么是 gRPC </a></li></ul></li><li><p>分布式的两阶段和三阶段（分布式事务）</p><ul><li><a href="https://segmentfault.com/a/1190000022248118">分布式 - 共识、线性一致性与顺序一致性_个人文章 - SegmentFault 思否</a></li><li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理 | 酷 壳 - CoolShell</a></li><li><a href="https://time.geekbang.org/column/article/321346">13 | 全局事务和共享事务是如何实现的？ (geekbang.org)</a></li></ul></li><li><p>一致性描述</p><ul><li>CAP理论：以下三点不可能同时完全达到</li><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition Tolerance）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123162644337.png" alt="image-20221120175358122"></li></ul></li><li><p>一致性的分析</p><ul><li>弱一致性（最终一致性，不保证实时性但是最终一致）：DNS(域名系统),Gossip</li><li>强一致性：同步，Paxos，Raft，ZAB</li></ul></li><li><p>分布式系统对于fault tolorence 的一般解决方案在于state machine replication，而以下的一致性算法实际上就是为了讨论在replication的过程中的共识算法，即这些算法实际上应该称之为<strong>状态机复制的共识算法</strong></p></li><li><p>分布式系统的一致性算法（共识算法）</p><ul><li>Paxos</li><li>Raft（multi-paxos）以下算法都被认为是与 Multi Paxos 的等价派生实现</li><li>ZAB（multi-paxos）</li></ul></li><li><p>base-paxos算法的过程</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163157233.png" alt="image-20221123162644337"></li></ul></li><li><p>base-paxos算法的常见情景</p><ul><li>正常情况</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163247552.png" alt="image-20221123163119964"></li><li>单节点宕机情况</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161635079.png" alt="image-20221123163157233"></li><li>proposer提案期间失败（会有新的Proposer来接替工作）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164415140.png" alt="image-20221123163247552"></li><li>错误情况：活锁（进行争抢提案，导致无效竞争，可以使用随机计时器避免争抢）</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164115232.png" alt="image-20221123163400102"></li></ul></li><li><p>base-paxos算法的问题</p><ul><li>实现复杂：角色组成多，实现起来复杂</li><li>效率低：调用两轮RPC操作</li><li>存在活锁问题</li></ul></li><li><p>Multi-paxos算法</p><ul><li>简化两轮RPC操作，通过一轮RPC实现</li><li>无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125161407202.png" alt="image-20221123164115232"></li><li>简化调用过程中的角色为两个</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163400102.png" alt="image-20221123164415140"></li></ul></li><li><p>Raft算法</p><ul><li><p>将问题简化为三个子问题</p><ul><li>leader election</li><li>log replication</li><li>safety</li></ul></li><li><p>重新定义角色</p><ul><li>leader</li><li>follower</li><li>candidate</li></ul></li></ul></li><li><p>分布式锁的实现方案</p><ul><li><p>Java中的锁主要包括synchronized锁和JUC包中的锁，这些锁都是针对单个JVM实例上的锁，对于分布式环境如果我们需要加锁就显得无能为力。</p><p>在单个JVM实例上，锁的竞争者通常是一些不同的线程，而在分布式环境中，锁的竞争者通常是一些不同的线程或者进程。如何实现在分布式环境中对一个对象进行加锁呢？答案就是分布式锁。</p><h3 id="分布式锁实现方案"><a href="#分布式锁实现方案" class="headerlink" title="分布式锁实现方案"></a>分布式锁实现方案</h3><p>目前分布式锁的实现方案主要包括三种：</p><ol><li>基于数据库（唯一索引）</li><li>基于缓存（Redis，memcached，tair）</li><li>基于Zookeeper</li></ol><p>基于数据库实现分布式锁主要是利用数据库的唯一索引来实现，唯一索引天然具有排他性，这刚好符合我们对锁的要求：同一时刻只能允许一个竞争者获取锁。加锁时我们在数据库中插入一条锁记录，利用业务id进行防重。当第一个竞争者加锁成功后，第二个竞争者再来加锁就会抛出唯一索引冲突，如果抛出这个异常，我们就判定当前竞争者加锁失败。</p><p>防重业务id需要我们自己来定义，例如我们的锁对象是一个方法，则我们的业务防重id就是这个方法的名字，如果锁定的对象是一个类，则业务防重id就是这个类名。</p><ul><li>基于缓存实现分布式锁：理论上来说使用缓存来实现分布式锁的效率最高，加锁速度最快，因为Redis几乎都是纯内存操作，而基于数据库的方案和基于Zookeeper的方案都会涉及到磁盘文件IO，效率相对低下。一般使用Redis来实现分布式锁都是利用Redis的SETNX key value这个命令，只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。</li><li>基于Zookeeper：Zookeeper一般用作配置中心，其实现分布式锁的原理和Redis类似，我们在Zookeeper中创建瞬时节点，利用节点不能重复创建的特性来保证排他性。</li></ul><p>在实现分布式锁的时候我们需要考虑一些问题，例如：分布式锁是否可重入，分布式锁的释放时机，分布式锁服务端是否有单点问题等。</p><h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><p>上面已经分析了基于数据库实现分布式锁的基本原理：通过唯一索引保持排他性，加锁时插入一条记录，解锁是删除这条记录。下面我们就简要实现一下基于数据库的分布式锁。</p><h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`distributed_lock`</span> (  <br>  <span class="hljs-symbol">`id`</span> bigint(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <br>  <span class="hljs-symbol">`unique_mutex`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;业务防重id&#x27;</span>,  <br>  <span class="hljs-symbol">`holder_id`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;锁持有者id&#x27;</span>,  <br>  <span class="hljs-symbol">`create_time`</span> datetime DEFAULT <span class="hljs-literal">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CURRENT_TIMESTAMP,  <br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),  <br>  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`mutex_index`</span> (<span class="hljs-symbol">`unique_mutex`</span>)  <br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;  <br></code></pre></td></tr></table></figure><p>id字段是数据库的自增id，unique_mutex字段就是我们的防重id，也就是加锁的对象，此对象唯一。在这张表上我们加了一个唯一索引，保证unique_mutex唯一性。holder_id代表竞争到锁的持有者id。</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> distributed_lock(unique_mutex, holder_id) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;unique_mutex&#x27;</span>, <span class="hljs-string">&#x27;holder_id&#x27;</span>);  <br></code></pre></td></tr></table></figure><p>如果当前sql执行成功代表加锁成功，如果抛出唯一索引异常(DuplicatedKeyException)则代表加锁失败，当前锁已经被其他竞争者获取。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">deletesql <span class="hljs-keyword">from</span> methodLock where <span class="hljs-attribute">unique_mutex</span>=<span class="hljs-string">&#x27;unique_mutex&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">holder_id</span>=<span class="hljs-string">&#x27;holder_id&#x27;</span>;  <br></code></pre></td></tr></table></figure><p>解锁很简单，直接删除此条记录即可。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：就以上的方案来说，我们实现的分布式锁是不可重入的，即是是同一个竞争者，在获取锁后未释放锁之前再来加锁，一样会加锁失败，因此是不可重入的。解决不可重入问题也很简单：加锁时判断记录中是否存在unique_mutex的记录，如果存在且holder_id和当前竞争者id相同，则加锁成功。这样就可以解决不可重入问题。</p><p><strong>锁释放时机</strong>：设想如果一个竞争者获取锁时候，进程挂了，此时distributed_lock表中的这条记录就会一直存在，其他竞争者无法加锁。为了解决这个问题，每次加锁之前我们先判断已经存在的记录的创建时间和当前系统时间之间的差是否已经超过超时时间，如果已经超过则先删除这条记录，再插入新的记录。另外在解锁时，必须是锁的持有者来解锁，其他竞争者无法解锁。这点可以通过holder_id字段来判定。</p><p><strong>数据库单点问题</strong>：单个数据库容易产生单点问题：如果数据库挂了，我们的锁服务就挂了。对于这个问题，可以考虑实现数据库的高可用方案，例如MySQL的MHA高可用解决方案。</p><h3 id="基于缓存实现分布式锁，以Redis为例"><a href="#基于缓存实现分布式锁，以Redis为例" class="headerlink" title="基于缓存实现分布式锁，以Redis为例"></a>基于缓存实现分布式锁，以Redis为例</h3><p>使用Jedis来和Redis通信。</p><h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_IF_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NX&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_WITH_EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PX&quot;</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 加锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁的key  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 竞争者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 锁超时时间，超时之后锁自动释放  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);  <br>    &#125;  <br>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">jedis.<span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> value, <span class="hljs-built_in">String</span> nxxx, <span class="hljs-built_in">String</span> expx, <span class="hljs-built_in">int</span> time);  <br></code></pre></td></tr></table></figure><p>这个set()方法一共五个形参：</p><ul><li>第一个为key,我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，这里写的是锁竞争者的id，在解锁时，我们需要判断当前解锁的竞争者id是否为锁持有者。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期时间的设置，具体时间由第五个参数决定；</li><li>第五个参数为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：1.当前没有锁（key不存在）,那么久进行加锁操作，并对锁设置一个有效期，同时value表示加锁的客户端。2.已经有锁存在，不做任何操作。</p><p>上述解锁请求中，SET_IF_NOT_EXIST(不存在则执行)保证了加锁请求的排他性，缓存超时机制保证了即使一个竞争者加锁之后挂了，也不会产生死锁问题：超时之后其他竞争者依然可以获取锁。通过设置value为竞争者的id，保证了只有锁的持有者才能来解锁，否则任何竞争者都能解锁，那岂不是乱套了。</p><h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Long</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span> = 1L;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 释放分布式锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 锁持有者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否释放成功  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span>(<span class="hljs-params">Jedis jedis, <span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId</span>) &#123;  <br>        <span class="hljs-title class_">String</span> script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;  <br>        <span class="hljs-title class_">Object</span> result = jedis.<span class="hljs-built_in">eval</span>(script, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(lockKey), <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(requestId));  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span>.<span class="hljs-title function_">equals</span>(result);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>解锁的步骤：</p><ol><li>判断当前解锁的竞争者id是否为锁的持有者，如果不是直接返回失败，如果是则进入第2步。</li><li>删除key，如果删除成功，返回解锁成功，否则解锁失败。</li></ol><p>注意到这里解锁其实是分为2个步骤，涉及到解锁操作的一个原子性操作问题。这也是为什么我们解锁的时候用Lua脚本来实现，因为Lua脚本可以保证操作的原子性。那么这里为什么需要保证这两个步骤的操作是原子操作呢？</p><p>设想：假设当前锁的持有者是竞争者1，竞争者1来解锁，成功执行第1步，判断自己就是锁持有者，这是还未执行第2步。这是锁过期了，然后竞争者2对这个key进行了加锁。加锁完成后，竞争者1又来执行第2步，此时错误产生了：竞争者1解锁了不属于自己持有的锁。可能会有人问为什么竞争者1执行完第1步之后突然停止了呢？</p><p>这个问题其实很好回答，例如竞争者1所在的JVM发生了GC停顿，导致竞争者1的线程停顿。这样的情况发生的概率很低，但是请记住即使只有万分之一的概率，在线上环境中完全可能发生。因此必须保证这两个步骤的操作是原子操作。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：以上实现的锁是不可重入的，如果需要实现可重入，在SET_IF_NOT_EXIST之后，再判断key对应的value是否为当前竞争者id，如果是返回加锁成功，否则失败。</p><p><strong>锁释放时机</strong>：加锁时我们设置了key的超时，当超时后，如果还未解锁，则自动删除key达到解锁的目的。如果一个竞争者获取锁之后挂了，我们的锁服务最多也就在超时时间的这段时间之内不可用。</p><p><strong>Redis单点问题</strong>：如果需要保证锁服务的高可用，可以对Redis做高可用方案：Redis集群+主从切换。目前都有比较成熟的解决方案。</p><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><h4 id="加锁和解锁流程"><a href="#加锁和解锁流程" class="headerlink" title="加锁和解锁流程"></a>加锁和解锁流程</h4><p>利用Zookeeper创建临时有序节点来实现分布式锁：</p><ol><li>当一个客户端来请求时，在锁的空间下面创建一个临时有序节点。</li><li>如果当前节点的序列是这个空间下面最小的，则代表加锁成功，否则加锁失败，加锁失败后设置Watcher，等待前面节点的通知。</li><li>当前节点监听其前面一个节点，如果前面一个节点删除了就通知当前节点。</li><li>当解锁时当前节点通知其后继节点，并删除当前节点。</li></ol><p>其基本思想类似于AQS中的等待队列，将请求排队处理。其流程图如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872108920/9F0FB4B766E3BFAF3E92FEAE0553DFC5" alt="img"></p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><strong>解决不可重入</strong>：客户端加锁时将主机和线程信息写入锁中，下一次再来加锁时直接和序列最小的节点对比，如果相同，则加锁成功，锁重入。</p><p><strong>锁释放时机</strong>：由于我们创建的节点是顺序临时节点，当客户端获取锁成功之后突然session会话断开，ZK会自动删除这个临时节点。</p><p><strong>单点问题</strong>：ZK是集群部署的，主要一半以上的机器存活，就可以保证服务可用性。</p><h4 id="利用curator实现"><a href="#利用curator实现" class="headerlink" title="利用curator实现"></a>利用curator实现</h4><p>Zookeeper第三方客户端curator中已经实现了基于Zookeeper的分布式锁。利用curator加锁和解锁的代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 加锁，支持超时，可重入   public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-function"><span class="hljs-keyword">return</span> interProcessMutex.<span class="hljs-title">acquire</span><span class="hljs-params">(timeout, unit)</span></span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;   <span class="hljs-comment">// 解锁   public boolean unlock() &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        interProcessMutex.release();  <br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;  <br>        log.<span class="hljs-keyword">error</span>(e.getMessage(), e);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        executorService.schedule(<span class="hljs-keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="三种方案比较"><a href="#三种方案比较" class="headerlink" title="三种方案比较"></a>三种方案比较</h3><p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872090690/841D619AD8F9824776994757BB726DFB" alt="img"></p></li></ul></li></ul><h2 id="消息队列相关"><a href="#消息队列相关" class="headerlink" title="消息队列相关"></a>消息队列相关</h2><ul><li><p>一个消息队列服务器推给客户端和客户端主动拉取消息的优缺点</p><ul><li><p>Push方式：</p><ul><li>优点：有消息就推给消费者。延迟小,几乎可以做到实时</li><li>缺点：加大Server端的工作量，进而影响Server的性能，并且Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题，解决方法是 给数据设定一个超时时间，当 Consumer 宕机时间超过这个阈值时，则清理数据；但这个时间阈值也并不太容易确定</li><li>总结：1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点</li><li>适用强调实时性的情况</li></ul></li><li><p>Pull方式：</p><ul><li>优点：消费者可以根据自己能力拉取消息处理</li><li>缺点：Client端循环地从Server端拉取消息，主动权在Client手里，但是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</li><li>总结：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull，为了避免空pull带来的性能损耗，使用<strong>长轮询</strong>的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。基本方式是：消费者如果尝试拉取失败，不是直接 return，而是把连接挂在那里（指挂在服务器端） wait，服务端如果有新的消息到来，把连接拉起，返回最新消息<ul><li>长轮询解释：<a href="https://blog.csdn.net/u013978512/article/details/126186884">( 什么是长轮询_法拉弟弟的博客-CSDN博客</a></li></ul></li><li>适用于消费者处理能力较强的情况，适用于消费者可能处于宕机状态的情况</li></ul></li></ul></li><li><p>mq消息队列的优势</p></li><li><p>RocketMQ 重传机制，上限</p></li><li><p>死信队列</p></li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li><strong>linux epoll底层原理</strong><ul><li>fd 即 文件描述符</li></ul></li><li>Linux文件系统</li><li>Linux中查询内存使用情况语句</li><li>Linux常用语句</li><li>epoll poll select讲讲（从底层linux源码机制到对比我都详细讲了）</li><li>c和z的快捷键区别<ul><li>ctrl+c是强制中断程序的执行,进程已经终止。</li><li>ctrl+z的是将任务中止（暂停的意思）,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg&#x2F;bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.</li></ul></li></ul><h2 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h2><p><a href="https://mp.weixin.qq.com/s/XoqGvYBabW8YBl9xEeNYZw">Nginx详解，睡前十分钟啃完值了！ (qq.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/6844904129987526663">连前端都看得懂的《Nginx 入门指南》 - 掘金 (juejin.cn)</a></p><ul><li>Nginx也使用了IO多路复用的技术来实现高效<ul><li>实际上其本身架构模式就即为Reactor 模式</li></ul></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>操作系统内存分配</li><li>缺页中断</li><li>那些操作会触发进程调度</li><li>进程调度算法</li><li>优先级抢占式调度算法，在都处于同一优先级的多个进程中，其中一个进程运行了太久怎么办？</li><li>什么时候会从用户态陷入内核态，具体细节</li></ul><h2 id="go语言拓展"><a href="#go语言拓展" class="headerlink" title="go语言拓展"></a>go语言拓展</h2><ul><li>gin框架了解</li><li>垃圾回收</li><li>协程实现</li></ul><h2 id="spring框架"><a href="#spring框架" class="headerlink" title="spring框架"></a>spring框架</h2><ul><li><p>springmvc的了解（整体辨析）</p></li><li><p>spring异常处理的实现（统一异常处理实现）</p></li><li><p>spring事务（详解）</p><ul><li>事务传播行为</li><li>事务管理机制：@Transactional<ol><li>原理</li><li>注解的参数</li><li>实现原理</li><li>失效情况</li></ol></li></ul></li><li><p>简单讲讲AOP以及常用注解spring的核心就是AOP，平常有没有用过AOP，尝试实战</p></li><li><p>JPA相关</p></li><li><p>springsecurity</p></li><li><p>Bean的生命周期</p><ul><li>javaguide</li></ul></li><li><p>@Resource与@Autowire的区别</p><ul><li>javaguide</li></ul></li><li><p>Spring中涉及到的设计模式</p><ul><li>javaguide</li></ul></li><li><p>Spring中依赖的注入</p></li><li><p>Spring中Bean的作用范围 </p><ul><li>javaguide</li></ul></li><li><p>Restful风格详解</p><ul><li>总结：将过程的调用名称不写在url中，而是使用GET、POST请求等作为区分</li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485510&idx=1&sn=e9273322ae638c8465a606737109ab97&chksm=cea2478df9d5ce9b58b9ff1f1e2ecca99e961b911adcec3d5a579b41e01151160cfb2891d91b&token=1701499214&lang=zh_CN&scene=21#wechat_redirect">后端开发必备的 RestFul API 知识 (qq.com)</a></li></ul></li><li><p>spring容器概念</p></li></ul><h3 id="JavaGuide部分"><a href="#JavaGuide部分" class="headerlink" title="JavaGuide部分"></a>JavaGuide部分</h3><ul><li>IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)</li><li>springboot和Spring等框架的关系<ul><li>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用</li></ul></li><li></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>红黑树</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>只含加减的计算机</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 存放所有的数字</span><br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将所有的空格去掉</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 存放所有的操作，包括 +/-</span><br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 计算到最近一个左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNum(c)) &#123;<br>                    <span class="hljs-comment">//当遇到数字时并不是只把这个位给加入，而是把所有的数字统计成一个数据加入</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty()) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-comment">//计算并且将计算结果直接放到Deque</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        nums.addLast(op == <span class="hljs-string">&#x27;+&#x27;</span> ? a + b : a - b);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加减乘除版本计算器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;()&#123;&#123;<br>        put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br>    &#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        nums.addLast(<span class="hljs-number">0</span>);<br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">if</span> (ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNumber(c)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="hljs-number">10</span> + (cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//为防止 () 内出现的首个字符为运算符，将所有的空格去掉，</span><br>                    <span class="hljs-comment">//并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</span><br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                        <span class="hljs-comment">//判断优先级位置</span><br>                        <span class="hljs-keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;<br>                            calc(nums, ops);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            ans = a + b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            ans = a - b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            ans = a * b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>            ans = a / b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>            ans = (<span class="hljs-type">int</span>)Math.pow(a, b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>            ans = a % b;<br>        &#125;<br>        nums.addLast(ans);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>手写层次遍历（这里问了我为什么前面用add后面用offer，我说我记得add被弃用了，前面紧张写快了就写成add了，后面想起来改成offer，底层是add直接调用offer）</li><li>平衡二叉树（左旋右旋）</li><li>红黑树相关</li><li>栈和队列的使用场景</li><li>反转字符串！</li><li>堆排序稳定吗（这个忘记了，现推说不稳定）</li><li>（排序总结）</li><li>写一个解析csv文件的类（写了40分钟，面试官说超时了。主要是我java好几个api忘了，一般我都是查文档，可是面试不能查，只能一个个试了😢）</li></ul><h2 id="项目场景"><a href="#项目场景" class="headerlink" title="项目场景"></a>项目场景</h2><ul><li>提前思考怎么突出项目中的亮点</li></ul><h2 id="主观问题总结"><a href="#主观问题总结" class="headerlink" title="主观问题总结"></a>主观问题总结</h2><ul><li>挑战性项目</li><li>诱导面试官提问自己熟悉的环节</li></ul><h2 id="细碎知识"><a href="#细碎知识" class="headerlink" title="细碎知识"></a>细碎知识</h2><p><strong>常见配置文件比较</strong></p><ul><li><a href="https://cloud.tencent.com/developer/article/1683160">深入对比TOML，JSON和YAML - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解JAVA虚拟机"><a href="#深入理解JAVA虚拟机" class="headerlink" title="深入理解JAVA虚拟机"></a>深入理解JAVA虚拟机</h1><h2 id="第二章：java内存区域和内存溢出异常"><a href="#第二章：java内存区域和内存溢出异常" class="headerlink" title="第二章：java内存区域和内存溢出异常"></a>第二章：java内存区域和内存溢出异常</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221119222233318.png" alt="image-20221119222233318"></p><ul><li><p>程序计数器部分：</p><ul><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域·</li></ul></li><li><p>栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息</p></li><li><p>对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置，不止是指针）</p></li><li><p>局部变量表中还存放了returnAddress类型（指向了一条字节码指令的地址）</p></li><li><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情</p></li><li><p>如果栈支持动态扩展，则当栈扩展无法申请到足够内存则会报错OOM</p></li><li><p>随着逃逸分析技术，栈上分配和标量替换等技术使得对象分配在堆中并不绝对化</p></li><li><p>分代并不是堆的固定“称呼”，只是HotSpot使用的垃圾回收器的流行导致的刻板印象</p></li><li><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存</p></li><li><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来</p></li><li><p>永久代（所谓永久只是因为这部分的垃圾回收不好操作，类卸载也很严格，但的确需要回收）只是HotSpot对于方法区的一种实现，其他虚拟机并没有这个区域，只是为了使得HotSpot的垃圾回收器能够像管理java堆一样管理方法区，由于其本身更容易产生内存溢出的问题，到了java8中将永久代中的类型信息移动到由本地内存实现的元空间中</p></li><li><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p></li><li><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法</p></li><li><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</p></li><li><p>对象的分配方式</p><ul><li>指针碰撞（Bump ThePointer）：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离<ul><li>使用场景：当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效</li></ul></li><li>空闲列表（Free List）：虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录<ul><li>使用场景：用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存</li></ul></li></ul></li><li><p>分配内存可能产生并发（争抢同一块内存）的解决方法：</p><ul><li>对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定</li></ul></li><li><p>内存分配完成后需要对分配好的内存空间（除对象头）全都初始化为0，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来</p></li><li><p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p><ul><li>对象头的组成部分<ul><li>Mark Word ：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特</li><li>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</li><li>（如果这个对象是数组）对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小</li></ul></li></ul></li><li><p>对象的定位方式</p><ul><li>句柄访问</li><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120151423921.png" alt="image-20221120151423921"></li><li>直接指针访问</li><li>优点：使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它<strong>主要使用第二种</strong>方式进行对象访问</li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120151434004.png" alt="image-20221120151434004"></li></ul></li><li><p>Java的线程是映射到操作系统的内核线程上，无限制地创建线程会对操作系统带来很大压力，上述代码执行时有很高的风险，可能会由于创建线程数量过多而导致操作系统假死</p></li><li><p>OOM的不同情况分析</p><ul><li>堆溢出<ul><li>使用内存映像分析工具对堆转储快照进行分析，判断是内存泄漏还是内存溢出，<ul><li>内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置</li><li>内存溢出，检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗</li></ul></li></ul></li><li>java虚拟机栈溢出&#x2F;本地方法栈溢出<ul><li>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常，但是如果运行动态扩展栈的大小则报错OOM</li></ul></li><li>方法区和运行时常量池溢出<ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120153930160.png" alt="image-20221120153930160"></li></ul></li><li>随着Spring框架等动态生成类的大量使用，导致方法区容易溢出，但是随着java8将类数据移动到元空间中，即类导致的内存溢出不容易出现</li></ul></li></ul><h2 id="第三章：垃圾收集器与内存分配策略"><a href="#第三章：垃圾收集器与内存分配策略" class="headerlink" title="第三章：垃圾收集器与内存分配策略"></a>第三章：垃圾收集器与内存分配策略</h2><ul><li><p>一般不考虑线程独占的内存部分的数据回收，因为随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的）</p></li><li><p>引用计数法简单高效但是需要很多额外的工作才能保证其工作正常运行（循环引用）</p></li><li><p>目前广泛使用可达性分析算法，使用GCroots进行判断</p></li><li><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，<strong>如果进行局部回收，某个区域里的对象完全有可能被位于堆中其他区域的对象所引用</strong>，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性</p></li><li><p>常见引用分类</p><ul><li>强引用：永远不回收，传统的引用定义</li><li>软引用：有用但不必须，在即将报错内存溢出时，会把软引用的对象纳入回收范围内进行回收，如果还是不够才报错</li><li>弱引用：只能活到下次垃圾回收前</li><li>虚引用：虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</li></ul></li><li><p>对象回收的完整过程（至少进行两次标记）</p><ul><li>可达性分析GCRoots标记，若其没有相连的引用链则进行第一次标记</li><li>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（这句话的含义在于，如果该对象通过finalize方法逃脱过一次垃圾回收，那么下一次垃圾回收就没办法使用这个逃脱方法了），那么虚拟机将这两种情况都视为“没有必要执行“</li><li>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会<strong>触发</strong>这个方法开始运行，但并不承诺一定会等待它运行结束（如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃）</li><li>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了</li></ul></li><li><p>对于方法区的垃圾回收</p><ul><li>JVM虚拟机规范中甚至不要求对方法区进行垃圾回收事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）（但对于方法区的回收实际上有是有必要的，在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力）</li><li>在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此</li></ul></li><li><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型</p></li><li><p>类卸载的三个前提（之所以是前提是因为就算满足了也不一定回收）</p><ul><li>Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收（很难满足）</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li><li><p>建立分代回收机制（分代本身越来越暴露缺陷）的三个前提假说</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数（实际上是前面两个假说的推论，因为强分代最终会因为引用了弱分代而把它拉到老年代中）</li></ul></li><li><p>跨代引用的解决方法</p><ul><li>我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的</li></ul></li><li><p>垃圾回收分类</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。<strong>目前只有CMS收集器会有单独收集老年代的行为。</strong>另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。<strong>目前只有G1收集器会有这种行为</strong></li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li></ul></li><li><p><strong>垃圾回收算法</strong></p><ul><li><p><strong>标记清除算法</strong></p><ul><li>缺点：<ul><li>第一个是<strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记（标记所有）和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>第二个是<strong>内存空间的碎片化</strong>问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul></li><li><p><strong>标记复制算法</strong>（正如其字面意思：半区复制）</p><ul><li>优点：内存分配简单，只需要在栈顶指针进行移动即可，不会有内存碎片的问题</li><li>缺点：只使用了一半的内存，并且当需要保存的对象很多时，内存复制开销大</li><li>适用场景：新生代的垃圾回收（由于新生代的对象短命，故每次内存复制的开销少）<ul><li>PS：同样的这样的算法显然不适合老年代回收，因为老年代往往大量不会被回收，新生代的那点担保空间完全不足以承担老年代的容量</li></ul></li><li>优化算法：“Appel式回收”<ul><li><strong>HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局</strong>[1]。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</li><li>特殊情况下需要保留的对象超过10%时，因此Appel式回收还有一个充当罕见情况的“<strong>逃生门</strong>”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion），即额外的部分直接进入老年代</li></ul></li></ul></li><li><p><strong>标记整理算法</strong></p><ul><li>缺点：移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，即“Stop The World”</li><li>适用场景：老年代垃圾回收</li><li>优化算法：对于老年代的回收可以通过移动来腾出内存，也可以使用<strong>分区空闲分配链表</strong>来解决内存分配问题，但是两者各有利弊移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是<strong>赋值器与收集器</strong>的效率总和。即使不移动对象会使得收集器的效率提升一些，但因<strong>内存分配和访问相比垃圾收集频率要高得多</strong>，这部分的耗时增加，<strong>总吞吐量仍然是下降的</strong>。HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的<ul><li>另外，还有一种<strong>“和稀泥式”</strong>解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机<strong>平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在</strong>，直到内存空间的碎片化程度已经大到影响对象分配时，<strong>再采用标记-整理算法收集一次，以获得规整的内存空间</strong>。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法</li></ul></li></ul></li><li><p>根结点枚举的难处：Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检</p><p>查以这里为起源的引用肯定得消耗不少时间</p></li><li><p>枚举根结点是一定要STW的，即使是所谓的并发分析也只是在一个具有一致性（枚举期间引用关系不能改变）的快照中进行的</p></li><li><p>虚拟机中并不是完全从GCroot开始分析的，虚拟机中有OopMap的数据结构用于存放对象引用</p></li><li><p>安全点：</p><ul><li>HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）</li><li>用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点</li><li>确保每个线程都达到安全的方式<ul><li>抢先式中断（Preemptive Suspension）抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。<strong>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件</strong></li><li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。<strong>轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</strong></li></ul></li><li>HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的test指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了</li><li>安全区域：<ul><li>用户线程处于Sleep状态或者Blocked状态由于没有时间片，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</li><li>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。<strong>我们也可以把安全区域看作被扩展拉伸了的安全点</strong></li><li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止</li></ul></li></ul></li></ul></li><li><p>TODO：记忆表卡表到垃圾回收器期间</p></li><li><p>java垃圾回收中<strong>并发和并行</strong>的定义</p><ul><li>并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li><li>并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响</li></ul></li><li><p>经典垃圾回收器</p><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221121165159996.png" alt="image-20221121165159996"></li><li><strong>Serial 垃圾回收器</strong><ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221121165405966.png" alt="image-20221121165405966"></li><li>优点：HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是<strong>简单而高效</strong>（与其他收集器的单线程相比）<ul><li><strong>物理机内存受限的情况：</strong>对于内存资源受限的环境，它是所有收集器里<strong>额外内存消耗（Memory Footprint）最小的</strong>；</li><li><strong>单核处理器情况：</strong>对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于<strong>没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</strong></li><li><strong>应用本身占用空间少的情况：</strong>在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的</li></ul></li></ul></li><li><strong>ParNew收集器</strong><ul><li>实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码</li><li>优点：不少运行在服务端模式下的HotSpot虚拟机<ul><li>除了Serial收集器外，目前只有它能与CMS收集器配合工作</li><li>当处理器多核并且开启了很多线程时比Serial收集器效果更好</li></ul></li><li>缺点：ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍）的环境中</li></ul></li><li><strong>Parallel Scavenge收集器：</strong>也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，Parallel Scavenge的诸多特性从表面上看和ParNew非常相似<ul><li>特点：Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</li><li>适用场景：停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务</li><li>调节参数：Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，<ul><li>控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数</li><li>直接设置吞吐量大小的-XX：GCTimeRatio参数</li><li>自动优化参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）</li></ul></li><li>和ParNew的区分：<ul><li>Parallel Scavenge注重吞吐量而非相应时间</li><li>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</li></ul></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123193014729.png" alt="image-20221126173040784"></p><ul><li><p><strong>Serial Old收集器：</strong>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法(特征类似Serial )</p><ul><li>适用场景：<ul><li>供客户端模式下的HotSpot虚拟机使用</li><li>在服务端情况下作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul></li></ul></li><li><p><strong>Parallel Old收集器：</strong>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现</p><ul><li>适用场景：<strong>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</strong></li></ul></li><li><p><strong>CMS（Concurrent Mark Sweep）收集器：</strong>是一种以获取最短回收停顿时间为目标的收集器</p><ul><li>适用场景：互联网网站或者基于浏览器的B&#x2F;S系统的服务端上（关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验）</li><li>使用步骤<ul><li>初始标记（CMS initial mark）  “<strong>Stop The World”</strong><ul><li>只是标记一下GCRoots能直接关联到的对象，速度很快</li></ul></li><li>并发标记（CMS concurrent mark）<ul><li>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li></ul></li><li>重新标记（CMS remark）        <strong>“Stop The World”</strong><ul><li>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li></ul></li><li>并发清除（CMS concurrent sweep）<ul><li>清理删除掉标记阶段判断的已经死亡的对象，由于<strong>不需要移动存活对象</strong>，所以这个阶段也是可以与用户线程同时并发的</li></ul></li><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123202904830.png" alt="image-20221123202904830"></li></ul></li><li>优点：<ul><li>并发收集、低停顿</li></ul></li><li>缺点：<ul><li><strong>CMS收集器对处理器资源非常敏感</strong>（配置要求高）。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。<strong>如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低</strong>。为了缓解这种情况，虚拟机提供了一种称为“增量式并发收集器”在并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK 7开始，i-CMS模式已经被声明为“deprecated”，即已过时不再提倡用户使用，<strong>到JDK 9发布后i-CMS模式被完全废弃</strong></li><li><strong>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生</strong>。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。<strong>同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。</strong>但这又会更容易面临另一种风险：要是CMS运行期间<strong>预留的内存无法满足程序分配新对象的需要</strong>，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，<strong>临时启用Serial Old收集器</strong>来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置</li><li><strong>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦</strong>，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）</li></ul></li></ul></li><li><p><strong>Garbage First（简称G1）收集器：</strong></p><ul><li><p>G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器</p></li><li><p>作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”（PausePrediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java（RTSJ）的中软实时垃圾收集器特征了</p></li><li><p>特点：</p><ul><li>以面向堆内存任何部分来组成<strong>回收集（Collection Set，一般简称CSet）</strong>进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</li><li><strong>G1开创的基于Region的堆内存布局是它能够面向堆内存任何部分回收的关键，</strong>把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果</li><li><strong>Region中还有一类特殊的Humongous区域，专门用来存储大对象</strong>。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li><li><strong>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，</strong>它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它<strong>将Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍，这样可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。更具体的处理思路是让<strong>G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小</strong>，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率</li><li>并非纯粹地追求低延迟，官方给它设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>（即更多的去追求回收速率而不是追求回收百分比，只要能够满足内存分配的速度即可）</li><li><strong>可以由用户指定期望的停顿时间是G1收集器很强大的一个功能</strong>，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为两百毫秒，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的</li></ul></li><li><p><strong>实现过程中解决问题的方式：</strong></p><ul><li>将Java堆分成多个独立Region后，Region里面存在的<strong>跨Region引用对象如何解决？</strong>解决的思路我们已经知道：使用记忆集避免全堆作为GC Roots扫描，但在<strong>G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针</strong>，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有更高的内存占用负担。根据经验，<strong>G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</strong></li><li><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong>这里首先要解决的是用户线程改变对象引用关系时，须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过（见3.4.6节）：<strong>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。</strong>此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，<strong>把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围</strong>。<strong>与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”</strong></li><li><strong>怎样建立起可靠的停顿预测模型？</strong>用户通过-XX：MaxGCPauseMillis参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但G1收集器要怎么做才能满足用户的期望呢？<strong>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息</strong>。这里<strong>强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值</strong>。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益</li></ul></li><li><p>执行过程的分析（如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤）：</p><ul><li><strong>初始标记（Initial Marking）：</strong>  “<strong>Stop The World”</strong><ul><li>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li></ul></li><li><strong>并发标记（Concurrent Marking）：</strong>    <ul><li>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。</li></ul></li><li><strong>最终标记（Final Marking）：</strong>    “<strong>Stop The World”</strong><ul><li>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li></ul></li><li><strong>筛选回收（Live Data Counting and Evacuation）： **    “</strong>Stop The World”**<ul><li>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作<strong>涉及存活对象的移动，是必须暂停用户线程</strong>，由多条收集器线程并行完成的。（CMS基于标记清除，不需要移动对象，自然不用STW）</li><li>PS：回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，<strong>停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案</strong></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126173040784.png" alt="image-20221201173858863"></p></li><li><p><strong>CMS垃圾回收器和G1垃圾回收器比较</strong></p><ul><li><strong>G1 的优点：****相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力</strong>与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li><li><strong>CMS的优点：</strong>虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的</li><li><strong>在执行负载的角度上</strong>，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同，譬如它们都使用到写屏障，<strong>CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障</strong>来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。</li><li><strong>总结：在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</strong></li></ul></li></ul></li></ul></li><li><p>TODO （剩余部分省略）</p></li></ul><h2 id="第六章：类文件结构"><a href="#第六章：类文件结构" class="headerlink" title="第六章：类文件结构"></a>第六章：类文件结构</h2><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221201173858863.png" alt="image-20221123193014729"></p><ul><li><p>class文件由两部分组成：无符号数和表（更准确的说，class文件的一部分即为常量池，而常量池中的所有数据项都可以看做是“_info”结尾的表，而这些表又由其他表或者基本数据类型所组成）</p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成</li></ul></li><li><p>由于class文件没有任何分割符，所以必须保证其长度的确定性</p></li><li><p>UTF-8缩略编码与普通UTF-8编码的区别是：（尽可能的省）</p><ul><li>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示</li></ul></li><li><p>类文件中的数据指向可以看做是连环嵌套的格式，比如下图类索引指向常量池中的类info，而类info中的字面量又指向utf8_info</p></li><li><p>相比于全限定名和简单名称，方法和字段的描述符就要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p><ul><li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录成“[I”。</li><li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava&#x2F;lang&#x2F;String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”</li></ul></li><li><p>方法表中本身没有code，其具体代码存放在方法属性表中</p><ul><li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在下一节中详细讲解。</li></ul></li><li><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p></li><li><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性</p></li></ul><h2 id="第十章：前端编译和优化（TODO学完编译原理后学习）"><a href="#第十章：前端编译和优化（TODO学完编译原理后学习）" class="headerlink" title="第十章：前端编译和优化（TODO学完编译原理后学习）"></a>第十章：前端编译和优化（TODO学完编译原理后学习）</h2><ul><li><strong>java中的编译的”多种解释”</strong><ul><li>前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；<ul><li>JDK的Javac（C++语言（包含少量C语言））、Eclipse JDT中的增量式编译器（ECJ）</li></ul></li><li>Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；<ul><li>HotSpot虚拟机的C1、C2编译器，Graal编译器</li></ul></li><li>使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程<ul><li>JDK的Jaotc、GNU Compiler for the Java（GCJ）[2]、Excelsior JET</li></ul></li></ul></li><li>前端编译实际上在后期的优化是微乎其微的，选择把对性能的优化全部集中到运行期的即时编译器中，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化措施所带来的性能红利</li><li><strong>java采用解释器和编译器并行的结构</strong><ul><li>解释器优点：<ul><li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行（编译器要想获取优化程度更好的代码自然要编译更长的时间）</li><li>内存角度：当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在）</li></ul></li><li>编译器优点<ul><li>随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</li><li>内存角度：如果内存相对充裕，可以使用编译执行来提升效率</li></ul></li><li>解释器作为编译器的逃生门（编译器做错事的后备选择）<ul><li>解释器还可以作为<strong>编译器激进优化时后备的“逃生门”</strong>（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如图11-1所示。</li></ul></li></ul></li></ul><h2 id="第十一章：后端编译和优化"><a href="#第十一章：后端编译和优化" class="headerlink" title="第十一章：后端编译和优化"></a>第十一章：后端编译和优化</h2><ul><li><p>即时编译器编译热点代码</p><ul><li>当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化</li></ul></li><li><p><strong>即时编译器分类</strong></p><ul><li>C1编译器——“客户端编译器”（Client Compiler）</li><li>C2编译器——“服务端编译器”（Server Compiler）</li><li>Graal编译器（JDK 10出现，目的用于替代C2编译器，Graal编译器目前还处于实验状态）</li></ul></li><li><p>java虚拟机默认情况都是编译器和解释器一同工作</p><ul><li>“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式（决定使用C1还是C2）</li><li>“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时候编译器完全不介入工作，全部代码都使用解释方式执行</li><li>“-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode），这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程</li></ul></li><li><p><strong>分层编译</strong></p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）</li><li>第1层。使用（C1）客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li><li>不同情况下的分层编译</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125203607563.png" alt="image-20221128104046824"></p></li><li><p>分层编译的好处</p><ul><li>实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间</li></ul></li><li><p>热点代码主要为：<strong>多次调用的方法，多次执行的循环体</strong></p><ul><li>对于这两种情况，<strong>编译的目标对象都是整个方法体，而不会是单独的循环体</strong>。第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为<strong>“栈上替换”（On Stack Replacement，OSR）</strong>，即方法的栈帧还在栈上，方法就被替换了</li></ul></li><li><p>热点探测判定：（两者在虚拟机的不同实现中都有应用）</p><ul><li><p>基于采样的热点探测（Sample Based Hot Spot Code Detection）</p><ul><li>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是<strong>很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li></ul></li><li><p>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</p><ul><li><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器</strong>，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li><li>方法调用计数器（Invocation Counter）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125203205479.png" alt="image-20221128144957798"></p><ul><li>回边计数器（Back Edge Counter“回边”的意思就是指在循环边界往回跳转）<ul><li><strong>在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，很显然建立回边计数器统计的目的是为了触发栈上的替换编译</strong></li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128104046824.png" alt="image-20221128145018987"></p><ul><li><strong>当一个方法被调用时</strong>，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求</li><li><strong>当解释器遇到一条回边指令时</strong>，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</li><li>（程序是并行执行的而并不是傻傻的等着编译器）如果没有做过任何设置，执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了</li></ul></li><li><p>计数的衰减</p><ul><li>方法调用计数器：统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的</li><li>回边计数器：与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程</li></ul></li></ul></li><li><p><strong>编译过程</strong>（TODO 11.2.3）</p></li><li><p><strong>提前编译</strong></p><ul><li>现在提前编译产品和对其的研究有着两条明显的分支，<ul><li><strong>传统静态</strong>：一条分支是做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作；<ul><li>这是传统的提前编译应用形式，它在Java中存在的价值直指即时编译的最大弱点：<strong>即时编译要占用程序运行时间和运算资源</strong>，而提前编译由于提前性，所以可以使用大量的时间来进行优化</li></ul></li><li><strong>动态缓存</strong>：另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用<ul><li>本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。这种提前编译被称为动态提前编译（DynamicAOT）或者索性就大大方方地直接叫即时编译缓存（JIT Caching）</li><li>动态缓存存在的<strong>弊端</strong>为：提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定，以及其为了提高本身的兼容性，无法做一些激进的优化操作</li></ul></li></ul></li><li>由于提前编译可以有重负荷的编译过程优势，但是<strong>JIT依旧尤其独特的优势</strong><ul><li><strong>性能分析制导优化（Profile-Guided Optimization，PGO）</strong>上一节介绍HotSpot的即时编译器时就多次提及在解释器或者客户端编译器运行过程中，会不断收集性能监控信息，譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解，最多只能依照一些启发性的条件去进行猜测。但在动态运行时却能看出它们具有非常明显的偏好性。如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它</li><li><strong>激进预测性优化（Aggressive Speculative Optimization）</strong>，这也已经成为很多即时编译优化措施的基础。静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果）与优化前是等效的，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度</li><li><strong>链接时优化（Link-Time Optimization，LTO）</strong>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码，这类事情在Java程序员眼里看起来毫无违和之处。但如果类似的场景出现在使用提前编译的语言和程序上，譬如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。这是因为<strong>主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码</strong>。这些代码的作者、编译的时间，以及编译器甚至很可能都是不同的，当出现跨链接库边界的调用时，那些理论上应该要做的优化——譬如做对调用方法的内联，就会执行起来相当的困难</li></ul></li></ul></li><li><p><strong>编译优化技术</strong></p><ul><li>OpenJDK的官方Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、即时编译器中采用的优化技术列表（见P556）</li><li>前提：<strong>即时编译器对这些代码优化变换是建立在代码的中间表示或者是机器码之上的，绝不是直接在Java源码上去做的</strong></li><li>常见编译优化技术<ul><li>方法内联（方法替换）<ul><li>优点：一是去除方法调用的成本（如查找方法版本、建立栈帧等）；二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。因此各种编译器一般都会把内联优化放在优化序列最靠前的位置</li></ul></li><li>冗余访问消除（Redundant Loads Elimination）<ul><li>如果删除某段代码不会影响最终这个方法的返回结果，则删除</li></ul></li><li>复写传播（Copy Propagation）<ul><li>如果A变量不需要使用B变量间接表达，则删除B</li></ul></li><li>无用代码消除（Dead Code Elimination）<ul><li>无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”</li></ul></li></ul></li><li>代表性编译优化：<ul><li>最重要的优化技术之一：方法内联<ul><li>方法内联重要且是其它优化技术的前提但是在java中本身很多代码是无法进行内联的</li><li><strong>无法内联的原因</strong>其实在第8章中讲解Java方法解析和分派调用的时候就已经解释过：只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，简而言之，Java语言中默认的实例方法是虚方法。对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个方法版本，如果不依赖上下文，是无法确定b的实际类型是什么的。假如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是执行父类的get()方法还是子类的get()方法，这应该是根据实际类型动态分派的，而实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论。更糟糕的情况是，由于Java提倡使用面向对象的方式进行编程，而Java对象的方法默认就是虚方法，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知，内联与虚方法之间会产生“矛盾”，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键字来修饰，但Java选择了在虚拟机中解决这个问题。</li></ul></li><li>最前沿的优化技术之一：逃逸分析</li><li>语言无关的经典优化技术之一：公共子表达式消除</li><li>语言相关的经典优化技术之一：数组边界检查消除</li></ul></li></ul></li></ul><h2 id="第十二章：Java内存模型和线程"><a href="#第十二章：Java内存模型和线程" class="headerlink" title="第十二章：Java内存模型和线程"></a>第十二章：Java内存模型和线程</h2><ul><li><p>每秒事务处理数（Transactions Per Second，TPS）</p></li><li><p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化</p></li><li><p>JMM的意义：屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序</p></li><li><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数</p></li><li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory），线程又各自拥有不同的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系</p></li><li><p>java堆中保存的数据</p><ul><li>对于HotSpot虚拟机来讲，Java堆保存了实例数据，Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）、Klass Point（指向存储类型元数据的指针）及一些用于字节对齐补白的填充数据</li></ul></li><li><p>JMM定义了工作内存和主内存交换数据通过lock,unlock,read,load,use,assign,store,write八种基本操作（这八种操作都是原子性的），后为了简化，将其简化为read、write、lock和unlock四种，并且将处理时需要满足的条件简化为happen-before原则</p></li><li><p>volatile</p><ul><li>volatile是Java虚拟机提供的最轻量级的同步机制，保证可见性可以作为通知变量使用</li><li>volatile作用<ul><li>保证变量具有可见性（A线程更改后B线程能立马得知）</li><li>禁止指令重排序优化，通过添加内存屏障，使得重排序时不能把后面的指令重排序到内存屏障之前的位置</li></ul></li><li>虽然变量具有可见性，但由于递增运算并不是原子性的（根本原因在于Java里面的运算操作符并非原子操作），从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中</li><li>注意字节码也不一定是原子操作：一条字节码指令在解释执行时，解释器要运行许多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令</li><li>volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少</li><li>针对long和double型变量的特殊规则，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）但实际上64位机上不会出现问题，32位机上出现这种问题也十分罕见，所以不用因为这个原因专门声明对应volatile变量</li></ul></li><li><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的</p><ul><li><p>原子性：</p><ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）</li><li>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了<strong>lock和unlock操作</strong>来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令<strong>monitorenter和monitorexit</strong>来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性</li></ul></li><li><p>可见性：</p><ul><li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。<strong>普通变量与volatile变量的区别</strong>是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li><li>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</li></ul></li><li><p>有序性</p><ul><li>Java程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</strong><ul><li>前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics）</li><li>后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li></ul></li><li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul></li><li><p>happen-before原则</p><ul><li><p>“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，<strong>线程是否安全</strong>的非常有用的手段，避免通过苦涩复杂的JMM来判断线程是否安全</p></li><li><p>定义：操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等（所以先行发生不意味着时间上真的先运行）</p></li><li><p>如果两个操作之间的关系不在happen-before原则中，并且无法从下列规则推导出来，则它们就没有顺序性保障，<strong>虚拟机可以对它们随意地进行重排序</strong>（简言之happen-before原则可以作为判断是否能重排序的规则（能重排序不代表一定重排序））</p></li><li><p>注意先行发生原则和时间没有关系，二者互不影响，详细见下分析</p><ul><li>示例一（先执行的不一定先行发生）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128144957798.png" alt="image-20221125203205479"></p><ul><li>线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么?    答案：可能是0，也有可能是1</li><li>分析：由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的</li><li>解决方法：<ul><li>要么把getter&#x2F;setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；</li><li>要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系</li></ul></li><li>示例二（满足先行发生的不一定真的时间上先发生）</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221128145018987.png" alt="image-20221125203607563"></p><ul><li>根据程序次序规则，“int i&#x3D;1”的操作先行发生于“int j&#x3D;2”，但是“int j&#x3D;2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这一点</li></ul></li></ul></li><li><p>线程相关</p><ul><li><p>Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java类库API中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现（恰好也是java线程是映射到系统线程的体现）</p></li><li><p>实现线程主要有三种方式</p><ul><li><p><strong>使用内核线程实现（1：1实现）</strong></p><ul><li>使用内核线程实现的方式也被称为1：1实现。<strong>内核线程（Kernel-Level Thread，KLT）</strong>就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过<strong>操纵调度器（Scheduler）</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上</li><li>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）</li><li>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——<strong>轻量级进程（LightWeight Process，LWP）</strong>，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型<ul><li>PS：概念上只要不是内核线程都应该被视为用户线程，但LWP是映射在KLT上的，不具有一般意义上的用户线程优点，故仍然被视为内核线程</li></ul></li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125192746870.png" alt="image-20221125192746870" style="zoom:67%;" /><ul><li>优点：<ul><li>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作</li></ul></li><li>局限性：<ul><li>线程切换代价大：由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，<strong>需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换</strong></li><li>线程的数量有限：每个轻量级进程都需要有一个内核线程的支持，因此<strong>轻量级进程要消耗一定的内核资源</strong>（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的</li></ul></li></ul></li><li><p><strong>使用用户线程实现（1：N实现）</strong></p><ul><li>优点：狭义上的用户线程指的是完全建立在用户空间的线程库上，<strong>系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量</strong>，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型</li><li>局限性：成也萧何败也萧何，用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如<strong>“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂，除了有明确的需求外（譬如以前在不支持多线程的操作系统中的多线程程序、需要支持大规模线程数量的应用），一般的应用程序都不倾向使用用户线程。</strong>Java、Ruby等语言都曾经使用过用户线程，最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如Golang、Erlang等，使得用户线程的使用率有所回升</li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125194107906.png" alt="image-20221125194122388" style="zoom:67%;" /></li><li><p><strong>使用用户线程加轻量级进程混合实现（N：M实现）</strong></p><ul><li>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现式，被称为N：M实现。在这种混合实现下，<strong>既存在用户线程，也存在轻量级进程</strong>。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，<strong>这大大降低了整个进程被完全阻塞的风险</strong>。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N：M的关系，如图12-5所示，这种就是多对多的线程模型</li><li>总结兼具了以上两种特点，能够使用灵活的用户线程，同时有轻量级进程不容易导致进程完全阻塞的优点<ul><li>N和M，在于可以有多个UT绑定在LWP上，也可以只有UT绑定在LWP上</li></ul></li></ul><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125200903780.png" alt="image-20221125194107906" style="zoom:67%;" /></li><li><p>java线程的实现</p><ul><li>JDK 1.2以前：早期的Classic虚拟机上是基于一种被称为“绿色线程”（Green Threads）的用户线程实现的</li><li>从JDK 1.3起：“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型（当然也有其他虚拟就采用另外两种线程实现方式）</li></ul></li><li><p>java线程特点</p><ul><li>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</li><li>由于线程实现很大程度上取决于操作系统的实现，所以java虚拟机规范实际上并不在意是如何实现的，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的（看不见的，无所谓的）</li></ul></li></ul></li><li><p>java线程调度方式（线程调度是指系统为线程分配处理器使用权的过程）</p><ul><li><strong>协同式（Cooperative Threads-Scheduling）线程调度</strong><ul><li>优点：<ul><li>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题</li></ul></li><li>缺点：<ul><li>线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的Windows 3.x系统就是使用协同式来实现多进程多任务的，那是相当不稳定的，只要有一个进程坚持不让出处理器执行时间，就可能会导致整个系统崩溃</li></ul></li></ul></li><li><strong>抢占式（Preemptive Threads-Scheduling）线程调度（java的实现方式）</strong><ul><li>特点：<ul><li>线程的切换，运行时间都是由系统控制的，线程可以调用Thread::yield()方法主动让出运行时间，但是不能通过线程本身获取运行时间，在这种调度方式下不会有线程导致系统崩溃问题</li><li>虽然线程的调度是系统控制的，但是我们可以使用线程优先级来”建议“系统对于线程的青睐，Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）<ul><li>优先级本身依赖于操作系统的实现，Solaris中线程有2147483648（2的31次幂）种优先级，但Windows中就只有七种优先级，所以可能存在一对多，多对一的情况</li><li>优先级本身不靠谱的原因<ul><li>由于优先级的映射问题，可能多个java优先级实际上映射的是同一个系统优先级</li><li>线程调度本质还是系统控制，系统可能因为优化等原因“擅自”改变运行顺序，如在Windows系统中存在一个叫“优先级推进器”的功能（Priority Boosting，当然它可以被关掉），大致作用是当系统发现一个线程被执行得特别频繁时，可能会越过线程优先级去为它分配执行时间，从而减少因为线程频繁切换而带来的性能损耗</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>java线程的状态转化</p><ul><li>Java语言定义了6种线程状态，在任意一个时间点中，<strong>一个线程只能有且只有其中的一种状态</strong>，并且可以通过特定的方法在不同状态之间转换</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125194122388.png" alt="image-20221125200903780"></p><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125200921258.png" alt="image-20221125200921258"></p></li></ul></li><li><p>java和协程</p><ul><li>Java语言抽象出来隐藏了各种操作系统线程差异性的统一线程接口，这本是其优势，但是由于高并发场景的出现，这种模式出现了一些弊病</li><li>现代B&#x2F;S系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在<strong>减少单个服务复杂度、增加复用性</strong>的同时，也不可避免地<strong>增加了服务的数量</strong>，缩短了留给每个服务的响应时间。这要求每一个服务都必须在<strong>极短的时间</strong>内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待</li><li>微服务架构下，java略显疲态：Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，<strong>但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限</strong>。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费</li></ul></li><li><p>切换内核线程为什么比切换用户线程成本要高？</p><ul><li>内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于<strong>响应中断、保护和恢复执行现场的成本</strong>，假设发生了  “  线程A -&gt; 系统中断 -&gt; 线程B  “ 过程</li><li>处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。</li><li>而这里说的<strong>“上下文”</strong><ul><li>以<strong>程序员</strong>的角度来看，是<strong>方法调用过程中的各种局部的变量与资源</strong>；</li><li>以<strong>线程</strong>的角度来看，是<strong>方法的调用栈中存储的各类信息</strong>；</li><li>而以<strong>操作系统和硬件</strong>的角度来看，则是<strong>存储在内存、缓存和寄存器中的一个个具体数值</strong>。</li></ul></li><li>物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作</li></ul></li><li><p>使用用户线程（协程）的好处</p><ul><li>如果说内核线程的切换开销是来自于保护和恢复现场的成本，那如果改为采用用户线程，这部分开销就能够省略掉吗？答案是“不能”。但是，一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上，那我们就可以打开脑洞，通过玩出很多新的花样来缩减这些开销</li><li>由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。又由于<strong>这时候的协程会完整地做调用栈的保护、恢复工作</strong>（自己调度上下文的保护，恢复工作），所以今天也被称为“有栈协程”（Stackfull Coroutine），起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine）区分开。无栈协程不是本节的主角，不过还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限</li><li>协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多，在不进行特殊设定的情况下，则在64位Linux上HotSpot的线程栈容量默认是1MB，此外内核数据结构（Kernel Data Structures）还会额外消耗16KB内存。与之相对的，一个协程的栈通常在几百个字节到几KB之间</li></ul></li><li><p>使用用户线程（协程）的弊端</p><ul><li>协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多</li><li>协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单。不过有不少资料上显示，既然取了“协程”这样的名字，它们之间就一定以协同调度的方式工作（并不绝对，反例并不少见）</li></ul></li><li><p>java实现协程的难点</p><ul><li>到Java语言，还会有一些别的限制，譬如HotSpot这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如Kotlin提供的协程实现，一旦遭遇synchronize关键字，那挂起来的仍将是整个线程</li></ul></li></ul></li></ul><h2 id="第十三章：线程安全与锁优化"><a href="#第十三章：线程安全与锁优化" class="headerlink" title="第十三章：线程安全与锁优化"></a>第十三章：线程安全与锁优化</h2><ul><li><p>线程安全：</p><ul><li>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的</li></ul></li><li><p>可操作的数据的安全状态（从强到弱）</p><ul><li><strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong></li><li>不可变：<ul><li>“不可变”带来的安全性是最直接、最纯粹的</li><li>在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及java.lang.Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型。但同为Number子类型的原子类AtomicInteger和AtomicLong则是可变的（TODO 为什么这两个是可变的）</li></ul></li><li>绝对线程安全（TODO 和相对线程安全的对比）：</li><li>相对线程安全：<ul><li>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</li><li>在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等</li></ul></li><li>线程兼容：<ul><li>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等</li></ul></li><li>线程对立<ul><li>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</li></ul></li></ul></li><li><p>线程安全的实现方法：</p><ul><li><p><strong>一、互斥同步：</strong></p><ul><li>是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的</li><li>互斥同步的应用<ul><li>synchronized关键字<ul><li>最常见的互斥同步的应用是<strong>synchronized关键字</strong>，这是一种块结构（BlockStructured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成<strong>monitorenter和monitorexit</strong>这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<strong>如果Java源码中的synchronized明确指定了对象参数</strong>，那就以<strong>这个对象的引用作为reference</strong>；<strong>如果没有明确指定</strong>，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是<strong>取代码所在的对象实例还是取类型对应的Class对象</strong>来作为线程要持有的锁</li><li>根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</li><li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li><li>synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作（在一些简单的方法中使用synchronized方法可能本身运行的时间还赶不上切换线程的消耗）。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中</li></ul></li><li>重入锁（ReentrantLock）<ul><li>java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，是各种锁的实现基础</li><li>重入锁（ReentrantLock）是Lock接口最常见的一种实现，顾名思义，<strong>它与synchronized一样是可重入的</strong>。在基本用法上，<strong>ReentrantLock也与synchronized很相似</strong>，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：<ul><li><strong>等待可中断：</strong>是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量</li><li><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li></ul></li><li>ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，看起来好像完爆synchronized，但还是在两者都能使用的时候选择synchronized，原因如下<ul><li><strong>简单易用：</strong>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized</li><li><strong>保证释放资源：</strong>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放</li><li><strong>synchronized更好优化的天性：</strong>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>二、非阻塞同步</strong></p><ul><li><p>互斥同步面临的主要问题是<strong>进行线程阻塞和唤醒</strong>所带来的性能开销，因此这种同步也被称为<strong>阻塞同步</strong>（Blocking Synchronization）。从解决问题的方式上看，互斥同步属于一种悲观的并发策略，<strong>其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）</strong>，这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展，我们已经有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>，<strong>通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为<strong>非阻塞同步（Non-Blocking Synchronization）</strong>，使用这种措施的代码也常被称为<strong>无锁（Lock-Free）编程</strong></p></li><li><p>要求操作和冲突检测这两个步骤具备原子性。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所以我们只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：（无论硬件底层使用的命令类型如何，最终暴露出来的都是CAS操作）</p><ul><li>在IA64、x86指令集中有用cmpxchg指令完成的CAS功能，</li><li>在SPARC-TSO中也有用casa指令实现的，</li><li>而在ARM和PowerPC架构下，则需要使用一对ldrex&#x2F;strex指令来完成LL&#x2F;SC的功能</li></ul></li><li><p><strong>CAS指令</strong>需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断</p></li><li><p>在java9之前，是不允许用户调用Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供CAS操作的HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了（并发包中的整数原子类的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS），由于Unsafe类中的方法限定了只有启动类加载器加载的类才能调用CAS操作，所以在JAVA9之前除非使用反射这样的奇技淫巧否则无法调用，直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作</p></li><li><pre><code class="java">//1.8中的incrementAndGet方法public final int incrementAndGet() &#123;        return U.getAndAddInt(this, VALUE, 1) + 1;    &#125;public final int getAndAddInt(Object o, long offset, int delta) &#123;        int v;        do &#123;  //不断进行CAS操作            v = getIntVolatile(o, offset);        &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));        return v;    &#125;    public final boolean weakCompareAndSetInt(Object o, long offset,                                              int expected,                                              int x) &#123;        return compareAndSetInt(o, offset, expected, x);    &#125;//本地方法public final native boolean compareAndSetInt(Object o, long offset,                                                 int expected,                                                 int x);</code></pre></li><li><p>ABA问题：J.U.C包为了解决这个问题（版本号或者时间戳），提供了一个<strong>带有标记的原子引用类AtomicStampedReference</strong>，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类处于相当鸡肋的位置，<strong>大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效</strong></p></li></ul></li><li><p><strong>三、无同步方法</strong></p><ul><li>解决线程安全的根源，即避免出现线程不安全的情况</li><li>常见应用<ul><li><strong>可重入代码（Reentrant Code）：</strong><ul><li>这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，<strong>可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。</strong></li><li>特点：不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等</li><li>判断方式：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的（醉了，实际上就是对重用这个词解释了一下）</li></ul></li><li><strong>线程本地存储（Thread Local Storage）：</strong><ul><li>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。（既然临界数据会导致线程不安全的问题，那么我干脆放到同一个线程中）</li><li>实际应用：<strong>大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式</strong>，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题</li><li>声明一个多线程共享的变量可以使用volatile修饰符，声明一个变量为线程独有的可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量</li></ul></li></ul></li></ul></li></ul></li><li><p>锁优化技术</p><ul><li><p>为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率引入了许多锁优化技术，适应性自旋（Adaptive Spinning）、锁消除（LockElimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（BiasedLocking）等</p></li><li><p><strong>自旋锁：</strong></p><ul><li>由于线程本身的切换开销很大，所以当某个线程请求锁的时候无法成功时，不将这个锁进行挂起而是让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋）</li><li>适用场景：自旋等待时间短，不适合自旋等待时间长的情况（这种情况考虑使用自适应自旋）</li><li>使用参数：<ul><li>-XX：+UseSpinning参数来开启，在JDK 6中就已经改为默认开启了</li><li>-XX：PreBlockSpin来自行更改自旋的次数，默认是10次</li></ul></li><li>自适应自旋<ul><li>自适应意味着自旋的时间不再是固定的了，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态</strong>来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了</li></ul></li></ul></li><li><p><strong>锁消除</strong></p><ul><li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行</li><li>同步代码块的出现频率实际上很高，即使用户没有显示的调用同步代码，实际上在运行过程中也是有很多同步代码和同步代码块优化</li><li>应用场景<ul><li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126130001272.png" alt="image-20221126125054413"></li></ul></li></ul></li><li><p><strong>锁粗化</strong></p><ul><li>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围<strong>限制得尽量小</strong>——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁</li><li>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗</li><li>应用场景：连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了</li></ul></li><li><p><strong>轻量级锁</strong></p><ul><li>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点<strong>，轻量级锁并不是用来代替重量级锁的，</strong>它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li><li>轻量级锁是基于对于对象的Mark Word 实现的，而轻量级锁的加锁解锁操作实际上都是基于CAS实现的</li><li>Mark Word：是一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125628190.png" alt="image-20221126125628190"></p><ul><li><p><strong>轻量级锁的工作流程</strong></p><ul><li>1、在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125826690.png" alt="image-20221126125826690"></p><ul><li>2、然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图13-4所示<ul><li><strong>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。</strong>虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li></ul></li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126125054413.png" alt="image-20221126130001272"></p><ul><li>3、轻量级锁的解锁过程（把原本存在栈帧中的Mark Word换回来）：上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程</li></ul></li><li><p>轻量级锁的应用分析：</p><ul><li>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在<strong>有竞争</strong>的情况下，轻量级锁反而会比传统的重量级锁更慢（适用于竞争量真的小的情况）</li></ul></li></ul></li><li><p><strong>偏向锁</strong></p><ul><li>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了（我摊牌了，我就赌所有的操作一般都不会有并发请求，所以我偏向第一个获取锁的线程，直到有别的线程来读取这个对象我才进行相关同步操作）</li><li>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</li><li>假设当前虚拟机启用了偏向锁（<strong>启用参数-XX：+UseBiased Locking，默认启动</strong>），<strong>那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作</strong>（例如加锁、解锁及对Mark Word的更新操作等）</li><li><strong>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。</li></ul><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126161740653.png" alt="image-20221126161740653"></p><ul><li><p>不用担心使用偏向锁时由于线程id和epoch的位置占据了hash值，因为线程ID和hashcode本身就是势不两立的</p><ul><li><p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求[1]时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁</p><p>的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码</p></li></ul></li><li><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能（和CAS操作有一样的弊端，如果这个资源真的是被多个线程并发处理的话，那么最好还是不要用偏向锁（多此一举））</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
