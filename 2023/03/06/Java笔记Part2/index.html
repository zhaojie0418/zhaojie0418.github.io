

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="接口(Interface) 接口和类是一种并列的结构，一定程度上解决了Java中的单继承的问题，使得其可以进行多重继承 继承类是指“是不是”，接口类是指“能不能” 接口中所定义的属性都是全局常量（即必须同时使用public static final 但是可以省略不写） 同样的，接口中的方法默认是public abstract修饰的，而且可以省略不写   接口是比抽象类更抽象的结构 class A">
<meta property="og:type" content="article">
<meta property="og:title" content="fluid">
<meta property="og:url" content="http://example.com/2023/03/06/Java%E7%AC%94%E8%AE%B0Part2/index.html">
<meta property="og:site_name" content="fluid">
<meta property="og:description" content="接口(Interface) 接口和类是一种并列的结构，一定程度上解决了Java中的单继承的问题，使得其可以进行多重继承 继承类是指“是不是”，接口类是指“能不能” 接口中所定义的属性都是全局常量（即必须同时使用public static final 但是可以省略不写） 同样的，接口中的方法默认是public abstract修饰的，而且可以省略不写   接口是比抽象类更抽象的结构 class A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190626192756554.png">
<meta property="og:image" content="c:\Users\%E5%B0%8F%E8%B5%B5%E5%90%8C%E5%AD%A6\Desktop\%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\%E5%9B%BE%E7%89%87\b0aeb7ffd1667b9162e5329154d43777_r.png">
<meta property="og:image" content="c:\Users\%E5%B0%8F%E8%B5%B5%E5%90%8C%E5%AD%A6\Desktop\%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\%E5%9B%BE%E7%89%87\java-string-1-2020-12-01.png">
<meta property="og:image" content="c:\Users\%E5%B0%8F%E8%B5%B5%E5%90%8C%E5%AD%A6\Desktop\%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\%E5%9B%BE%E7%89%87\%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013122204.png">
<meta property="og:image" content="c:\Users\%E5%B0%8F%E8%B5%B5%E5%90%8C%E5%AD%A6\Desktop\%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\%E5%9B%BE%E7%89%87\%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211026222630.jpg">
<meta property="article:published_time" content="2023-03-06T12:20:13.351Z">
<meta property="article:modified_time" content="2021-11-18T09:16:31.950Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190626192756554.png">
  
  
  
  <title>fluid</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-06 20:20" pubdate>
          2023年3月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          264 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h4 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(Interface)</h4><ul>
<li>接口和类是一种并列的结构，一定程度上解决了Java中的单继承的问题，使得其可以进行多重继承</li>
<li>继承类是指“是不是”，接口类是指“能不能”</li>
<li>接口中所定义的属性都是全局常量（即必须同时使用public static final 但是可以省略不写）<ul>
<li>同样的，接口中的方法默认是public abstract修饰的，而且可以省略不写</li>
</ul>
</li>
<li>接口是比抽象类更抽象的结构</li>
<li>class A extends B implements C,D,E(可实现多继承)</li>
<li>接口和接口之间也可以进行继承，并且可以进行多继承</li>
<li>接口的具体使用，实际上就是多态性的体现，接口实际上可以看做是一种规范</li>
<li>可以在形参列表中进行创建一个接口，并进行调用</li>
<li>Java8中关于接口的新特性：<ul>
<li>除了可以定义全局常量和抽象方法之外，还可以定义<strong>静态方法和默认方法</strong></li>
<li>接口中的静态方法只能通过接口进行调用，不能通过实现类进行调用（类似工具类）</li>
<li>接口中的默认方法可以通过实现类的对象可以调用接口中的默认方法，若实现类重写了接口中的默认方法，调用时使用的是重写过后的方法，如果一个子类继承的父类和实现的接口的同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（类优先原则）</li>
<li>如果实现类实现了多个接口，而这些多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，编译器会报错（接口冲突）这就需要我们必须在实现类中重写此方法</li>
</ul>
</li>
</ul>
<p>在Java中，Java文件是源文件，而class文件是通过Java文件编译后产生的字节码文件</p>
<h4 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h4><ul>
<li>开发中优先选择实现Runnable接口的方式<ul>
<li>原因：a，实现的方式没有类的单继承性的局限性  b,实现的方式更适合来处理多个线程有共有数据的情况</li>
</ul>
</li>
<li>两种方式的相同点：两种创建线程的方式都需要重写run()方法，将线程要执行的逻辑声明在run()方法中</li>
</ul>
<p>this代指的对象是调用该方法的对象</p>
<p>所有省略没写调用方法的对象名的对象都是this</p>
<p>注意两种创建新线程的方式不同：若是使用继承Thread类的方式创建多线程的方式，慎用this来充当同步监视器。可以考虑使用当前类来充当同步监视器；若是使用实现Runnable接口的方式创建新线程，则可以使用this关键词来充当同步监视器(前一种方法创建了多个对象，即产生的锁不唯一，而后一种方法只创建了一个继承Runnable接口的类的实例化对象，其他对象只是以这个这个实例化对象为参数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//这种解决线程安全的处理方式适合于该方法中的所有操作都是基于共享数据的  </span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-comment">//(针对于继承类的开启新线程方法）这两种方法是等价的，即在方法前用synchronized修饰等价为用synchronized修饰该代码块的锁</span><br></code></pre></td></tr></table></figure>

<p>解决线程安全问题的方式：1、同步代码块2、同步方法3、Lock锁(JDK5.0新增)</p>
<p>是否需要考虑如何解决线程安全问题：若有共享数据则需要考虑解决线程安全问题</p>
<h4 id="Lock锁的使用方法："><a href="#Lock锁的使用方法：" class="headerlink" title="Lock锁的使用方法："></a>Lock锁的使用方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*synchronized和lock的异同？</span><br><span class="hljs-comment">相同：二者都可以解决安全问题</span><br><span class="hljs-comment">不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器，而Lock需要手动的启动同步(Lock())，同时结束同步也需要手动的进行实现unlock()</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.实例化ReentrantLock</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">//2.调用锁定方法lock()</span><br>lock1.lock();<br><span class="hljs-comment">//3.调用解锁方法unlock()</span><br>lock1.unlock();<br></code></pre></td></tr></table></figure>

<p>在IDEA中定义过但没有调用过的方法体是灰色的</p>
<p>线程通信当中使用的三个方法：</p>
<ul>
<li>wait( )：一旦执行此方法，当前线程就会进入阻塞状态，并且释放同步监视器</li>
<li>notify( ):一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级较高的那个线程</li>
<li>notifyAll( ):一旦执行此方法，就会唤醒所有被wait的线程</li>
</ul>
<p>1、这三个在线程通信中所使用的方法必须使用在同步代码块或者同步方法中</p>
<p>2、这三个方法的调用者必须是同步代码块或者同步方法中的同步监视器，否则会出现异常</p>
<p>3、这三个方法是继承于java.lang.object</p>
<h4 id="sleep-和wait-的异同"><a href="#sleep-和wait-的异同" class="headerlink" title="sleep( )和wait( )的异同"></a>sleep( )和wait( )的异同</h4><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</p>
<p>不同点：1、两个方法所声明的位置不同：Thread类中声明sleep( )，而在Object类中声明wait( ) 2、调用的要求不同：sleep( )可以在任何需要的场景下进行调用，wait( )必须使用在同步代码块或者同步方法中 3、关于是否释放同步监视器：如果两个方法都使用在同步代码块或者同步方法中，sleep( )不会释放锁，而wait()会释放锁</p>
<h4 id="类中还可定义类作为主类的成员变量："><a href="#类中还可定义类作为主类的成员变量：" class="headerlink" title="类中还可定义类作为主类的成员变量："></a>类中还可定义类作为主类的成员变量：</h4><p>如果在主类中声明了一个其他类的对象，那么主类实例化的时候，也同时实例化了那个其他类的对象。如果这个其他类对象有自己的特殊的构造函数，你主类构造时如果没有实现那个构造函数。那么这个其他类的对象因为缺少构造函数的调用是无法实例化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在顾客消费货物问题的main方法中</span><br><span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br><span class="hljs-comment">//Clerk是Producer和Consumer中所共有的子类</span><br><span class="hljs-type">Producer</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(clerk);<br>p1.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br><span class="hljs-comment">//二者都将clerk作为其类中的参数，而clerk在此之前就已经被创建了，clerk是Clerk类的实例化对象</span><br><span class="hljs-type">Consumer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(clerk);<br>c1.setname(<span class="hljs-string">&quot;消费者1&quot;</span>);<br></code></pre></td></tr></table></figure>

<h4 id="print、printf、printin的区别："><a href="#print、printf、printin的区别：" class="headerlink" title="print、printf、printin的区别："></a>print、printf、printin的区别：</h4><p>print:普通输出    printin：比普通输出多个换行   printf：主要是继承了C语言的printf的一些特性，可以进行格式化输出</p>
<p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</p>
<p>路径：<br>    1、绝对路径是指这个文件在操作系统中的位置，<br>    2、相对路径通过这个文件的上一级 &#x2F; 或下一级&#x2F; 来指定文件内容</p>
<pre><code class="hljs">    例如：
    D:\Steam\steamapps\common\dota 2 beta
    
流中用的就是路径名。因为和系统文件相关。
</code></pre>
<p>全类名：全类名是指package + （.）类的名字</p>
<pre><code class="hljs">    例如：
    二分查找.NO4第一个错误的版本.Solution
     包名           包名          类名
全类名例如 Class.forName（&quot;....&quot;），通过字符串来创建字节码对象（类对象）。
</code></pre>
<h4 id="创建抽象类的匿名子类"><a href="#创建抽象类的匿名子类" class="headerlink" title="创建抽象类的匿名子类"></a>创建抽象类的匿名子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<span class="hljs-comment">//创建抽象类Person</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-comment">//创建匿名子类的非对象p，重写抽象类中的方法</span><br>		<span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<span class="hljs-comment">//等号左边表示的是被应用的对象类型（是个引用变量），右边才是真正的创建对象</span><br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>				System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);<br>				&#125;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123; <br>				System.out.println(<span class="hljs-string">&quot;走路&quot;</span>);<br>			&#125;<br>		&#125;;<br>		method(p);<br>		method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<span class="hljs-comment">//创建抽象类的匿名子类</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;chifan&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;huxi&quot;</span>);<br>        &#125;<br>	&#125;<br>	<span class="hljs-comment">//这里的method方法仅用如测试重写方法是否成功，与如何创建抽象类的匿名子类无关，如果输出结果是“吃饭 走路”，则表示创建成功。</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Person p)</span> &#123;<br>		p.eat();<br>		p.walk();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>string类实际上相当于将字符数组进行封装，将其看做是一个类，使用方法对其进行操作</p>
<p>string的内存解析：尚硅谷P469</p>
<p>string的不可变性：对字符串的任意操作都需要重新创建一个字符串，而不是在原来字符串的基础上进行改变</p>
<p><strong>字符串的比较大小</strong>是从两个字符串的第一个开始比较大小，若相同则一起往后移动一个格，直到遇到字符不相同的时候返回值是不同的那对字符的ASCII值的差值 </p>
<p>在字符串类型的操作方法往往都是“左闭右开”的</p>
<p>只有具有子父类关系的类才能进行强转</p>
<p>当编码集和解码集不一致时，解析完产生的结果可能出现乱码</p>
<p>Java没有无符号类型，全部是有符号类型的数据类型</p>
<h4 id="StringBuffer和StringBuilder、string的异同"><a href="#StringBuffer和StringBuilder、string的异同" class="headerlink" title="StringBuffer和StringBuilder、string的异同"></a>StringBuffer和StringBuilder、string的异同</h4><p>StringBuffer：可变的字符序列；线程安全的，效率较低（尝试用于多线程的情况）底层使用char型数组存储</p>
<p>StringBuilder：可变的字符序列；线程不安全的，效率较高（非多线程的时候常用）底层使用char型数组存储</p>
<p>String：不可变的字符序列；底层使用char型数组存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-comment">//相当于创建了char[ ] value = new char[0];</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//相当于创建了char[ ] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><span class="hljs-comment">//相当于char[ ] value = new char [16];</span><br>sb1.append(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//相当于 value[0]=&#x27;a&#x27;;</span><br>sb1.append(<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">//相当于 value[1]=&#x27;b&#x27;;</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//相当于创建了char[] value = new char[&quot;abc&quot;.length()+16];</span><br>System.out.printin(sb2.length());<span class="hljs-comment">//sb2.length()=3  返回字符串的实际长度</span><br>System.out.printin(sb2.capacity());<span class="hljs-comment">//sb2.capacity()=16 返回字符串所占容器的总大小</span><br>容量不等于实际长度<br><span class="hljs-comment">//扩容问题：如果要添加的数据底层数组存放不下，则需要对底层数组进行扩容，默认情况下，扩容为原来容量的两倍多2，同时将原有数组中的元素复制到新的数组中，特别的：若添加的字符串很长，即使是扩容后依然无法容纳，数组会将这个长字符串的长度当成扩容的长度</span><br><br><span class="hljs-comment">//开发中常使用构造器StringBuffer(int capacity)或StringBuilder (int capacity)即在创建StringBuffer时就确定其大小，避免扩容过程中对数组的复制降低效率</span><br></code></pre></td></tr></table></figure>

<p><strong>健壮性(鲁棒性）</strong>：鲁棒是Robust的音译，也就是健壮和强壮的意思。它也是在异常和危险情况下系统生存的能力。比如说，计算机软件在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。</p>
<p><strong>调用过时的结构的时候关键词会被idea中间画黑线，提示这种结构已经过时了(存在更合适更好的结构)</strong></p>
<p>有时输出的界面会有延迟，输出的实际结果可能和计算结果不符</p>
<p>list相当于是动态数组</p>
<p>遍历集合的方法：</p>
<p>iterator本身是个迭代器，操作数据是在原本数据基础上进行操作的，其本身并不存储数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>    System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//hasNext():判断是否存在下一个元素</span><br><span class="hljs-comment">//next():1、指针下移  2、将下移以后集合位置上的元素返回</span><br>下面是错误方式<span class="hljs-number">1</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br><span class="hljs-keyword">while</span>(iterator.next()!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(iterator.next());<br>&#125;<span class="hljs-comment">//会导致越界，并且导致输出是间隔一个进行输出（进行两次next才输出一次）</span><br>下面是错误方式<span class="hljs-number">2</span><span class="hljs-comment">//创建了匿名的迭代器（通过调用iterator()方法来生成迭代器）</span><br><span class="hljs-keyword">while</span>(coll.iterator().hasNext())&#123;<br>    System.out.println(coll.iterator.next());<br>&#125;<span class="hljs-comment">//由于集合对象每一次调用iterator()方法都会得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前，所以这个错误方式会一直不断产生新的迭代器，同时不断输出该coll中的第一个元素</span><br><span class="hljs-comment">//remove()方法的使用：删除集合中的Tom</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> coll.iterator();<br><span class="hljs-keyword">while</span> (iteratior.hasNext())&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;Tom&quot;</span>.equals(obj))&#123;<br>        iterator.remove();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意remove必须在next之后调用，而且不能连续使用两次remove因为remove方法只是移除但是并不对指针进行移动，需要使用next方法将指针后移</span><br>新特性：foreach(增强版<span class="hljs-keyword">for</span>循环)<br>遍历集合：<span class="hljs-keyword">for</span>(集合元素的类型 局部变量：集合对象)<br>    <span class="hljs-keyword">for</span>(Object obj : coll)&#123;<br>        System.out.println(obj);<br>    &#125;<span class="hljs-comment">//改变obj的值不会影响原集合的值</span><br>遍历数组：<span class="hljs-keyword">for</span>(数组元素的类型 局部变量：数组对象)<br><span class="hljs-type">int</span>[ ] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>        System.out.println(i);<br>    &#125;<span class="hljs-comment">//改变i的值不会影响原数组的值</span><br><span class="hljs-comment">//第一次取得coll集合的第一个元素，然后将这个元素赋给Object类型的obj元素，然后取得coll集合的下一个元素，重复此操作，实际上内部仍然使用了迭代器</span><br> <br></code></pre></td></tr></table></figure>

<h4 id="List接口的使用："><a href="#List接口的使用：" class="headerlink" title="List接口的使用："></a>List接口的使用：</h4><p><strong>Array和list的异同：</strong>二者都是顺序表，Array是一段连续的存储结构而List不是连续的存储结构，List的每一个节点都包含有Next标明了下一个元素存在的位置</p>
<p>ArrayList、LinkedList、Vector三者的异同</p>
<ul>
<li>相同点：三个类都是实现List接口，存储数据的特点相同，都是存储有序的、可重复的数据</li>
<li>不同点：<ul>
<li>ArrayList：作为List接口的主要实现类；<strong>线程不安全的，效率高</strong>；底层使用的是Object[ ] elementData存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类比ArrayList的效率高；底层使用的是双向链表存储</li>
<li>Vector：作为List接口的古老实现类：<strong>线程安全的，效率低</strong>；底层使用Object[ ] elementData存储</li>
</ul>
</li>
</ul>
<p><strong>建议在开发中使用带参构造器：ArrayList List &#x3D; new ArrayList(int capcity)使其避免进行扩容，提高运行效率</strong></p>
<p>集合中不能存放基本数据类型，存放基本数据类型需要转化为对应的包装类</p>
<p>collection接口子接口：1、Set接口  2、list接口</p>
<p>list.add(list1); 将list1看做个整体加到list中</p>
<p>list.addall(list1);将list1中的元素分开来看，一个一个加到list中</p>
<p>list.remove(2); 舍弃的是角标为2的元素</p>
<p>list.remove(new Integer(value 2));舍弃的是list中元素值为2</p>
<h4 id="重写和重载的比较："><a href="#重写和重载的比较：" class="headerlink" title="重写和重载的比较："></a>重写和重载的比较：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-built_in">super</span>.move();<span class="hljs-comment">//使用super关键词调用父类中被重写的方法</span><br>      System.out.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;狗可以吠叫&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDog</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>      <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// Animal 对象</span><br>      <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>      b.bark();<br>   &#125;<br>&#125;<br><span class="hljs-comment">//编译时会报错，因为b的数据类型是Animal但是Animal类中没有bark方法(左边是数据类型，右边是构造器方法)</span><br></code></pre></td></tr></table></figure>

<h5 id="重写特点"><a href="#重写特点" class="headerlink" title="重写特点"></a>重写特点</h5><ul>
<li>重写方法的参数列表必须完全相同</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以</li>
<li>构造方法不能被重写</li>
</ul>
<h5 id="重载特点"><a href="#重载特点" class="headerlink" title="重载特点"></a>重载特点</h5><ul>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式</p>
<ul>
<li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)</li>
<li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现</li>
</ul>
<h5 id="instanceof-关键词"><a href="#instanceof-关键词" class="headerlink" title="instanceof 关键词"></a>instanceof 关键词</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> obj <span class="hljs-keyword">instanceof</span> Class<br>    <span class="hljs-comment">//其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false</span><br>　<span class="hljs-comment">//　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定</span><br></code></pre></td></tr></table></figure>

<h5 id="默认方法，静态方法，私有方法"><a href="#默认方法，静态方法，私有方法" class="headerlink" title="默认方法，静态方法，私有方法"></a>默认方法，静态方法，私有方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>   <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;我是一辆车!&quot;</span>);<br>   &#125;<br>&#125;<br><span class="hljs-comment">//在没有默认方法之前，需要对接口进行升级，则需要使用定义一个对应接口的子接口，然后让需要升级的继承类再次继承这个子接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterfaceSon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">newshow</span><span class="hljs-params">()</span>;<br>&#125;<br>Interface3 <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Interface0</span>, Interface1...<br><span class="hljs-comment">//继承多个接口的写法</span><br><span class="hljs-comment">/*默认方法：</span><br><span class="hljs-comment">*       默认方法是可以在接口中写执行体的。主要作用：</span><br><span class="hljs-comment">*       1.接口升级，可以避免改变其他实现类。</span><br><span class="hljs-comment">*       2.函数拼接</span><br><span class="hljs-comment">* 格式：public default 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*该格式中的public可以省略</span><br><span class="hljs-comment">*   注意：接口的默认方法可以通过接口或者实现类的对象类进行调用，实现类可以选择性地其进行覆盖重写。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 静态方法：</span><br><span class="hljs-comment">*静态方法不可以实例化，在接口中也是一样的</span><br><span class="hljs-comment">*注意静态方法不能够调用非静态方法       </span><br><span class="hljs-comment">*所以在接口中定义静态方法的作用就是类的静态方法的作用：</span><br><span class="hljs-comment">*不需要实例化，直接使用，并且只能通过接口进行调用而不能通过其实例化的类或者对象进行调用，节省内存空间。</span><br><span class="hljs-comment">*格式：public static 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*该格式中的public可以省略</span><br><span class="hljs-comment">* 注意：接口中静态方法和类中静态方法一样，只能通过接口.静态方法名的方式调用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">PS:接口中在新特性中能够使用私有方法，并不是意味着只有接口中才能够使用静态方法</span><br><span class="hljs-comment">私有方法的好处：1.减少重复代码数量，提高代码的可读性 2.为封装性考虑</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*私有方法：</span><br><span class="hljs-comment">*格式：private 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*作用：当两个默认方法或者静态方法中包含有一段相同的代码实现时，程序必然考虑将这一段代码抽取成一个共性方法，而这个共性方法是不需要让别人了解的(黑盒)，因此进行私有化隐藏起来</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*私有静态方法：</span><br><span class="hljs-comment">*格式：private static 返回值 方法名()&#123;&#125;</span><br><span class="hljs-comment">*作用：同私有方法相同，只不过私有静态方法是针对于静态方法中的相同代码块</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//默认方法可以调用私有的静态方法和私有的非静态方法</span><br><span class="hljs-comment">//静态方法只能够调用私有的静态方法</span><br></code></pre></td></tr></table></figure>

<h4 id="多态的具体理解"><a href="#多态的具体理解" class="headerlink" title="多态的具体理解"></a>多态的具体理解</h4><p>编译时多态：比如重载<br>运行时多态：比如重写</p>
<p>父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。</p>
<p>我们将引入Java静态分派和动态分派这个概念。</p>
<ul>
<li>静态分派:所有依赖静态类型来定位方法执行版本的分派动作。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，而是由编译器来完成。（编译时多态）</li>
<li>动态分派：在运行期根据实际类型确定方法执行版本的分派动作。（运行时多态）</li>
</ul>
<p>static变量并不是归于对象所有，而是归属于类所有，被所有的对象所共有</p>
<h5 id="多态成员访问的特点"><a href="#多态成员访问的特点" class="headerlink" title="多态成员访问的特点"></a>多态成员访问的特点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure>

<p><strong>成员变量</strong></p>
<p>编译看左边（基类），运行看左边（基类）；无论如何都是访问基类的成员变量</p>
<p><strong>成员方法</strong></p>
<p>编译看左边（基类），运行看右边（派生类），动态绑定</p>
<p><strong>Static方法</strong></p>
<p>编译看左边（基类），运行看左边（基类）。</p>
<p>非静态的成员方法</p>
<p>编译看左边（基类）,运行看右边（派生类）</p>
<p>这样，我们也可以得出多态的局限：</p>
<p><strong>不能使用派生类特有的成员属性和派生类特有的成员方法</strong></p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>在调用成员变量以及静态方法时，“编译看左边，运行看左边”，</strong>即程序编译时创建了一个Animal类型的对象，并且使用new Cat()对于这个Animal对象赋值，但最终得到的还是一个Animal类的对象，只需要看“&#x3D;”左边的Animal animal即可</li>
<li>在调用非静态方法时，由于Animal类的对象是用Cat()来实例化的，这个非静态方法在运行时会被重写，从而输出子类中方法重写后的结果。这就是“编译看左边，运行看右边”</li>
</ul>
<h5 id="foreach（增强版for）的使用："><a href="#foreach（增强版for）的使用：" class="headerlink" title="foreach（增强版for）的使用："></a>foreach（增强版for）的使用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//for(集合或数组中元素的类型 局部变量i :集合或数组的名称)</span><br><span class="hljs-keyword">for</span>(Object obj : coll)&#123;<br>    System.out.println(obj);<br>&#125;<span class="hljs-comment">//遍历集合</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>    i=i+<span class="hljs-number">10</span>;<span class="hljs-comment">//注意这里不会改变数组元素的值，i在这里是个形参</span><br>    System.out.println(i);<br>&#125;<span class="hljs-comment">//遍历数组</span><br><span class="hljs-comment">//其本质还是调用了迭代器</span><br></code></pre></td></tr></table></figure>

<h5 id="set特点"><a href="#set特点" class="headerlink" title="set特点"></a>set特点</h5><p>Set接口中没有定义额外的新的方法，使用的都是Collection中声明过的方法</p>
<p>要求：向Set中添加新的数据，其所在的类一定要重写equals()方法和hashCode()方法，重写的equals()方法和hashCode()方法尽可能保持一致性：相同的对象必须具有相等的散列码，equal()方法用于判断元素是否相同，hashCode()用于判断元素应该存放的角标位置</p>
<p><strong>使用Alt+Shift+S可以直接生成新的equals()方法和hashCode()方法</strong></p>
<p>无序性和不可重复性——以HashSet为例说明：</p>
<ul>
<li>无序性：并不是随机性，多次遍历的输出顺序是相同的，都是按照某个特定的顺序进行输出，存储的数据在底层数组中并非按照数组索引的顺序进行添加，而是通过数据的哈希值来决定存放位置</li>
<li>不可重复性：保证添加的元素按照equals()判断时，不能返回true，即相同的元素只能添加一个</li>
</ul>
<p>添加元素的过程——以HashSet为例说明：</p>
<ul>
<li><p>通过数据的哈希值进行某些算法决定底层数组存储的角标，避免了添加第100个元素时得和以前的所有数据进行比较，但是由于哈希值不同计算出来的角标位置是可能是相同的，若待存放数据计算得到的位置已经有元素了，进行equals()，若不相同则用链表的方式连接到这个元素上(存放的位置“七上八下”) ，即<strong>Set实际上是数组和链表的结合</strong></p>
<p> JDK7：待存放的元素指向原来存在的元素</p>
<p> JDK8：原来存放的数组指向待存放的元素</p>
</li>
</ul>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li>LinkedHashSet是HashSet的子类</li>
<li>在存放数据的时候同时多了一个标注顺序的双向链表，在添加数据的同时每个数据还维护了两个引用，记录此数据前一个数据和后一个数据</li>
<li>优点：对于需要频繁的遍历操作 LinkedHashSet效率高于HashSet</li>
</ul>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><ul>
<li>向TreeSet中添加数据，要求是相同类的对象（因为需要进行比较）</li>
<li>排序的方式：自然排序(实现Comparable接口)  和  定制排序(Comparator)</li>
<li>TreeSet中比较是否重复和排序的根据是类中重写的compareTo方法（自然排序）或者compare方法（定制排序）进行比较</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li>和collection类是并列的关系，用于存储双列数据，类似函数</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul>
<li>在集合中没有使用泛型的情况下可能会有两种问题：1、存放学生成绩时用Object类可能会导致非int型的变量输入  2、由于输入的数据可能不是所想要的数据强转的过程中可能会异常</li>
<li><strong>只有在实例化的时候才确定了泛型所对应的数据类型，在自定义泛型类的时候可以把泛型看作是一个类，但实际上它是一个参数类型</strong></li>
<li>如果定义了泛型类，但是实例化没有指明类的泛型，则认为该泛型类型是Object类型</li>
<li>如果定义了类是带泛型的，建议在实例化的时候指明类的泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承带泛型的父类的两种情况</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;Integar&gt;&#123;&#125;<br><span class="hljs-comment">//由于子类在继承带泛型的父类时就指明了所接入的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;T&gt;&#123;&#125;<br><span class="hljs-comment">//继承带泛型的父类时，同样也可以保留使用泛型的特点</span><br><br><span class="hljs-comment">//如果想要创建泛型数组的写法</span><br>T[ ] arr = (T[ ]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确写法</span><br>T[ ] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//错误写法</span><br></code></pre></td></tr></table></figure>

<ul>
<li>泛型不同的引用对象不能彼此之间相互赋值</li>
<li><strong>由于泛型是在实例化调用的时候才使用确定的，而静态结构是在实例化之前存在的，故静态方法中不能使用类的泛型，特殊的，自定义异常类不能使用泛型</strong></li>
<li>泛型方法：在方法中出现了泛型的结构，至于泛型方法所属的类是不是泛型类都行，注意并不是使用泛型的方法就是泛型方法</li>
<li>泛型方法可以被声明为静态的，因为其泛型参数是在调用方法时确定的，而不是在实例化类的时候确定的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">Dosth</span> <span class="hljs-params">(E[] arr)</span>&#123;<br>    <span class="hljs-comment">//&lt;E&gt;表明E是一个泛型，该方法是泛型方法</span><br>    <span class="hljs-comment">//List&lt;E&gt;表明返回值是一个泛型List</span><br>    <span class="hljs-comment">//E[] arr表明参数是个泛型数组</span><br>&#125;<br><span class="hljs-comment">//泛型方法在调用时，指明泛型参数的类型</span><br>List&lt;Integer&gt; list = order.Dosth(arr);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>泛型在继承方面的体现：是否有子父类关系取决于外层对象的类</p>
</li>
<li><p>如果类A和类B是子父类关系，（或者其他类型）List(A)和List(B)不具有子父类关系</p>
</li>
<li><p>如果类A和类B是子父类关系，且A是B的父类，则A<G>是B<G>的父类</p>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>集合接口和集合类在JDK5.0时都修改成了带泛型的结构</li>
<li>在实例化集合类的时候，可以指明具体的泛型类型</li>
<li>在指明完后，在集合类或者接口中凡是定义类或者接口时，内部结构（方法、属性、构造器等）使用到类的泛型的位置，都指定为实例化的泛型类型</li>
<li>泛型的类型必须是类，不能是基本数据类型，在需要使用基本数据类型的位置，使用包装类</li>
<li>如果实例化时没有指明泛型的类型，默认类型为Object类型</li>
</ul>
<h4 id="🥙通配符-即？"><a href="#🥙通配符-即？" class="headerlink" title="🥙通配符(即？)"></a>🥙通配符(即？)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*如果类A和类B是子父类关系，（或者其他类型）List(A)和List(B)不具有子父类关系,二者共同的父类是G&lt;?&gt;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    List&lt;Object&gt; list1 = <span class="hljs-literal">null</span>;<br>    List&lt;String&gt; list2 = <span class="hljs-literal">null</span>;<br>    List&lt;?&gt; list = <span class="hljs-literal">null</span>;<br>    list = list1;<br>    list = list2;<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<span class="hljs-comment">//编译时产生错误，因为我们不知道list当中的成员的具体数据类型，故无法添加任何数据，除了null因为null特殊在它是所有类型的成员</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//读取是允许的，按照Object类型方式进行读取</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>文件的位置：</p>
<p>1、绝对路径：从D:\开始写等等</p>
<p>File file1 &#x3D; new File(“D:\\workspace\\day08\\he.txt”)</p>
<p>(本身Windows的分隔符是  \  但是由于这个符号在编译器里是转义字符，所以要写成连续两个\\)</p>
<p>2、相对路径：默认相对于在当前module目录下（如果该语句写在主函数当中，则是相较于当前工程而言的）</p>
<p>File file2 &#x3D; new File(“he.txt”)</p>
<p>3、寻找文件夹的方式：</p>
<p>File file3 &#x3D; new File(“D:\\workspace”，JavaSenior)；</p>
<p>寻找名为JavaSenior的文件夹</p>
<p>4、寻找指定文件夹下的文件</p>
<p>File file1 &#x3D; new File(file3,”hi.txt”)；注意第一个参数是一个File类，即名为JavaSenior的文件夹</p>
<p>输入输出总是相对而言的，而相对于文件和程序，对于程序员而言，应当从程序的角度来分析输入输出，即从内存的角度来分析输入输出 </p>
<p><strong>缓冲流</strong>：能够提高流的读取和写入的速度，提高速度的原因是，存在缓存区，当缓冲区的存储数据满后批量移动数据，</p>
<p><strong>flush()</strong>;缓冲流的方法，用于刷新缓冲区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;地址&quot;</span>)));<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;地址&quot;</span>)));<br><span class="hljs-comment">//由于缓冲流是包在节点流之外的，所以可以用一行代码来代替</span><br></code></pre></td></tr></table></figure>

<p><strong>转换流</strong>：属于字符流也是处理流，其作用是提供字节流和字符流之间的转化，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过使用转换流，可以使得使用某编码集的文件转换成另一种编码集的文件</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;something.txt&quot;</span>);<br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis);<br><span class="hljs-comment">//所传的一个参数应该是字节输入流，此时默认使用系统默认的字符集</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//所传的第二个参数是指定的编码集，具体使用什么字符集取决于文件something.txt保存时所使用的字符集</span><br></code></pre></td></tr></table></figure>

<p><strong>字符集</strong>：许多字符集都兼容ASCII码</p>
<p>汉字有的需要两个字节储存，有的需要一个字节存储，为避免将一个两个字节的文字看成是两个一个字节的文字，故在第一个字节时，如果首位是0则说明是这两个自己分别有意思，如果首位是1这说明是两个字节是一个整体</p>
<p><strong>数据流</strong>：数据流的写入都需要使用数据流来操作 ，读取不同类型的数据的顺序要和当初写入文件时，保存的数据的顺序一致</p>
<p><strong>反序列化</strong>：将磁盘文件中的对象还原成内存中的一个Java对象，通过使用ObjectInputStream来进行实现</p>
<h4 id="复习异常的处理"><a href="#复习异常的处理" class="headerlink" title="复习异常的处理"></a>复习异常的处理</h4><ul>
<li>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</li>
<li>Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</li>
<li>如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，如果父类在子类的前面则会使得对于异常对象的查找不合适，父类会覆盖掉本应该让子类异常处理的问题，导致有没意义的异常处理出现</li>
<li>异常的出现相当于：提前预判了可能会出现的错误输出情况并且显式的给出了对应的解决异常方法</li>
</ul>
<p>API:应用程序编程接口</p>
<p>Java中的API：JDK中所提供的的各种Java类</p>
<p>java中的lang包是不需要导包的</p>
<p>抽象类可以作为形参和返回值，但是注意由于抽象类是不能够被实例化的，所以如果方法中的参数是抽象类，需要实际上传入抽象类的子类作为参数(使用了多态的性质)，同理当抽象类作为一个返回值时实际上返回的是抽象类的子类。</p>
<p>接口可以作为形参和返回值，类似抽象类，实际形参是接口的实现类对象，返回的实际上是接口的实现类对象</p>
<p>Animal a &#x3D; new Cat();</p>
<h4 id="Properties类的使用"><a href="#Properties类的使用" class="headerlink" title="Properties类的使用"></a>Properties类的使用</h4><ul>
<li>Properties 类位于 java.util.Properties ，是Java 语言的配置文件所使用的类， Xxx.properties 为Java 语言常见的配置文件，如数据库的配置 jdbc.properties, 系统参数配置 system.properties</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190626192756554.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>继承了Hashtable 类，以Map 的形式进行放置值， put(key,value) get(key)</li>
</ul>
<h4 id="内部类补充"><a href="#内部类补充" class="headerlink" title="内部类补充"></a>内部类补充</h4><ul>
<li>内部类可以看成是外部类的组成部分，比如人的心脏，心脏应该是人的一个变量但是一个变量不足以表示心脏，故将其看做是一个内部类</li>
<li>外部类想要调用内部类不需要创建一个内部类的对象才能够调用内部类的方法属性，而内部类可以调用外部类的变量(在类的定义以外调用，更需要通过内部类所特殊的创建类的方法 )</li>
</ul>
<p>内部类可以分为四种:<strong>成员内部类、局部内部类、匿名内部类、静态内部类</strong></p>
<ul>
<li>成员内部类:定义在类中的类</li>
<li>局部内部类：定义在方法中的类，和成员内部类的区别在于局部内部类的访问权限仅限于方法或作用域内</li>
<li>注意内部类可以写在参数列表当中，在需要该参数时顺便创建了该参数的对象</li>
<li>匿名内部类：没有构造方法。也是唯一没有构造方法的内部类。<strong>匿名内部类和局部内部类只能访问外部类的final变量</strong>，匿名内部类的本质是继承了该类或者实现了该接口的子类匿名对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当匿名内部类作为参数时，这个方法中定义的参数可以是接口可以是抽象类可以是具体类，并且写匿名内部类的代码块当中可以给对应的父类或者接口中的方法进行重写</span><br><span class="hljs-comment">//匿名内部类的使用(写在类中或者写在方法中)</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>)<br>    &#125;<br>&#125;.show();<span class="hljs-comment">//创建对象的时候就调用方法</span><br><span class="hljs-comment">//由于本质上匿名内部类是一个对象，所以如果想要多次调用方法则应该使用多态的形式</span><br><span class="hljs-type">Inter</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>)<br>    &#125;<br>&#125;<br>i.show();<br>i.show();<br><span class="hljs-comment">//该方法创建了一个抽象类或者接口的匿名子类，然后通过多态的方式进行调用方法</span><br></code></pre></td></tr></table></figure>



<ul>
<li>静态内部类：静态内部类和成员内部类相比多了一个static修饰符。它与类的静态成员变量一样，是不依赖于外部类的。同时静态内部类也有它的特殊性。因为外部类加载时只会加载静态域，所以静态内部类不能使用外部类的非静态变量与方法。</li>
</ul>
<p>使用内部类的好处：</p>
<ul>
<li>完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响</li>
</ul>
<p>静态内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; new 外部类.内部类();</strong><br>成员内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; 外部类对象名.new 内部类();</strong></p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>尽量避免面向对象的复杂语法，强调去做什么而不是强调怎么去做的思想</p>
<p>当需要对一个函数式接口实例化的时候，可以使用Lambda表达式，<strong>Lambda表达式的本质就是作为函数式接口的实例</strong></p>
<p>lambda表达式的出现使得之前使用匿名实现类进行表示的现在都可以使用Lambda表达式来写</p>
<p>Lambda表达式只影响了创建实例的方式，不影响调用方法的过程</p>
<p>使用给定的函数式接口的场景 ：</p>
<p>如果在开发中需要定义函数式接口，首先确定在已有的jdk中提供的函数式接口，如果有则直接进行调用即可</p>
<p>lambda表达式使用前提：</p>
<ul>
<li>有一个接口</li>
<li>接口中有且只有一个抽象方法 </li>
<li>必须有上下文环境才能推导出lambda表达式对应的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//能够使用lambda表达式的方法定义格式</span><br>方法名（接口类型 接口形参名）<br><span class="hljs-comment">//即参数是一个接口的类型，不能是抽象类或者是具体类</span><br><span class="hljs-comment">//但实际上在使用lambda表达式调用方法时，所传入的参数是取决于接口中的唯一的抽象方法所使用的的参数</span><br></code></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>通过方法引用来使用已经存在的方案</p>
<p>lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</p>
<p>lambda表达式被对象的实例方法所替代的时候，它的形式参数全部传递给该方法作为参数</p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>若在一个接口中，只声明了一个抽象方法，则这个接口就称之为函数式接口，我们可以在一个接口上使用@FunctionaLInterface注解，这样可以用于检查这个接口是否为函数式接口</p>
<p>Lambda表达式本质是函数式接口的实例</p>
<p>当某一个方法的参数为一个接口时，可以使用lambda表达式来代替用匿名类进行创建，填入接口参数位置时，只需要写</p>
<p>参数 -&gt; 调用的方法</p>
<p>因为在接口形参的位置填入lambda表达式本身编译器就可以推断出对应的接口类型</p>
<h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h4><p><strong>运行时类</strong>：加载到内存中的类</p>
<p>在Person类外部，不可以通过Person类的对象调用其内部的私有结构</p>
<p>通过反射可以调用类中的私有结构</p>
<p>常见使用直接new和反射的方式，常见都是直接使用new的方式调用公共的结构，但是如果在反射具有动态性的时候用后者（使用反射创建对象就是为了体现反射的动态性）</p>
<p><strong>反射机制和面向对象的封装性不矛盾</strong>：封装性强调的是不建议在外部调用私有的属性，而反射的特性相当于强化了Java的能力，强调它可以调用私有的结构</p>
<p><strong>关于java.lang.Class类的理解</strong>：万事万物皆对象的概念理解，即类本身也是另一个类的对象，加载到内存中的运行时类会缓存一定的时间，在此时间内，我们可以通过不同的方式来获取此运行时类，并且通过不同的方式获取的运行时类是相同的，Class实例对应着加载到内存中的一个运行时类</p>
<p>**newInstance():**方法实际上 其本质还是使用了其类的空参构造器进行创建对象</p>
<p><strong>newInstance():正常使用的条件</strong>1.运行时类必须提供空参的构造器  2.空参的构造器的访问权限需要足够。通常设置为public</p>
<p>在javabean中要求提供public的空参构造器，原因如下：1.便于通过反射，创建运行时类的对象  2.便于子类继承此运行时类时，默认调用super()，保证父类有此构造器</p>
<p>使用反射创建对象就是便于在运行时确定想要创建的类，便于对框架的使用</p>
<p>通过反射可以获取和调用运行时类的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过反射创建对象的方式之一</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><span class="hljs-comment">//通过反射创建对象的方式之二</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-comment">//往往采用第一种方式创建对象，因为反射的动态性，所有需要提高代码的通用性，使用第一种方法来调用对应类中的空参构造器</span><br></code></pre></td></tr></table></figure>

<p>创建对象的方法：1. new + 构造器  2.部分类中存在静态方法用于创建对象  3.通过反射进行创建对象</p>
<p>待处理：反射相关的方法</p>
<p><a href="%5Bjava%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3_fly_zhyu%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_java%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90%5D(https://blog.csdn.net/fly_zhyu/article/details/74178883)">Java内存解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jian0110/p/10690483.html">Java泛型解析</a></p>
</li>
</ul>
<p>**Javabean:1、所有属性为private  2、提供默认构造方法  3、提供getter和setter  4、实现serializable接口 **       <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19773379">JavaBean详细解释</a></p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>静态代理特点：在编译期间代理类和被代理类就已经确定了</strong></p>
<p><strong>实现动态代理所需要解决的问题：</strong></p>
<p><strong>问题一：</strong>如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</p>
<p><strong>问题二：</strong>当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</p>
<p>定义代理类时，可以定义参数是代理类所实现的接口，因为当实际创建代理类对象时，传入的参数是实现接口的被代理类（多态）</p>
<h2 id="amp-和-amp-amp-：当且仅当-a、b-都为-true-时，结果为-true-；"><a href="#amp-和-amp-amp-：当且仅当-a、b-都为-true-时，结果为-true-；" class="headerlink" title="&amp;和&amp;&amp;：当且仅当 a、b 都为 true 时，结果为 true ；"></a>&amp;和&amp;&amp;：当且仅当 a、b 都为 true 时，结果为 true ；</h2><h2 id="和-：-当且仅当-a、b-都为-false-时，结果为-false-；"><a href="#和-：-当且仅当-a、b-都为-false-时，结果为-false-；" class="headerlink" title="| 和 || ： 当且仅当 a、b 都为 false 时，结果为 false ；"></a>| 和 || ： 当且仅当 a、b 都为 false 时，结果为 false ；</h2><p>(前者是不聪明的逻辑运算，后者是聪明一点的逻辑运算)</p>
<p>在java中&amp;和&amp;&amp;均可用于当逻辑运算符，区别同上，并且单个的&amp;也可以当做位运算符使用</p>
<p>形参用final进行修饰表示的是这个形参只能被实参赋值一次</p>
<p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址</p>
<p>注意子类的异常类型应当放在父类的异常类型之下，如果父类的异常放在子类的上面，则子类的异常类型就不起作用了</p>
<p><strong>foreach</strong>并不是一个关键字，习惯上将for(元素类型t 元素变量x : 遍历对象obj)这种特殊的for语句格式称之为<strong>“foreach”</strong>语句</p>
<p><strong>数组和集合的差别：</strong>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了 而集合是可以动态扩展容量，可以根据需要动态改变大小</p>
<p><strong>ArrayList和Array的区别：</strong></p>
<ul>
<li>ArrayList是属于集合当中的，其长度可以发生改变，并且因为其实集合的缘故，<strong>ArrayList中不能存放基本数据类型</strong>（但是在编写当中没有差距，因为存在自动装箱的操作，但是仍然不能使用ArrayList<int>系统会认为其错误，进行报错）</li>
<li>ArrayList是基于array，它提供和array一定程度上一样的性能 但是在一些额外功能性的ArrayList上性能还是和array 存在一定差别，主要是内存的使用和CPU 耗时 </li>
<li>ArrayList 是类型安全的，因为它支持泛型(Generics) 允许编译器检查 ArrayList 里所包含的对象是否是正确的类型</li>
<li>ArrayList 也允许你删除元素，这在<strong>array上也是不可能的 通过删除</strong>，我的意思并不是将null置于对应的index里，而是将所删除元素的后面所有元素的index都往前移动一位，这些都是ArrayList自动为我们做的（添加元素同理）</li>
<li>ArrayList中支持使用迭代器进行遍历</li>
<li>ArrayList提供一个size()方法来告诉你当前时间点ArrayList存储了多少个元素  size() 总是和length不同的，它也是ArrayList的容量</li>
<li>ArrayList和array的另外一个重要的区别就是array可以使多维度的  如你可以设置一个二维数组或者三维数组，可以使你创在一个特殊的数据结构来代表矩阵或者2D形式(terrains)  另一方面，ArrayList并不支持允许你指定维度</li>
</ul>
<h4 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h4><p>构造器无法被标示为<em>synchronized</em>, <em>final</em>, <em>abstract</em>, <em>native</em>, 或者 <em>static</em></p>
<p><strong>抽象类的构造器作用：</strong></p>
<ul>
<li>子类的构造方法中，如果没有调用父类的构造方法，就会默认加一个super()</li>
<li>抽象类的构造器不能用来实例化对象，但是可以被子类调用</li>
</ul>
<p>Java 里的构造器会按照以下顺序完成下列工作：</p>
<ol>
<li>将类变量初始到缺省值。（byte, short, int, long, float, 和 double 变量会默认设为它们相应的0值，booleans 会被设为 false, chars 会被设为空字符(‘\u0000’)，对象引用会被设为 null）</li>
<li>引用父类的构造器，如果没有定义任何构造器。</li>
<li>将实例变量初始化到指定值。</li>
<li>执行构造器内的代码。</li>
</ol>
<p>一、普通代码块<br>　　直接在一个方法中出现的{}就称为普通代码块，例子程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeDemo01</span>&#123;<br>　　　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>　　　　<span class="hljs-comment">//普通代码块</span><br>　　　　&#123;<br>　　　　　　<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>　　　　　　System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x);<br>　　　　&#125;<br>　　　　<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>　　　　System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x);<br>　　　　&#125;<br>　　&#125;<br><span class="hljs-comment">//在方法中定义的代码块，并没有特殊的实际意义</span><br></code></pre></td></tr></table></figure>

<p>二、构造代码块</p>
<p>　　直接在类中定义的没有加static关键字的代码块{}称为构造代码块，例子程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;第一构造块&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test1</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次调用&quot;</span> + <span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br> <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;第二构造块&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-number">2</span>);<br> <br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行结果  第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第0次调用构造方法</span><br><span class="hljs-comment"> *           第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第1次调用构造方法</span><br><span class="hljs-comment"> *           第一构造块</span><br><span class="hljs-comment"> *           第二构造块</span><br><span class="hljs-comment"> *           第2次调用构造方法</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 构造代码块：直接在类中定义且没有加static关键字的代码块称为&#123;&#125;构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。如果存在多个构造代码块，执行顺序由他们在代码中出现的次序决定，先出现先执行。</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>

<p>三、静态代码块<br>静态代码块:在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行</p>
<p>如果类中包含多个静态代码块，那么将按照”先定义的代码先执行，后定义的代码后执行”</p>
<p>1 .静态代码块不能存在于任何方法体内</p>
<p>2 .静态代码块不能直接访问实例变量和实例方法，需要通过类的实例对象来访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">STATIC_FIELD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;静态属性&quot;</span>;<br> <br>    <span class="hljs-comment">// 静态块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(STATIC_FIELD);<br>        System.out.println(<span class="hljs-string">&quot;静态代码块1&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;非静态属性&quot;</span>;<br> <br>    <span class="hljs-comment">// 非静态块</span><br>    &#123;<br>        System.out.println(field);<br>        System.out.println(<span class="hljs-string">&quot;非静态代码块2&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InitOderTest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造函数&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InitOderTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitOderTest</span>();<br>    &#125;<br> <br>    <span class="hljs-comment">// 非静态块</span><br>    &#123;<br>        System.out.println(field);<br>        System.out.println(<span class="hljs-string">&quot;非静态代码块1&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 静态块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(STATIC_FIELD);<br>        System.out.println(<span class="hljs-string">&quot;静态代码块2&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 运行结果  静态属性</span><br><span class="hljs-comment"> *           静态代码块1</span><br><span class="hljs-comment"> *           静态属性</span><br><span class="hljs-comment"> *           静态代码块2</span><br><span class="hljs-comment"> *           非静态属性</span><br><span class="hljs-comment"> *           非静态代码块2</span><br><span class="hljs-comment"> *           非静态属性</span><br><span class="hljs-comment"> *           非静态代码块1</span><br><span class="hljs-comment"> *           无参构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//在调用主方法之前，先调用所有的静态代码块(按顺序调用)再调用所有的非静态代码块(按顺序调用)，最后再调用主方法</span><br><span class="hljs-comment">//注意静态代码块只能调用静态变量</span><br></code></pre></td></tr></table></figure>

<p>四、同步代码块<br>　　同步代码块主要出现在多线程中。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>　　　　<span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>　　　　<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>　　　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>　　　　　　<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>　　　　　　　　<span class="hljs-keyword">synchronized</span>(obj)&#123;<br>　　　　　　　　　　<span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;<br>　　　　　　　　　　　　ticket--;<br>　　　　　　　　　　&#125;<br>　　　　　　　　&#125;<br>　　　　　　&#125;<br>　　　　&#125;<br>　　&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Javabean"><a href="#Javabean" class="headerlink" title="Javabean"></a>Javabean</h4><p>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。</p>
<p>通过这样的编写习惯来保证代码的<strong>向后兼容性</strong></p>
<p><strong>ArrayList中size和capacity的区别：</strong></p>
<ul>
<li>size指的是ArrayList中元素的数量</li>
<li>capacity指的是在ArrayList底层实现中Object数组的大小，也可以理解为ArrayList的容量</li>
</ul>
<p><strong>equal和 &#x3D;&#x3D;的区别：</strong></p>
<ul>
<li>对于基本数据类型：二者一样，都可以看做是比较两者的值</li>
<li>对于引用数据类型：&#x3D;&#x3D;号比较两个对象时比较的是两个对象的地址值，而由于equals()方法存在于Object类中，并且Object类是所有类的直接或间接父类，也就是说所有的类中的equals()方法都继承自Object类，<strong>并且Object类中equals()方法底层依赖的是&#x3D;&#x3D;号，那么，在所有没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;号的效果一样，也是比较的地址值，</strong>然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值（对于自定义类型，往往要重写equal方法）（即未重写的equals方法实际上和&#x3D;&#x3D;相同）</li>
</ul>
<h4 id="绝对路径和相对路径的区别："><a href="#绝对路径和相对路径的区别：" class="headerlink" title="绝对路径和相对路径的区别："></a>绝对路径和相对路径的区别：</h4><p>绝对路径：</p>
<blockquote>
<p><em>就是真实的路径,是计算机中完整路径,必须准确,否则不能找到,起点是系统的根目录,也就是各个盘符</em></p>
</blockquote>
<p>举例：C:&#x2F;Users&#x2F;a1394&#x2F;Desktop&#x2F;OneDrive</p>
<p>相对路径：</p>
<blockquote>
<p><em>绝对路径是一种简化版的路径,以当前文件,活动窗口目录为根目录,进行向上或者向下c</em></p>
</blockquote>
<p>举例：</p>
<ul>
<li><p>1</p>
</li>
<li><ul>
<li><p>2</p>
</li>
<li><ul>
<li>3.jpg</li>
</ul>
</li>
</ul>
</li>
<li><p>a</p>
</li>
<li><ul>
<li><p>b</p>
</li>
<li><ul>
<li>c.html</li>
<li>c.jpg</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1,2,a,b都是文件夹,假设现在我打开的是c.html,那么c.html所在的目录就是相对根目录</p>
<p>1.如果在同一目录下另一个文件使用c.jpg,那么路径就是<strong>url&#x3D;”c.jpg”</strong></p>
<p>2.如果我要去找3.jpg的话,就要回到父文件夹的父文件夹,也就是1,此时路径为<strong>url&#x3D;”..&#x2F;..&#x2F;“</strong>    </p>
<p>此时1文件夹和a文件夹同一级,那么就进入1然后进入2,找到3.jpg,所以最后的路径为<strong>url&#x3D;..&#x2F;..&#x2F;1&#x2F;2&#x2F;3.jpg</strong></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h3><p>相对路径比较灵活,只要层级结构没有变化,比如上面的a和b文件夹只是换了个名字,那么不影响寻址,但是绝对路径就要好好确认下路径有没有问题了</p>
<p>前端开发或者你的程序需要在不同的设备中来回移动的话,必须用相对路径,因为你换设备就会改变绝对路径,就类似于你用u盘的时候,你的盘符都不是固定的一个道理</p>
<p><strong>总结:</strong></p>
<p>绝对路径就是写死的路径,缺点是换设备会出现路径找不到问题</p>
<p>相对路径就是灵活的路径,优点是不会因为设备更换出现路径问题</p>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>1、函数的调用过程</p>
<p>调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。</p>
<p> 这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的<strong>压栈</strong>和<strong>出栈</strong>。 </p>
<p>因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。</p>
<p>2、内联函数</p>
<p>那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。<strong>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。</strong>显然，这样就不会产生转去转回的问题，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。</p>
<blockquote>
<p>写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等）。在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被编译器视为内联函数。</p>
</blockquote>
<p>3、JVM内联函数</p>
<p>C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来说，<strong>一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</strong></p>
<p>JVM内联有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。<strong>如果是长方法JVM可能直接就跪了</strong>。第二个原因则更重要：方法内联 </p>
<p><strong>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身</strong>。比如说下面这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;  <br>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>    &#125;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2)</span> &#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2;  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在金融计算中使用BigDecimal来表示准确的数字</p>
<p>”&gt;&gt;&gt;”表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</p>
<p>switch中使用的标签支持使用String类型</p>
<p>case穿透现象：如果不在case中添加break则会继续下一个</p>
<p><strong>cmd执行java命令与javac命令的区别：</strong></p>
<p>javac：是编译命令，将java源文件编译成.class字节码文件。需要加扩展名</p>
<p>例如：javac hello.java  将生成hello.class文件。</p>
<p>java：是运行字节码文件；由java虚拟机对字节码进行解释和运行。不需要加扩展名</p>
<p>例如：java hello<br>eg：c:\Users\Administrator\Desktop\javadoc&gt; java HelloWorld hello hello 123 321</p>
<p>即从被运行的文件以后的视为参数</p>
<p>若在cmd窗口中输入这些则会运行HelloWorld程序，并且传递的参数args[0]&#x3D;args[1]&#x3D;hello,args[2]&#x3D;123;</p>
<p>在单例模式要保证构造器私有</p>
<p>只有一个函数的接口称之为函数式接口</p>
<p>Date类中建议使用calendar类，更为先进</p>
<p><strong>StringBuffer：</strong>效率低，安全，多线程用</p>
<p>**StringBulider:**效率高，不安全，单线程用</p>
<p>泛型起到约束的作用，避免类型转换之间的问题</p>
<h4 id="可变长参数详解："><a href="#可变长参数详解：" class="headerlink" title="可变长参数详解："></a>可变长参数详解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//格式:</span><br>print(String... args)&#123;<br><br>&#125;<br><span class="hljs-comment">//在具有可变长参数的方法中可以把参数当成数组使用，例如可以循环输出所有的参数值</span><br>print(String... args)&#123;<br>   <span class="hljs-keyword">for</span>(String temp:args)<br>   System.out.println(temp);<br>&#125;<br><span class="hljs-comment">//调用的时候可以给出任意多个参数也可不给参数，例如：</span><br>print();<br>print(<span class="hljs-string">&quot;hello&quot;</span>);<br>print(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-comment">//调用可变长参数方法的调用规则：</span><br><span class="hljs-comment">//1、在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则选择固定参数的方法</span><br><span class="hljs-comment">//即优先使用更加精确的对应方法</span><br><span class="hljs-comment">//2、如果要调用的方法可以和两个可变参数匹配，则出现错误</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            out.println(args[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test,String...args )</span>&#123;<br>          out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VarArgsTest1</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VarArgsTest1</span>();<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>);<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;alexia&quot;</span>);<br>    &#125;<span class="hljs-comment">//对于上面的代码，main方法中的两个调用都不能编译通过，因为编译器不知道该选哪个方法调用</span><br><span class="hljs-comment">//3、一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数</span><br><br><span class="hljs-comment">//调用可变长参数的使用规范</span><br><span class="hljs-comment">//1、避免带有可变长参数的方法重载</span><br><span class="hljs-comment">//2、在可变长参数中避免使用null值和空值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test, Integer... is)</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String test,String...args )</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VarArgsTest1</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VarArgsTest1</span>();<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>);<br>        test.print(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br><span class="hljs-comment">//这时会发现两个调用编译都不通过,因为两个方法都匹配，编译器不知道选哪个，于是报错了，这里同时还有个非常不好的编码习惯，即调用者隐藏了实参类型，这是非常危险的，不仅仅调用者需要“猜测”该调用哪个方法，而且被调用者也可能产生内部逻辑混乱的情况</span><br></code></pre></td></tr></table></figure>

<h4 id="java包机制详解："><a href="#java包机制详解：" class="headerlink" title="java包机制详解："></a>java包机制详解：</h4><ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li>
</ul>
<p>创建包的注意：创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它</p>
<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中</p>
<p><strong>javadoc:</strong></p>
<p>javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件</p>
<p>每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引</p>
<p>由于 javadoc 的实现不同，工作也可能不同，你需要检查你的 Java 开发系统的版本等细节，选择合适的 Javadoc 版本</p>
<p>java中本身数组是引用变量，即无论数组元素中基本类型还是引用类型，在进行数组间的赋值时，实际上是将两个数组引用变量指向同一个数组实体，如果需要对数组进行真实的拷贝，需要调用copy方法</p>
<p>在编码过程中尽量减少读取内存的操作，因为读取内存消耗的时间远大于计算所需的开销，即内存墙</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54e2aeca013b">什么是编译型语言和解释型语言？</a></p>
<h4 id="静态语言和动态语言："><a href="#静态语言和动态语言：" class="headerlink" title="静态语言和动态语言："></a>静态语言和动态语言：</h4><p><strong>静态语言（强类型语言）</strong>：</p>
<p>在编译时变量的数据类型就已经确定，多数静态类型语言要求在使用变量之前必须声明数据类型。比如：C，C++，Java等，不允许隐式转化数据类型</p>
<p> <strong>动态语言（弱类型语言）</strong>：</p>
<p>在运行时，确认数据类型的语言。变量使用之前不需要声明类型，通常变量的类型是被赋值的那个值的类型。比如：Python，PHP，SQL，Ruby等，允许隐式转换数据类型</p>
<p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\b0aeb7ffd1667b9162e5329154d43777_r.png" srcset="/img/loading.gif" lazyload alt="b0aeb7ffd1667b9162e5329154d43777_r"></p>
<p>无论是基本数据类型还是引用数据类型，数组本身都是引用类型，只是基本数据类型中的元素是数据本身存储在堆空间中，引用类型的数组的元素数组元素也是存储在堆空间中，但是数组元素是引用对象的引用</p>
<p>如果创建了一个3*3的二维数组，则该数组的a[2]实际上是一个地址</p>
<p><strong>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</strong></p>
<p>创建字符串两种方式的不同之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1;                    <span class="hljs-comment">// 相同引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br><span class="hljs-comment">//使用new即一定在堆空间重新开辟了空间存放</span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\java-string-1-2020-12-01.png" srcset="/img/loading.gif" lazyload alt="java-string-1-2020-12-01"></p>
<h4 id="Comparable接口和Comparator接口的比较"><a href="#Comparable接口和Comparator接口的比较" class="headerlink" title="Comparable接口和Comparator接口的比较:"></a>Comparable接口和Comparator接口的比较:</h4><p><strong>Comparable接口:</strong></p>
<ul>
<li>此接口强行对实现它的每个类的对象进行整体排序 </li>
<li>类的 compareTo 方法被称为它的自然比较方法</li>
</ul>
<p><strong>Comparable接口的compareTo方法：</strong><br>public int compareTo(T o);-<br>这个Comparable是一般让一个自定义类的作为其实现类<br>将this对象与T  o对象比较，如果return0，则表示它们相等，如果&gt;0 则表示this对象比T o 对象大，如果 &lt; 0 则 this对象比T o 小</p>
<p> <strong>Comparator接口:</strong><br>对集合对象或数组对象进行排序</p>
<p><strong>Comparator接口 的compare方法：</strong><br>int compare(T o1, T o2);<br>Comparator是不需要对自定义提供接口的，而是重新写一个Comparator的新的实现类作为比较器，当做sort的一个参数，<br>sort函数的形参专门有接口这些比较器的类型（这种写法很常见，实现代码重用、扩展，也就是策略模式了） 它和Comparable比较规则一样，这里o1 与 o2比较，如果返回值 &#x3D; 0 则表示o1 &#x3D;&#x3D; o2 ；如果 &gt; 0 则表示 o1 &gt; o2; 如果 &lt; 0 则 o1 &lt; o2;</p>
<p>Comparator接口 的compare方法均为返回值&gt;0即前者大，返回值&lt;0则后者大</p>
<p><strong>Comparable接口和Comparator接口的区别：</strong></p>
<ul>
<li>Comparator位于包java.util下，而Comparable位于包java.lang下</li>
<li>Comparable接口将比较代码嵌入自身类中，而后者在一个独立的类中实现比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>                <span class="hljs-keyword">return</span> str1.compareTo(str2);<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//Comparator接口中可以实现不同种类的排序，并且可以通过匿名类的方式对Comparator接口进行实现</span><br><span class="hljs-comment">//注意区别Collection和Collections，前者是集合类，后者是工具类</span><br><span class="hljs-comment">//sort方法的第一个参数是待排序的数组，第二个参数是重写的构造器</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609">Java 到底是值传递还是引用传递？</a></p>
<p>字符流不能用于读取二进制文件，因为在使用字符流的过程中存在着编码和解码的过程，而正常二进制的文件中可能存在超过字符集编码设定范围的数字导致错码乱码</p>
<p>显示读取文件路径只传入String类型的文件名实际上是，传入的是省略了路径符号的相对路径</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43871333/article/details/89042724?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">常见几种编码格式及比较_B–rabbit的博客-CSDN博客_常见编码格式</a></p>
<p>@Test方法可以使得不必编写main方法而可以直接调用该方法</p>
<p>parseInt():将输入参数转换成int类型的返回值</p>
<p>使用字节流处理非文本文件，使用字符流处理文本文件，特殊的如果只是想将文件从一个文件复制到另外一个文件，则文本文件也可以用字节流进行处理，只要不在内存层面进行显示即可，反之不行</p>
<p>对象流的读出是按object的形式读出，可以进行强转为特定对象</p>
<p>实际上在使用对象流进行序列化时，往往是令文件中都是一种类的文件，而不是有各种各样的对象</p>
<p>序列化不仅要让当前类是可序列化的，类中的元素的数据类型也必须都是可序列化的</p>
<p>随机读取流：使得下载文件暂停后重新打开是继续进行的</p>
<p>jar包相当于是第三方提供的额外的API导入后即可使用，比如文件的复制读写等操作都有相应的jar包使用</p>
<p><strong>字符集编码知识：</strong><br>GBK:如果是1开头则标注是由两个字节表示的，如果是0开头则表明是由一个字节所表示的</p>
<p>UTF-8:在该编码集中，使用三个字节来标注汉字，其属于变长编码使用1~4个字节编码</p>
<p>Unicode：确立了编码和字符一一对应的关系而不是具体编码的形式(UTF-8,UTF-16是对应的编码形式)</p>
<p>使用” xxx.* “表示的是导入xxx包下的所有结构，但是导入的只是xxx包下的结构，如果需要使用xxx包的子包中的结构则还需要导包</p>
<p>如果定义的类或接口是本包下定义的则不需要使用import，在java.lang包下的结构也不需要使用import</p>
<p>若在源文件中使用不同的包下存在同名的结构，则需要至少其中一个类用全类名的方式调用</p>
<p>由于反射是为了进行实现动态，所以倾向于使用通用性较强的方法而不是特定的方法</p>
<p>在java中可以简单的理解为基本数据类型是传值，而引用数据类型是传引用</p>
<p>在java中每一个类都对应一个main方法，但是在一个java文件中只能有一个public的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeOrNotTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeOrNot</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> x[])</span> &#123;<br>	i = -<span class="hljs-number">1</span>;<br>    x[<span class="hljs-number">0</span>] = -<span class="hljs-number">2</span>;<br>    <span class="hljs-type">double</span> y[] = x;<br>    y[<span class="hljs-number">1</span>] = -<span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> z[] = &#123;-<span class="hljs-number">4</span>, -<span class="hljs-number">8</span>, -<span class="hljs-number">12</span>&#125;;<br>    x = z;<br>    <span class="hljs-comment">//x和z像两个小旗帜，x = z只是标明了x所指向的方向，并不是真的通过x所指的方向改变了A数组</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> A[] = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>&#125;;<br>    changeOrNot(k, A);<br>    System.out.println(<span class="hljs-string">&quot;k = &quot;</span> + k);      <span class="hljs-comment">//  1</span><br>    System.out.println(<span class="hljs-string">&quot;A[0] = &quot;</span> + A[<span class="hljs-number">0</span>]);<span class="hljs-comment">//  -2</span><br>    System.out.println(<span class="hljs-string">&quot;A[1] = &quot;</span> + A[<span class="hljs-number">1</span>]);<span class="hljs-comment">//  -3</span><br>    System.out.println(<span class="hljs-string">&quot;A[2] = &quot;</span> + A[<span class="hljs-number">2</span>]);<span class="hljs-comment">//   3</span><br>		&#125;<br>    <span class="hljs-comment">//注意数组的[]相当于是一次取址，故使用[]时会改变对应的真实值，而不进行取址时不会改变对应的具体值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>javac需要后缀名，而java不需要后缀名</p>
<p>注意由于标准输出输入流是字节流所以在进行读写操作时注意将其转化成字符流</p>
<p>文件路径默认在当前module下</p>
<p>多种字节码文件的集合即jar包可以理解成对基本java的补充，即插件类似，其不仅有编写好的类还有相关的辅助资源</p>
<p>read(arr)其中的arr可以看做是一种容器，需要注意的是其前一次搬运的数据并不会被清空而是保留之前存放好的文件</p>
<p>缓冲流的读写速度要好于结点流，往往使用缓冲流而非节点流</p>
<p>类只有两种访问权限：default和public</p>
<p>子类的方法的权限修饰符必须要比父类的访问权限修饰符要更加宽松，否则当将子类的实例赋值给父类时，若子类更加严格的访问修饰符，则无法通过父类变量调用子类的方法</p>
<p><strong>抽象方法、实例方法和虚方法的区别：</strong></p>
<ul>
<li><strong>抽象方法：</strong>使用abstract修饰的方法，只能用来声明而不能实现，抽象方法必须声明在抽象类中，反过来抽象类中不一定要有抽象方法，抽象方法的作用就是强制子类实现该抽象方法（如果子类不是抽象类的话）</li>
<li><strong>实例方法：</strong>可以用对象的引用调用的都称之为实例方法，实例方法必须在对象实例化之后，通过对象引用进行调用</li>
<li><strong>虚方法：</strong>可以被覆写的方法都称之为虚方法，因此虚方法并不需要进行特殊的声明（即虚方法是默认的，在java中不存在virtual关键词）</li>
</ul>
<p><strong>泛型方法</strong>中  <strong>T</strong>  的含义：</p>
<p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211013122204.png" srcset="/img/loading.gif" lazyload alt="微信图片_20211013122204"></p>
<p><strong>编译看左边，运行看右边的理解：</strong></p>
<ul>
<li><strong>编译看左边：</strong>虽然实际运行的方法是子类中的方法，但这个方法必须要在父类中定义过（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了）</li>
<li><strong>运行看右边：</strong>实际调用的方法是右侧变量的方法</li>
</ul>
<p>A a&#x3D;new B()：引用变量a决定了调用的是A类中的方法和属性，而引用的的对象类型B确定了调用的方法，如果B覆盖了A类的方法，那么调用B中重写的方法；如果没有覆盖，调用A类中的方法； 方法调用的优先问题 ：优先级由高到低依次为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)    （和编译看左边，运行看右边并不冲突）</p>
<p>（优先调用左边的父类，其次调用右边的父类，一次保证只用一次父类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>  ... &#123;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(D obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);<br>         &#125; <br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);<br>         &#125; <br>&#125;  <br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">B</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">A</span> ... &#123;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(B obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>...&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);<br>         &#125; <br>&#125;<br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">C</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">B</span> &#123;&#125;  <br> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">D</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">B</span> &#123;&#125;  <br> <span class="hljs-type">A</span> <span class="hljs-variable">a1</span>  <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">A</span>();<br> <span class="hljs-type">A</span> <span class="hljs-variable">a2</span>  <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">B</span>();<br> <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>     <span class="hljs-keyword">new</span>  <span class="hljs-title class_">B</span>();<br> <span class="hljs-type">C</span> <span class="hljs-variable">c</span>  <span class="hljs-operator">=</span>    <span class="hljs-keyword">new</span>  <span class="hljs-title class_">C</span>(); <br> <span class="hljs-type">D</span> <span class="hljs-variable">d</span>  <span class="hljs-operator">=</span>    <span class="hljs-keyword">new</span>  <span class="hljs-title class_">D</span>(); <br>System.out.println(a2.show(b));  B and A<br>System.out.println(a2.show(c));  B and A<br>System.out.println(a2.show(d));  A and D<br>System.out.println(b.show(b));   B and B<br>System.out.println(b.show(c));   B and B<br>System.out.println(b.show(d));   A and D   <br><br></code></pre></td></tr></table></figure>

<p>（目前看来）没有返回值是迭代器的方法，注意有时返回的是接口名，即返回继承这个接口的子类，相当于使用了多态</p>
<p><strong>静态导入</strong>可以帮助您使用静态成员的简单名称来简化程序的编写和读取，但是有时静态导入可能会在程序中引入细微的错误，这可能很难调试，故尽量减少使用静态导入</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010859650/article/details/85009595?ops_request_misc=%7B%22request_id%22:%22163525828516780269811366%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=163525828516780269811366&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-85009595.pc_search_result_control_group&utm_term=%E8%AF%A6%E8%A7%A3Java%E4%B8%ADComparable%E5%92%8CCompartor%E6%8E%A5%E5%8F%A3&spm=1018.2226.3001.4187">Java中Comparable和Comparator接口的区别_</a></p>
<p><img src="C:\Users\小赵同学\Desktop\计算机学习笔记\图片\微信图片_20211026222630.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20211026222630"></p>
<p>静态字段和非静态字段在初始化的时候都会被默认赋初始值，不同的是：静态字段是在在类加载的准备阶段时被赋值初始值，而非静态字段是在对象被创建的时候被赋初始值,本地变量，即方法中的变量不会被系统默认赋初始值</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/03/06/Java笔记Part2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/06/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/06/Java%E7%AC%94%E8%AE%B0Part1/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
