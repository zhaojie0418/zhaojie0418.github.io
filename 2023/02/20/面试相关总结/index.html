

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试题相关总结java相关java基础知识相关 java和c++对比  java和go对比  (51条消息) Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)_go java_Java烟雨的博客-CSDN博客 性能：这个是java和go之间对比必须聊到的一个话题，性能一直是java开发经常吐槽的地方。在串行的业务下，java的性能就比Go差，并发业务下，java更比go差">
<meta property="og:type" content="article">
<meta property="og:title" content="fluid">
<meta property="og:url" content="http://example.com/2023/02/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="fluid">
<meta property="og:description" content="面试题相关总结java相关java基础知识相关 java和c++对比  java和go对比  (51条消息) Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)_go java_Java烟雨的博客-CSDN博客 性能：这个是java和go之间对比必须聊到的一个话题，性能一直是java开发经常吐槽的地方。在串行的业务下，java的性能就比Go差，并发业务下，java更比go差">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141317504.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184312672.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184550382.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183754754.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/856b9a63a67a4475ae85f87499dd1aa9.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183648553.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221129145421079.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185026711.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185238672.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141809023.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165519514.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165600678.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162858367.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162139212.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165542010.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161659369.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165626261.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164538597.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230108120131773.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184605349.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164514248.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221117183934578.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120175358122.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184621739.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163119964.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123162644337.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163157233.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163247552.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161635079.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164415140.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164115232.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125161407202.png">
<meta property="og:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163400102.png">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872108920/9F0FB4B766E3BFAF3E92FEAE0553DFC5">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872090690/841D619AD8F9824776994757BB726DFB">
<meta property="article:published_time" content="2023-02-20T01:36:51.787Z">
<meta property="article:modified_time" content="2023-02-20T06:01:05.663Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141317504.png">
  
  
  
  <title>fluid</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-20 09:36" pubdate>
          2023年2月20日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          286 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试题相关总结"><a href="#面试题相关总结" class="headerlink" title="面试题相关总结"></a>面试题相关总结</h1><h2 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h2><h3 id="java基础知识相关"><a href="#java基础知识相关" class="headerlink" title="java基础知识相关"></a>java基础知识相关</h3><ul>
<li><p>java和c++对比</p>
</li>
<li><p><strong>java和go对比</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_70730532/article/details/126405302">(51条消息) Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)_go java_Java烟雨的博客-CSDN博客</a></li>
<li>性能：这个是java和go之间对比必须聊到的一个话题，性能一直是java开发经常吐槽的地方。在串行的业务下，java的性能就比Go差，并发业务下，java更比go差远了。这个可能Go比较偏向于C，C++的缘故吧，go的性能可以媲美c，c++。</li>
<li>多线程：Go就是为多线程而生的，语法直接支持多线程，使用go语法即可使用多线程。在多线程逻辑实现方面Go也比java更清晰，更简单，这个就是后发语言的优势了，不知道kotlin能不够弥补这个缺点。在性能方面，Go多线程也是碾压java，Go协程相对于传统操作系统中的线程 (thread) 是非常轻量级的，所以Go在多线程方面是比java又快内存占用又小。</li>
<li>生态：这个是java的最大优势，现在go还处于发展阶段，每个新版本出来大家都要抢着升级，因为新功能太重要了，不用不行。就比如包管理功能，从go vendor到go module，都没有java maven强大，但是都不得不用。java新版本出来了，可能不见得会去升级，好多公司现在还在用jdk1.6，因为该有的功能java都已经有了，没必要再去赶潮流。还有java的spring全家桶，虽然go没有spring，不过好在go的web模块功能也还比较强大，虽然没有spring系列方便，但是也足够使用了。</li>
<li>编译，部署：这个对于java来说可能是最轻松的事了吧，在之前的互联网公司的时候，从来没有碰到过部署方面难题，更不用说编译了，本地编译ok，服务器一定更加ok，然后部署放到类似于阿里云这类的云容器上面，一键上线轻轻松松。但是go就不一样了，编译go如同编译C++一样，不同操作系统需要交叉编译，由于依赖服务器的一些环境，所以本地还运行不了Go程序，没办法本地debug，部署更是如同打仗一般，需要写很多python脚本来将编译构建之后部署至docker,k8s上</li>
</ul>
</li>
<li><p>Java的跨平台的机制是什么？</p>
<ul>
<li>java代码得到的class文件相同，不同平台使用各自对应的jvm进行解读class文件</li>
</ul>
</li>
<li><p>String类型不可修改，为什么呢？</p>
<ul>
<li>底层实现逻辑：在jdk8时底层为char[]，在jdk9的时候底层为byte[]</li>
<li>数组长度一旦声明则不可改变，字符串一旦声明则不可改变，改变的只是引用内存指向</li>
<li>不可修改的意义：<ul>
<li>方便实现字符串对象池，如果String可变，那么对象池就需要考虑何时深浅拷贝字符串的问题了</li>
<li>更方便缓存hashCode ，作为key时可以更高效的保存到hashmap中</li>
<li>线程安全，就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理</li>
</ul>
</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141317504.png" srcset="/img/loading.gif" lazyload alt="856b9a63a67a4475ae85f87499dd1aa9"></li>
</ul>
</li>
<li><p>字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？  非要改String类型，能改的到吗？  new一个String对象，是放在哪里的？ TODO</p>
</li>
<li><p>StringBuilder和StringBuffer有什么区别</p>
<ul>
<li><p>最简单的解释：Buffer是线程安全的，Builder是线程不安全的</p>
</li>
<li><p>二者的相同点</p>
<ul>
<li>都继承AbstractStringBuilder这个抽象类，实现了CharSequence接口</li>
<li>其append方法都是调用了父类AbstractStringBuilder的append(String str)方法</li>
<li>初始容量都是16并且扩容机制也是相同的（”旧容量*2+2”）</li>
<li>底层都是用char[]字符数组实现，且字符数组都是可变的</li>
</ul>
</li>
<li><p>二者的不同点</p>
<ul>
<li><p>Buffer是线程安全的，Builder是线程不安全的</p>
</li>
<li><p>StringBuffer从JDK1.0就有了，StringBuilder是JDK5.0才出现</p>
</li>
<li><p>StringBuffer比StringBuilder多了一个toStringCache字段，用来在toString方法中进行缓存，每次append操作之前都先把toStringCache设置为null，若多次连续调用toString方法，可避免每次Arrays.copyOfRange(value, 0, count)操作，节省性能</p>
</li>
<li><p>由于StringBuilder没有考虑同步，在单线程情况下，StringBuilder的性能要优于StringBuffer</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>       toStringCache = <span class="hljs-literal">null</span>;<br>       <span class="hljs-built_in">super</span>.append(str);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>           toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>反射机制有了解吗？反射创建对象和new创建对象有什么区别？  反射和new的性能哪个更高一点？</p>
</li>
<li><p>设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）</p>
</li>
<li><p>hashmap的底层结构</p>
</li>
<li><p>字符串相关</p>
<ul>
<li><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</li>
<li>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化</li>
<li>字符串常量池的实现是基于一个hashMap实现的，其长度有个常量值（可以通过参数修改<code>-XX:StringTableSize=99991</code>）如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降（因为要一个一个找）<ul>
<li>StringTableSize含义：Number of buckets in the interned String table<br>String.intern()被调用时会往Hashtable插入一个String（若该String不存在），这里的Table就是StringTable，此参数就是这个StringTable的大小<br>若此参数设置过小，明显的问题就是过多的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>碰撞，造成在查找字符串时比较消耗CPU资源<br>JDK1.6起，当冲突次数超过100次会自动rehash，即便如此，若此参数设置过小会导致不断的rehash，依然会过度消耗CPU资源，建议将此参数设置的值稍大一些，以减少hash冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>HashMap</p>
<ul>
<li>HashMap的put操作的流程</li>
</ul>
</li>
<li><p>HashMap扩容流程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258347168">从基础到实践，一文带你看懂HashMap - 知乎 (zhihu.com)</a></li>
</ul>
</li>
<li><p>TreeMap和HashMap的区别</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dghehe/article/details/125474352">(51条消息) TreeMap和HashMap的区别_东莞呵呵的博客-CSDN博客_treemap和hashmap区别</a></li>
</ul>
</li>
<li><p>java集合（存储结构、使用场景、和List的区别，线程安全的Map）</p>
</li>
<li><p>讲讲创建线程的方式</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/clear_0217/article/details/122736610">线程的创建方式_clear0217的博客-CSDN博客_线程的创建方式</a></li>
</ul>
</li>
<li><p>runnable接口和callable接口除了区别</p>
<ul>
<li>Callable规定的方法是call(),Runnable规定的方法是run().</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值得</li>
<li>call方法可以抛出异常，run方法不可以</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li>
</ul>
</li>
<li><p>FutureTask的方法（只知道get）</p>
</li>
<li><p>浅拷贝和深拷贝</p>
<ul>
<li>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>浅拷贝：变量保存的不是对象本身,是指向对象的地址，此时改变对象本身的内容,其他变量显示内容也会改变；如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>浅拷贝两者指向同一元素，深拷贝两者互不影响</li>
</ul>
</li>
<li><p>异常类</p>
</li>
<li><p>try catch finally执行顺序</p>
</li>
<li><p>synchronized关键字、锁升级</p>
</li>
<li><p>面向对象SOLID原则：单一功能，开闭，里氏替换、接口隔离、依赖反转</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LiJiVV/article/details/112004467">(51条消息) 面向对象设计原则（SOLID）_蝎子莱布莱的博客-CSDN博客_面向对象设计的solid原则</a></li>
</ul>
</li>
<li><p>对于hash冲突，有什么解决办法吗？</p>
</li>
<li><p>怎么设计一个hash函数？（直接按照HashMap的hash思想说了一遍）</p>
</li>
<li><p>TreeMap和HashMap的查询效率分别是什么情况？</p>
<ul>
<li>[<a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/QW5YwyANzm/">Java] 多个Map的性能比较（TreeMap、HashMap、ConcurrentSkipListMap） (bbsmax.com)</a></li>
</ul>
</li>
<li><p>jdk19相关</p>
</li>
<li><p>常用在java集合类中的fastfail机制</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyuan_27/article/details/122077946">(49条消息) fail-fast 快速失败机制_Z_sh的博客-CSDN博客_快速失败机制</a></li>
</ul>
</li>
<li><p>java初始化原则：</p>
<ul>
<li><p>①静态对象（变量）优先于非静态对象（变量）初始化；</p>
<p>②父类优先于子类进行初始化；</p>
<p>③按照成员变量的定义顺序进行初始化；</p>
</li>
</ul>
</li>
</ul>
<h3 id="jvm相关"><a href="#jvm相关" class="headerlink" title="jvm相关"></a>jvm相关</h3><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184312672.png" srcset="/img/loading.gif" lazyload alt="image-20221120141317504"></p>
<ul>
<li><p>JVM内存是怎么管理的？</p>
</li>
<li><p>jvm调优常用参数</p>
</li>
<li><p>GC一般在什么时候触发？</p>
<ul>
<li><p>MinorGC触发</p>
<ul>
<li><p><strong>Allocation Failure：</strong> 分配对象失败，空间不足.</p>
</li>
<li><p><strong>Survivor 区满了</strong>，需要拷贝</p>
</li>
</ul>
</li>
<li><p>FullGC触发</p>
<ul>
<li><p><strong><code>System.gc()</code>被调用</strong>并且没有指定关闭显示GC，就是没有指定-XX:+DisableExplicitGC这个JVM flag</p>
</li>
<li><p><strong>老年代也满了</strong></p>
</li>
<li><p><strong>堆外内存满了</strong>，例如metaspace，代码即时编译缓存，直接内存，mmap内存</p>
</li>
<li><p><strong>gc 担保失败</strong>，请参考：-XX:-HandlePromotionFailure</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？如果不是，是什么机制来保障的（finalize）（是想要回答二次标记问题）</p>
<ul>
<li>其实基本没什么机会用得到这个命令System.gc(), 因为这个命令只是建议JVM安排GC运行, 还有可能完全被拒绝。 GC本身是会周期性的自动运行的,由JVM决定运行的时机,而且现在的版本有多种更智能的模式可以选择,还会根据运行的机器自动去做选择,就算真的有性能上的需求,也应该去对GC的运行机制进行微调,而不是通过使用这个命令来实现性能的优化</li>
<li>频繁GC会导致服务器的资源被消耗殆尽程序卡顿，根据不同的垃圾收集器会造成不同的STW时间</li>
<li>Java语言规范并不保证finalize方法会被及时地执行，因为JVM通常在单独的低优先级线程中完成finalize的执行，而且根本不会保证它们会被执行</li>
<li>继承自object的finalize()它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以建议完全可以忘掉Java语言里面的这个方法</li>
</ul>
</li>
<li><p>高并发下的内存管理（海量并发线程创建了许多对象导致无法处理）</p>
<ul>
<li>优化代码中的处理请求的业务逻辑，尽 量少创建一次性对象，特别是内存占用大的对象。比如让 Request 对象在业务流程中一直传递下去，而不是每执行一个步骤，就创建一个内存和 Request 相似的新对象。</li>
<li>对于需要频繁的使用，或者占用内存较大的对象，可以考虑自行回收并重用这些对象。可以为这些对象加了一个对象池，收到请求后，在对象池内申请一个对象，使用完放回对象池。反复使用，避免频繁触发垃圾回收。</li>
</ul>
</li>
<li><p>Java有了GC之后还会有内存泄漏问题吗？</p>
<ul>
<li>静态集合类泄漏</li>
<li>单例对象由于持有对外部的引用而造成泄漏</li>
<li>连接：数据库网络IO等连接没有显示调用close关闭</li>
<li>监听器：在释放对象的时候没有删除对应监听器（实际上应该是所有的发布订阅模型都会存在这个问题）<ul>
<li>可以使用弱引用（其他引用使用同理）来不太好的解决这种问题 WeakReference<String> weakReference &#x3D; new WeakReference&lt;&gt;(str1); </li>
<li>同样对于比较重要或者比较限制的资源需要及时的释放资源来保证运行</li>
</ul>
</li>
</ul>
</li>
<li><p>0哪些可以作为GC Roots？</p>
<ul>
<li><p>总结：GC Roots即运行过程中必不可少的部分</p>
<ul>
<li><strong>本地变量表，静态变量，常量，本地方法（引用的对象），jvm内部对象，同步锁的对象，反应jvm内部的对象</strong></li>
</ul>
</li>
<li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p>
</li>
<li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</p>
</li>
<li><p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</p>
</li>
<li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</p>
</li>
<li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
<li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p>
</li>
</ul>
</li>
<li><p>jvm内存模型</p>
<ul>
<li>详见jvm笔记</li>
</ul>
</li>
<li><p>方法区，元空间，永久代辨析</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126184550382.png" srcset="/img/loading.gif" lazyload alt="image-20221126184312672"></li>
<li>方法区是抽象概念，而元空间和永久代是在不同版本时对于方法区的实现</li>
</ul>
</li>
<li><p>元空间</p>
<ul>
<li><p>使用本地内存存储元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题 </p>
</li>
<li><p>回收元空间的时机分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。</p>
</li>
</ul>
</li>
<li><p>哪些地方会发生内存溢出（除了PC其他都会溢出）</p>
<ul>
<li><p>1、方法区溢出</p>
<p>第一种原因：上线的时候MetaSpace区域直接用默认的参数，即根本不设置其大小，这会导Meta</p>
<p>Space区域可能才几十M而已或者设置的比较小，此时对于一个稍微大型系统，因为他有很多自己的类，还依赖了很多外部jar包的类，MetaSpace空间很容易不够的。</p>
<p>第二种原因：就是很多人开发系统代码都会用一些cglib之类的技术动态生成一些类，一旦代码没有控制好，导致生成的类过多的时候，就很容易MetaSpace给塞满，进而引起内存溢出。</p>
<p>2、虚拟机栈&#x2F;本地方法栈溢出<br>（1）StackOverflowError：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常。最常见的场景就是方法无限递归调用。<br>（2）OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError。<br>虚拟机中可以供栈占用的空间≈可用物理内存 - 最大堆内存 - 最大方法区内存，比如一台机器内存为 4G，系统和其他应用占用 2G，虚拟机可用的物理内存为 2G，最大堆内存为 1G，最大方法区内存为 512M，那可供栈占有的内存大约就是 512M，假如我们设置每个线程栈的大小为 1M，那虚拟机中最多可以创建 512个线程，超过 512个线程再创建就没有空间可以给栈了，就报 OutOfMemoryError 异常了。</p>
<p>3、堆内存溢出<br>（1）内存中加载的数据过多如一次从<strong>数据库</strong>中取出过多数据；集合对对象引用过多且使用完后没有清空；代码中存在死循环或循环产生过多重复对象；堆内存分配不合理；网络连接问题、数据库问题等。<br>（2）系统承载高并发请求，因为请求量过大，导致大量的对象都是存活的，所以要放入新的对象放不下了，此时就会引起内存溢出系统崩溃；<br>（3）系统有泄漏的问题，就是莫名其妙产生了很多对象，结果对象都是存活的，没有及时取消他们的引用，导致触发GC还是无法回收，此时只能引发内存溢出，因为实在是放不下更多的对象了。</p>
<p>4、本机直接内存溢出<br>本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但 Java 中用到 NIO 相关操作时（比如 ByteBuffer 的 allocteDirect 方法申请的是本机直接内存），也可能会出现内存溢出的异常</p>
</li>
</ul>
</li>
<li><p>string常量池在哪</p>
<ul>
<li>位于方法区中，根据java版本的不同，在java7之前存放在永久代中，在java7后将其移动到java堆中</li>
</ul>
</li>
<li><p>字面量和符号引用的区别</p>
<ul>
<li>符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够在使用的时候无歧义的定位到对应目标即可，例如在class文件中常以CONSTANT_Class_info等变量的形式出现</li>
<li>字面量就是对应赋值操作中的常量值，如”abc”,1等</li>
</ul>
</li>
<li><p>JVM广义上的常量池分类</p>
<ul>
<li><p>1.类文件常量池</p>
<pre><code class="hljs">     我们写的每一个Java类被编译后，就会形成一份class文件（每个class文件都有一个class常量池）。 class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)

   字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;
   符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。
</code></pre>
<ol start="2">
<li>运行时常量池</li>
</ol>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">运行时常量池（Runtime <span class="hljs-keyword">Constant</span> Pool）是方法区的一部分。jdk1<span class="hljs-number">.8</span>以前存在于永久代，jdk1<span class="hljs-number">.8</span>之后存在于元空间。静态常量池中的内容，在类加载后会被存放到方法区的运行时常量池中。运行时常量池相对于<span class="hljs-keyword">Class</span>文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入<span class="hljs-keyword">Class</span>文件中静态常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。<br></code></pre></td></tr></table></figure>

<p>3.字符串常量池</p>
<pre><code class="hljs">    字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。字符串常量池的存在使JVM提高了性能和减少了内存开销。

    字符串常量池可以理解为是分担了部分运行时常量池的工作。和其他的对象分配一样，字符串耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能，为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化，为字符串开辟一个字符串常量池，类似于缓存区。实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用。

    加载时，对于class文件的静态常量池，字符串字面量会进入到当前类的运行时常量池，但不会立即进入全局的字符串常量池（即在字符串常量池中并没有相应的引用，在堆中也没有对应的对象产生），字符串常量池是lazy resolve的，在第一次引用该项的ldc指令被第一次执行到的时候才会resolve，但这个过程我们可以不关注。可以认为当类加载完成后，运行代码String str1=&quot;abc&quot;或String str2=new String(“abc”)时，字面量“abc”已经存在于字符串常量池。jdk7字符串常量池以后存在于堆中
</code></pre>
</li>
</ul>
</li>
<li><p>JMM</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/119212455">Java 内存模型(Java Memory Model)_hfnjfudnnr的博客-CSDN博客</a></li>
<li>定义：JMM 是Java内存模型（ Java Memory Model）。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范，是和多线程相关的一组规范。<strong>通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式</strong>方需要每个JVM 的实现都要遵守这样的规范，有了JMM规范的保障，并发程序运行在不同的虚拟机上时，得到的程序结果才是安全可靠可信赖的</li>
<li>详细定义见JVM书599</li>
</ul>
</li>
<li><p>GC日志（尝试阅读）（TODO 深入理解虚拟机4，5章）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/267388951">JVM实战：GC日志解析 - 知乎 (zhihu.com)</a></li>
</ul>
</li>
<li><p>类加载相关：</p>
</li>
<li><p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183754754.png" srcset="/img/loading.gif" lazyload alt="image-20221126185026711"></p>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/856b9a63a67a4475ae85f87499dd1aa9.png" srcset="/img/loading.gif" lazyload alt="image-20221126183754754"></p>
<ul>
<li><p>加载（loading）</p>
<ul>
<li>加载是读取class文件（网络，动态生成等），并将其转换为某种静态数据结构存储在<strong>方法区</strong>中，并在<strong>堆</strong>中生成一个便于用户调用的java.lang.Class类型对象的过程</li>
</ul>
</li>
<li><p>验证：</p>
<ul>
<li>进行文件格式验证，元数据，字节码验证，符号引用验证等（这些行为是在整个运行期间都存在的），保证安全性</li>
</ul>
</li>
<li><p>准备：</p>
<ul>
<li>进行相关赋值操作</li>
</ul>
</li>
<li><p>解析：</p>
<ul>
<li>将符号引用替换成直接引用</li>
<li>动态解析：如果引用的B类是一个接口，而其实现是C或者D，那么就将其暂且搁置，直到真正调用其实现类的时候，才将A的符号引用转变为对C和D的直接引用</li>
</ul>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126183648553.png" srcset="/img/loading.gif" lazyload alt="image-20221126184550382"></p>
</li>
<li><p>初始化：</p>
<ul>
<li>判断代码中是否存在主动的类的资源初始化操作（不同于对象的初始化操作，对象的初始化只有在显式调用new时才会进行），如果有则进行执行</li>
</ul>
</li>
<li><p>使用</p>
</li>
<li><p>类卸载</p>
</li>
</ul>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221129145421079.png" srcset="/img/loading.gif" lazyload alt="image-20221126185238672"></p>
</li>
<li><p>java代码执行流程</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185026711.png" srcset="/img/loading.gif" lazyload alt="image-20221126183648553"></li>
</ul>
</li>
<li><p><strong>栈上替换，方法内联，代码缓存</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justinzengTM/article/details/114255737">(49条消息) 栈上替换、方法内联和代码缓存_大力海棠的博客-CSDN博客_栈上替换</a></li>
</ul>
</li>
<li><p>对象头相关</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903832833490957">Java对象在内存的结构 - 掘金 (juejin.cn)</a></li>
</ul>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>Redis和大型数据库有什么区别？</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/agonie201218/article/details/123656539"> Redis的优势和特点</a></li>
</ul>
</li>
<li><p>Redis高效的原因</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw">为什么单线程的 Redis 如何做到每秒数万 QPS ？ (qq.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></li>
</ul>
</li>
<li><p>redis雪崩、穿透、击穿的原因和解决方案</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>redis的常见数据类型及应用场景</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>LPOP 和 BLPOP 的区别</p>
<ul>
<li>LPOP命令如果遇到列表中的数据为空时，则直接返回空值</li>
<li>BLPOP 命令可以弹出指定列表中的头部的元素，若所有的列表均不存在或者为空，则阻塞等待</li>
</ul>
</li>
<li><p>Redis 消息队列和 MQ 的区别</p>
<ul>
<li><p><strong>可靠消费</strong></p>
<ul>
<li>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理</li>
<li>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费</li>
</ul>
</li>
<li><p><strong>可靠发布</strong></p>
<ul>
<li><p>Reids：不提供，需自行实现，Redis的消息队列，如果在从队列pop出去的时候，worker处理失败的话，数据不会回到队列中，需要从业务中手动把失败的处理数据push到队列中；</p>
</li>
<li><p>RabbitMQ：具有发布确认功能，保证消息被发布到服务器RabbitMQ有一个消息确认机制来保证消息的不丢失：</p>
<ul>
<li>客户端从队列中取出消息之后，可能需要一段时间才能处理完成，如果在这个过程中，客户端出错了，异常退出了，而数据还没有处理完成，那么非常不幸，这段数据就丢失了，因为RabbitMQ默认会把此消息标记为已完成，然后从队列中移除。</li>
<li>消息确认是客户端从RabbitMQ中取出消息，并处理完成之后，会发送一个ack告诉RabbitMQ，消息处理完成，当RabbitMQ收到客户端的获取消息请求之后，或标记为处理中，当再次收到ack之后，才会标记为已完成，然后从队列中删除。当RabbitMQ检测到客户端和自己断开链接之后，还没收到ack，则会重新将消息放回消息队列，交给下一个客户端处理，保证消息不丢失，也就是说，RabbitMQ给了客户端足够长的时间来做数据处理。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>高可用</strong></p>
<ul>
<li>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案</li>
<li>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作</li>
</ul>
</li>
<li><p><strong>持久化</strong></p>
<ul>
<li>Redis：将整个Redis实例持久化到磁盘</li>
<li>RabbitMQ：队列，消息，都可以选择是否持久化</li>
</ul>
</li>
<li><p><strong>消费者负载均衡</strong></p>
<ul>
<li>Redis：不提供，需自行实现</li>
<li>RabbitMQ：根据消费者情况，进行消息的均衡分发</li>
</ul>
</li>
<li><p><strong>队列监控</strong></p>
<ul>
<li>Redis：不提供，需自行实现</li>
<li>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）</li>
</ul>
</li>
<li><p><strong>流量控制</strong></p>
<ul>
<li>Redis：不提供，需自行实现</li>
<li>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性</li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>redis： 轻量级，低延迟，高并发，低可靠性；</li>
<li>rabbitmq：重量级，高可靠，异步，不保证实时；</li>
<li><strong>rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>原生Redis分布式锁有什么问题，怎么解决（TODO 分布式锁的实现）</p>
</li>
<li><p>Redis持久化机制</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>Redis键过期策略</p>
<ul>
<li>小林code（Redis 过期删除策略和内存淘汰策略有什么区别？）</li>
</ul>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221126185238672.png" srcset="/img/loading.gif" lazyload alt="image-20221129145421079"></p>
</li>
<li><p>Redis的数据一致性（主备复制）怎么做的？</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>（TODO 集群网课）项目是单机还是多机架构？你怎么认为Redis的集群模式？为什么要有集群？</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>initServer 启动服务，另外一个就是 aeMain 事件循环</p>
</li>
<li><p>SDS（简单动态字符串）</p>
</li>
<li><p><strong>quicklist</strong> </p>
</li>
<li><p>Redis缓存更新的策略（读写策略出现问题往往是A线程执行的操作把B线程包裹住了）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路 | 酷 壳 - CoolShell</a></li>
<li>小林code相关</li>
<li>一致性要求低时（一般不会单纯使用这种方式）：使用Redis自带的内存淘汰机制</li>
<li>一致性要求高时：主动更新，并采用超时剔除兜底方案<ul>
<li><p>读操作</p>
<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库并写入缓存，并设置其超时时间</li>
</ul>
</li>
<li><p>写操作</p>
<ul>
<li><strong>先写入数据库然后再删除缓存</strong>（并不写入缓存，只是删除缓存）</li>
<li><strong>确保数据库和缓存操作的原子性</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>IO多路复用总结：</strong>(epoll用于Redis，Nginx，JavaNIO（基于Linux）)</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/410316787">深入理解 Linux 的 epoll 机制及epoll原理 - 知乎 (zhihu.com)</a></p>
<ul>
<li><p>epoll_create：创建一个 epoll 对象</p>
</li>
<li><p>epoll_ctl：向 epoll 对象中添加要管理的连接</p>
</li>
<li><p>epoll_wait：等待其管理的连接上的 IO 事件</p>
</li>
</ul>
</li>
<li><p>Select</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120141809023.png" srcset="/img/loading.gif" lazyload alt="image-20221125161407202"></li>
</ul>
</li>
<li><p>Poll</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165519514.png" srcset="/img/loading.gif" lazyload alt="image-20221125162139212"></li>
</ul>
</li>
<li><p>Epoll</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165600678.png" srcset="/img/loading.gif" lazyload alt="image-20221125162858367"></li>
</ul>
</li>
<li><p>epool快速的关键</p>
<ul>
<li>内部管理 fd 使用了高效的红黑树结构管理，做到了增删改之后性能的优化和平衡；</li>
<li>epoll 池添加 fd 的时候，调用 file_operations-&gt;poll ，把这个 fd 就绪之后的回调路径安排好。通过事件通知的形式，做到最高效的运行；</li>
<li>epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；</li>
</ul>
</li>
<li><p>布隆过滤器</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/redis/bloom-filter.html">Redis布隆过滤器（原理+图解） (biancheng.net)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zK4y1h7pA/?spm_id_from=333.337.search-card.all.click&vd_source=9a4f938fc995660b06355915cb8675cb">程序员都必须会的技术，面试必备【布隆过滤器详解】，Redis缓存穿透解决方案_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14K411c7Yo/?spm_id_from=333.999.0.0&vd_source=9a4f938fc995660b06355915cb8675cb">面试阿里，竟然给了我一窝鸟蛋，让我用鸟蛋讲布谷鸟过滤器，这是什么鬼？_哔哩哔哩_bilibili</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul>
<li><p>编码的时候，会做网络序转换，为什么要做这个转换呢？</p>
<ul>
<li>由于不同的系统对应的大小端不同需要进行转换，并且使用小端能够更好的进行部分计算机运算</li>
<li>大小端模式：</li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">大端与小端的比较</a></li>
<li>大端实际上就是按照内存地址递增的方向顺序存储，小端即反向存储对应结构</li>
<li>网络传输字节序<ul>
<li>TCP&#x2F;IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化</li>
</ul>
</li>
<li>常见的处理器大小端模式<ul>
<li>x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian</li>
<li>Motorola 6800，Motorola 68000，PowerPC 970，System&#x2F;370，SPARC（除V9外）等处理器为Big endian</li>
<li>ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的</li>
</ul>
</li>
<li>判断大小端的程序写法<ul>
<li>给定一个int类型的数字num值为1<br>如果是大端字节序，则在内存中存储方式为 0000 0000    0000 0000   0000 0000    0000 0001<br>如果是小端字节序，则在内存中存储方式为   0000 0001    0000 0000   0000 0000    0000 0000<br>要判断它们，我们可以只取出第一个字节，如果是0，则是大端；如果是1，则是小端</li>
</ul>
</li>
</ul>
</li>
<li><p>多级cache</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell</a>(写的非常好)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38017860/article/details/122988861">(缓存一致性协议-MESI_小盒子的技术分享的博客-CSDN博客</a>(关于MESI的使用)</p>
</li>
</ul>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162858367.png" srcset="/img/loading.gif" lazyload alt="image-20221120141809023"></p>
<ul>
<li><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存</p>
<p>读取数据过程。就像数据库缓存一样，首先在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，向内存要数据。一次次地未命中，代表取数据消耗的时间越长。</p>
</li>
<li><p>CPU缓存(cache)是由很多个Cache line组成的。Cache line是CPU缓存和主存交换数据的最小单位，Cache line大小是固定的，通常为64Byte</p>
</li>
<li><p>当数据大小超过Cache line的固定大小时，就没法用缓存一致性协议了，会转而使用总线加锁</p>
</li>
<li><p>缓存一致性（MESI）协议</p>
<ul>
<li>缓存一致性协议提供了一种高效的内存数据管理方案，它<strong>只会对单个缓存行（缓存行是缓存中数据存储的基本单元）的数据进行加锁，不会影响到内存中其他数据的读写</strong></li>
<li>缓存一致性协议有MSI，MESI，MOSI，Synapse，Firefly及DragonProtocol等</li>
<li>其中MESI分别代表缓存行数据所处的四种状态，通过这四种状态的切换，来管理缓存数据。可以使用2bit进行表示<ul>
<li>M修改（Modefiy）：该缓存行有效， 数据被修改了，和内存中的数据不一样，数据只存在于本缓存行中</li>
<li>E独享（Exclusive）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据只存在本缓存行中</li>
<li>S共享（Shared）：该缓存行有效，数据和内存中的数据<strong>一致</strong>，数据同时存在于其他缓存中</li>
<li>I无效（Invalid）：该缓存行数据无效</li>
</ul>
</li>
<li>MESI协议总结<ul>
<li>当CPU进行写操作时，如果发现操作的变量是共享变量，则会发出信号通知其他的CPU将该变量的缓存行置为无效状态，此时其他的CPU需要读取这个变量时，发现自己缓存中是无效的就会从内存中重新读取数据来保证一致性<ul>
<li>所谓同步化是使用监听（嗅探）其他cpu对该缓存行对应主内存地址的读取操作来实现同步</li>
</ul>
</li>
<li>其正常运行依赖于以下两点<ul>
<li>读取数据时，其他CPU缓存行如果修改了数据，需要先把修改的数据写入主存中</li>
<li>当修改数据时，其他CPU中缓存行都必须失效</li>
</ul>
</li>
<li>由于缓存行的形式，可能同时存在多个核需要修改的值存放在同一缓存行的情况，这时就会由于两个核都竞相写入这个缓存行并且导致其他核中缓存无效的重复操作，故需要进行把缓存行中仅存储目标变量，其余空间采用“无用”数据填充补齐64字节</li>
</ul>
</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125162139212.png" srcset="/img/loading.gif" lazyload alt="image-20221122165519514"></li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165542010.png" srcset="/img/loading.gif" lazyload alt="image-20221122165542010"></li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161659369.png" srcset="/img/loading.gif" lazyload alt="image-20221122165600678"></li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221122165626261.png" srcset="/img/loading.gif" lazyload alt="image-20221122165626261"></li>
<li>AMD的Opteron处理器使用从MESI中演化出的MOESI协议，O(Owned)是MESI中S和M的一个合体，表示本Cache line被修改，和内存中的数据不一致，不过其它的核可以有这份数据的拷贝，状态为S</li>
<li>Intel的core i7处理器使用从MESI中演化出的MESIF协议，F(Forward)从Share中演化而来，一个Cache line如果是Forward状态，它可以把数据直接传给其它内核的Cache，而Share则不能</li>
<li>每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li>
<li>嗅探所导致的问题：<strong>总线风暴</strong>，由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值</li>
<li>嗅探本身其实就是缓存一致性的一种实现<ul>
<li><strong>每个处理器内核都会监听在CPU总线上传播的数据，并检查自己的缓存值是否已过期；如果处理器发现自己缓存行对应的内存地址已被修改，就会将当前处理器的缓存行设置为无效状态当处理器对这个数据进行修改操作时，会重新从主内存中把数据读取到处理器的缓存中。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DMA</strong>  <strong>直接内存访问（Direct Memory Access）</strong></p>
<ul>
<li><strong>总结：</strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务（聪明的CPU让DMA去做搬运数据等脏活累活，直到干完活后才通知CPU过来做从内核缓冲区到用户缓冲区这样高难度的工作）</li>
<li>每个 I&#x2F;O 设备都有自己的 DMA 控制器</li>
<li>小林code</li>
</ul>
</li>
<li><p>零拷贝及IO优化</p>
<ul>
<li>小林code操作系统第九章</li>
<li><strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong></li>
<li>零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</li>
<li>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I&#x2F;O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能</li>
</ul>
</li>
<li><p>PageCash相关</p>
<ul>
<li>小林code操作系统第九章</li>
<li>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题</li>
<li>在高并发的场景下，针对大文件的传输的方式，应该使用<strong>「异步 I&#x2F;O + 直接 I&#x2F;O」</strong>来替代零拷贝技术。</li>
</ul>
</li>
<li><p>两层循环，循环次数多的放内层还是外层</p>
<ul>
<li>结论：存在嵌套循环时，大循环写里面，小循环写外面</li>
<li>原因：外层的循环次数正比于预测错误的次数，为了尽可能的降低预测错误的次数，故将外层循环次数降低</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164538597.png" srcset="/img/loading.gif" lazyload alt="image-20221117183934578"></li>
</ul>
</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><p>TODO 网络数据传输解析全过程</p>
</li>
<li><p>ICMP协议，有了解吗？</p>
<ul>
<li>ICMP是（Internet Control Message Protocol）Internet控制报文协议</li>
<li>主要功能（Ping）<ul>
<li>确认IP包是否成功到达目标地址</li>
<li>通知在发送过程中IP包被丢弃的原因</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP和HTTPS的区别是什么？</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoming100001/article/details/81109617?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-81109617-blog-80969419.pc_relevant_aa2&utm_relevant_index=1"> HTTP和HTTPS协议，看一篇就够了_会飞的狗~的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://tyler-zx.blog.csdn.net/article/details/80969419?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80969419-blog-117329590.pc_relevant_aa&utm_relevant_index=1"> HTTP 和 HTTPS 的区别（面试常考题）_Tyler_Zx的博客-CSDN博客_http和https区别</a></li>
</ul>
</li>
<li><p>http版本相关</p>
<ul>
<li><p>HTTP0.9</p>
<ul>
<li>最早版本是<code>1991</code>年发布的<code>0.9</code>版。该版本极其简单，只有一个命令<code>GET</code>。协议规定，服务器只能回应<code>HTML</code>格式的字符串，不能回应别的格式。服务器发送完毕，就关闭TCP连接</li>
</ul>
</li>
<li><p>HTTP1.0</p>
<ul>
<li>除了<code>GET</code>，还引入了<code>POST</code>和<code>HEAD</code>方法，丰富了浏览器与服务器的互动手段。此时不仅可以传输文字，还能传输图像、视频、二进制文件。<code>HTTP/1.0</code> 版的主要缺点是，每个<code>TCP</code>连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接（短连接）</li>
</ul>
</li>
<li><p>HTTP1.1</p>
<ul>
<li>默认使用长链接，支持管道化，不必等前一个请求响应才发出第二个请求，还提供了与身份认证、状态管理和 <code>Cache</code> 缓存等机制相关的请求头和响应头此外，还新增了五种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code>，并且增加了host字段</li>
</ul>
</li>
<li><p>HTTP2</p>
<ul>
<li>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</li>
<li>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分</li>
<li>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率</li>
<li>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li>
<li>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</li>
</ul>
</li>
<li><p>HTTP3</p>
<ul>
<li>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP</li>
</ul>
</li>
</ul>
</li>
<li><p>数字证书使用了什么机制？  数字证书为什么可以被创建？</p>
</li>
<li><p>http的三次握手四次挥手</p>
<ul>
<li>小林code</li>
</ul>
</li>
<li><p>http的几种常见状态码</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/DGMM_/article/details/120641072">常见的http状态码有哪些_呆瓜瓜瓜的博客-CSDN博客_http状态码</a></li>
</ul>
</li>
<li><p>http长连接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyxhbj1/article/details/124904092"> HTTP 长连接原理_Leo90567的博客-CSDN博客</a></li>
</ul>
</li>
<li><p>SSL协议和TLS协议</p>
<ul>
<li><p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p>
</li>
</ul>
</li>
<li><p>浏览器解析页面的过程（TODO 进一步细化到ARP层）</p>
<ul>
<li>在地址栏中输入URL</li>
<li>对输入的URL进行DNS解析，获取目标服务器IP地址，优先浏览器DNS缓存查询&gt;本地host文件查询，如没有则进行递归或迭代查询，本地区的域名服务器&gt;根DNS域名服务器&gt;顶级域名服务器&gt;依次向下</li>
<li>像目标IP发送http请求</li>
<li>建立tcp链接</li>
<li>接受返回数据</li>
<li>浏览器渲染线程解析html文件，方向由上至下</li>
<li>解析HTML文件标签对并渲染</li>
<li>（从dhcp，到dns解析，到http，到tcp，到arp，到nat、到局域网，因特网，我很详细地说了）</li>
<li>详见小林code</li>
</ul>
</li>
<li><p>TCP模型、流量控制、拥塞控制</p>
</li>
<li><p>tcp如何实现可靠传输</p>
</li>
<li><p>tcp和udp区别</p>
</li>
<li><p>如何基于udp实现可靠传输</p>
<ul>
<li>小林code</li>
<li>TCP的缺点：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9kHoRk6QIYOFUR_PCmHY6g">TCP 就没什么缺陷吗？ (qq.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/405387352">https://zhuanlan.zhihu.com/p/405387352</a></li>
<li>不应该考虑如何在应用层实现TCP的特点（那样不如直接使用TCP），而是要强调UDP的特点</li>
</ul>
</li>
<li><p>线性一致性是什么</p>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>线程、进程和协程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39304851/article/details/119975280">进程、线程、协程_Pinker_Q的博客-CSDN博客_进程 线程 协程</a></li>
<li>早期操作系统只有进程这个唯一的执行体，而现在出现了<strong>进程内的执行体</strong>（线程和协程）</li>
<li>进程是<strong>资源分配</strong>（内存，显卡，磁盘）的最小单位，线程是<strong>程序执行</strong>(cpu调度)的最小单元</li>
</ul>
</li>
<li><p>线程上下文切换的开销</p>
<ul>
<li>直接开销：操作系统保存恢复上下文（CPU寄存器值，程序计数器值）所需的开销； 线程调度器调度线程的开销</li>
<li>间接开销：处理器高速缓存重新加载的开销；上下文切换可能导致整个一级高速缓存中的内容被冲刷，即被写入到下一级高速缓存或主存</li>
</ul>
</li>
<li><p>进程和协程之间的互斥</p>
</li>
<li><p>PV操作相关</p>
</li>
<li><p>多核对于多线程的分配</p>
<ul>
<li>同一个核上同时只会有一个线程在跑，线程本身由操作系统调度，操作系统会根据线程的优先级等内容为线程分配时间片，如果所属时间片用完操作系统会将该线程的上下文保存起来，然后把另外的线程选一个将上下文推到栈内，然后切换到对应代码块执行代码</li>
<li>所以运行态线程多的情况下，需要一小部分cpu用于线程的上下文切换，而且还有执行上下文切换时的内核态和用户态的切换开销</li>
<li>一个核同一时间只能执行一条线程，所以不能盲目的增加线程，当线程过多时，CPU核快速切换线程也会导致效率下降</li>
<li>针对不同情况选择不同的线程数，对于计算密集型线程，为了尽可能保证每一个核都被利用，需要将线程数和核心数相统一，对于IO密集型线程，则可以相对创建更多的线程来处理（因为io占用了很长时间导致CPU没有使用很久）</li>
<li>多线程的话会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，但方便的同时会造成变量值的混乱，所以要通过线程锁来限制线程的执行</li>
</ul>
</li>
<li><p>线程安全队列的设计</p>
</li>
<li><p>io密集型和计算密集型分别适合多线程还是多进程</p>
</li>
<li><p>mysql以及java里面的乐观锁和悲观锁</p>
<ul>
<li><strong>悲观锁</strong>认为出现并发的概率很大，所以一旦线程拥有了锁就不允许其他线程获取</li>
<li><strong>乐观锁</strong>相对而言更宽泛，不对数据进行加锁操作，只是在数据提交的时候进行校验来判断是否产生冲突，常使用版本(version)或时间戳(timestamp)来实现，其中，版本最为常用</li>
<li>乐观锁适用于读多写少的场景，可以省去频繁加锁、释放锁的开销，提高吞吐量</li>
<li>在写比较多的场景下，乐观锁会因为版本不一致，不断重试更新，产生大量自旋，消耗 CPU，影响性能。这种情况下，适合悲观锁</li>
</ul>
</li>
<li><p>进程的通信方式（由于每个进程资源是独立的（地址空间和数据空间），就要在操作系统层面进行通信，如管道，队列，信号等）</p>
<ul>
<li><p>管道：管道是最简单，效率最差的一种通信方式。</p>
<ul>
<li>管道本质上就是内核中的一个缓存，当进程创建一个管道后，Linux会返回两个文件描述符，一个是写入端的描述符，一个是输出端的描述符，可以通过这两个描述符往管道写入或者读取数据。如果想要实现两个进程通过管道来通信，则需要让创建管道的进程fork子进程，这样子进程们就拥有了父进程的文件描述符，这样子进程之间也就有了对同一管道的操作。</li>
<li>缺点：半双工通信，一条管道同时只能一个进程写</li>
</ul>
</li>
<li><p>消息队列：数据会被分为一个一个的数据单元，称为消息体，消息发送方和接收方约定好消息体的数据类型，不像管道是无格式的字节流类型，这样的好处是可以边发送边接收，而不需要等待完整的数据</p>
<ul>
<li>缺点：1、数据单元的大小有限，队列中的数据单元数量也有限 2、消息队列通信过程中存在用户态和内核态之间的数据拷贝问题。进程往消息队列写入数据时，会发送用户态拷贝数据到内核态的过程，同理读取数据时会发生从内核态到用户态拷贝数据的过程</li>
</ul>
</li>
<li><p>共享内存：共享内存解决了消息队列存在的内核态和用户态之间数据拷贝的问题</p>
<ul>
<li>现代操作系统对于内存管理采用的是虚拟内存技术，也就是说每个进程都有自己的虚拟内存空间，虚拟内存映射到真实的物理内存。共享内存的机制就是，不同的进程拿出一块虚拟内存空间，映射到相同的物理内存空间。这样一个进程写入的东西，另一个进程马上就能够看到，不需要进行拷贝</li>
</ul>
</li>
<li><p>信号量：实际上是通过对信号量PV的限定来制约对共享内存的读写限制</p>
</li>
<li><p>信号：系统提供的信号用于响应各种事件可以通过kill -l命令查看，例如如下操作</p>
<ul>
<li>如果是运行在shell终端的进程，可以通过键盘组合键来给进程发送信号，例如使用Ctrl+C产生SIGINT信号，表示终止进程。</li>
<li>如果是运行在后台的进程，可以通过命令来给进程发送信号，例如使用kill -9 PID产生SIGKILL信号，表示立即结束进程</li>
</ul>
</li>
<li><p>Socket：跨网络与不同的主机进行通信，也可以用于本机通信，Socket是操作系统提供给程序员操作网络的接口，根据底层不同的实现方式，通信方式也不同，存在TCP的Socket通信和UDP的Sock通信</p>
<ul>
<li><p>TCP<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20230108120131773.png" srcset="/img/loading.gif" lazyload alt="image-20221118161635079"></p>
</li>
<li><p>UDP</p>
<p><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184605349.png" srcset="/img/loading.gif" lazyload alt="image-20221118161659369"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TLB</p>
</li>
<li><p>进程切换，会刷新TLB吗</p>
</li>
<li><p>多核CPU里面，多个线程对缓存的数据操作，会出现什么问题？怎么解决？怎么保证数据的一致性</p>
</li>
<li><p>CAS是从乐观的角度出发，尝试用新值更新内存值，更新时会判断内存值是否被别人修改过，如果没有则直接更新。如果被修改过，则重新获取最新值再继续尝试更新，直到更新成功为止，所以CAS方式也称自旋锁</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/user2025/article/details/109274018">CAS锁机制（无锁、自旋锁、乐观锁、轻量级锁）_</a></li>
</ul>
</li>
<li><p>synchronized跟Lock的区别</p>
</li>
<li><p>current包下的其他类</p>
</li>
<li><p>线程同步的方式</p>
</li>
<li><p>数据的线程安全了解吗？什么是线程安全问题？怎么解决</p>
</li>
<li><p>volatile修饰的变量在多个线程同时执行自增操作会发生什么？怎么解决</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)</a></li>
<li>volatile保证了可见性和有序性，其原理如下分析<ul>
<li><p><strong>字节码层面</strong></p>
<ul>
<li><p>使用<strong>ACC_VOLATILE</strong>标识，使得后续操作通过判断该标识符来进行操作</p>
</li>
<li><p>具体代码如下，看得出其不能保证原子性，因为在读取和写入两个操作之间并不是原子性的</p>
<ul>
<li><p>getfield 获取原始值</p>
</li>
<li><p>iconst_1 将值入栈</p>
</li>
<li><p>iadd 进行加 1 操作</p>
</li>
<li><p>putfield 把 iadd 后的操作写回主内存</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>JVM层面：</strong></p>
<ul>
<li>基于内存屏障（或者说是在JMM的层面上）<ul>
<li><p>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</p>
</li>
<li><p>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>汇编层面：</strong></p>
<ul>
<li>Load屏障，是x86上的”ifence“指令，在其他指令前插入ifence指令，<strong>可以让高速缓存中的数据失效，强制当前线程从主内存里面加载数据</strong></li>
<li>Store屏障，是x86的”sfence“指令，在其他指令后插入sfence指令，<strong>能让当前线程写入高速缓存中的最新数据，写入主内存，让其他线程可见。</strong></li>
<li>使用lock指令<ul>
<li>lock前缀，会保证某个处理器对共享内存（一般是缓存行cacheline）的独占使用（MESI协议）。它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。通过独占内存、使其他处理器缓存失效，达到了“指令重排序无法越过内存屏障”的作用，即在每次更改volatile变量的指令前面都添加lock指令，<strong>使得将当前处理器缓存行的数据写回到系统内存并且这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特性总结</strong></p>
<ul>
<li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主 存中读取。</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li>
<li>volatile可以使得long和double的赋值是原子的。</li>
<li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal发生内存泄漏的原因，线程结束之后是怎么样的</p>
</li>
<li><p>进程线程、协程区别（我很详细的说了，从os的底层实现到go的gmp模型）</p>
</li>
<li><p>线程池相关</p>
<ul>
<li><p>参数</p>
</li>
<li><p>执行过程</p>
</li>
<li><p>工作流程</p>
</li>
<li><p>拒绝策略<a target="_blank" rel="noopener" href="https://blog.csdn.net/alan_liuyue/article/details/120995601">(51条消息) 线程池-四种拒绝策略总结_尘光掠影的博客-CSDN博客_线程池拒绝策略</a></p>
<ul>
<li><strong>AbortPolicy</strong> - 抛出异常，中止任务。抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行</li>
<li><strong>CallerRunsPolicy</strong> - 使用调用线程执行任务。当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li>
<li><strong>DiscardPolicy</strong> - 直接丢弃，其他啥都没有，只是单纯抛弃任务并没有抛出异常的效果</li>
<li><strong>DiscardOldestPolicy</strong> - 丢弃队列最老任务，添加新任务。当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li>
</ul>
</li>
<li><p><strong>场景</strong>：四种拒绝策略都是有损的，如何优化。</p>
</li>
<li><p>i++和++i哪个线程不安全，为什么（深入再考虑一下静态变量的情况，静态变量到变量表的赋值过程，经操作证明对于静态变量而言，两者都是线程不安全的）</p>
</li>
<li><p>都是线程不安全的，两者本质在于先将在局部变量表中的读取和加载到操作数栈上的顺序</p>
</li>
<li><p>i++情况</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118164514248.png" srcset="/img/loading.gif" lazyload alt="image-20221118164514248"></li>
</ul>
</li>
<li><p>++i情况</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221117183934578.png" srcset="/img/loading.gif" lazyload alt="image-20221118164538597"></li>
</ul>
</li>
</ul>
</li>
<li><p>线程的生命周期</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lingstar/p/16529674.html">线程的生命周期 - 星余明 - 博客园 (cnblogs.com)</a></li>
<li>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221120175358122.png" srcset="/img/loading.gif" lazyload alt="image-20230108120131773"></li>
</ul>
</li>
</ul>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul>
<li>并发和并行的区别<ul>
<li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行</li>
<li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li>
</ul>
</li>
<li>汇编文件的lock前缀，内存屏障，MESI设计，MESI与volatile的关系，MESI优化队列，总线锁与缓存锁，总线风暴</li>
</ul>
<h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><ul>
<li><p>数据库的四种隔离级别</p>
</li>
<li><p>索引</p>
<ul>
<li><p>聚集索引</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221124184621739.png" srcset="/img/loading.gif" lazyload alt="image-20221124184605349"></li>
</ul>
</li>
<li><p>非聚集索引</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163119964.png" srcset="/img/loading.gif" lazyload alt="image-20221124184621739"></li>
</ul>
</li>
</ul>
</li>
<li><p>事务</p>
</li>
<li><p>锁</p>
</li>
<li><p>字符集相关</p>
<ul>
<li>mysql, mysqladmin, mysqlcheck, mysqlimport, and mysqlshow 这些客户端工具都有一个默认的字符集，MySQL 5.7 是 latin1 ，MySQL 8.0为 utf8mb4 ；</li>
<li>每个客户端工具都会检测操作系统的字符集，比如Linux系统LANG环境变量的值，如果MySQL支持操作系统的字符集，就会使用操作系统的（这里支持包括不完全精确匹配时，OS字符集将映射到最接近的MySQL字符集）；如果不支持，就使用客户端默认字符集</li>
<li>Latin1是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ISO-8859-1?fromModule=lemma_inlink">ISO-8859-1</a>的别名，有些环境下写作Latin-1。ISO-8859-1编码是单<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318?fromModule=lemma_inlink">字节</a>编码，向下兼容<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII?fromModule=lemma_inlink">ASCII</a>，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>，0xA0-0xFF之间是文字符号</li>
</ul>
</li>
<li><p>联合索引，最左匹配法则</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41917109/article/details/88944290?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-88944290-blog-112726517.pc_relevant_default&utm_relevant_index=2">Mysql最左匹配原则_Summersadness8的博客-CSDN博客</a></li>
<li><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li>
</ul>
</li>
<li><p>更新 MySQL 时失败如何处理</p>
</li>
<li><p>模糊查询索引失效的情况</p>
</li>
<li><p>什么情况下索引会失效</p>
</li>
<li><p>索引缺点？？</p>
</li>
<li><p>模糊查询用%哪种情况会失效</p>
</li>
<li><p>inner join、left join、right join</p>
</li>
<li><p>怎么避免笛卡尔积，判断条件用哪个关键字</p>
</li>
<li><p>SQL优化</p>
</li>
<li><p>最左前缀</p>
</li>
<li><p>如何设计表</p>
</li>
<li><p>行锁和表锁是什么？行锁怎么实现的？</p>
</li>
<li><p>SQL的执行计划了解吗？（SQL执行顺序？哦哦是explain）</p>
</li>
<li><p>mysql的读写锁了解吗？（一时间没反应过来，直到面试官说共享排他才想起来）什么时候会触发排它锁</p>
</li>
<li><p>mysqldump导出sql文件和Navicat导出SQL文件的区别</p>
<ul>
<li>mysqldump导出的sql文件中会把尽可能多的数据放到一条“insert”语句中，而navicat导出的sql文件每条“insert”语句只对应一条数据，mysqldump导出的sql文件效率更高</li>
</ul>
</li>
<li><p>MySQL的索引为什么不设计成Hash？</p>
<ul>
<li>根本原因在于hash本身只能适用于等值运算和重复数据的影响<ul>
<li>Hash 索引仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</li>
<li>Hash 索引无法进行数据的排序操作</li>
<li>Hash 索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用</li>
<li>Hash 索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果</li>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</li>
</ul>
</li>
</ul>
</li>
<li><p>安全等于可以用来判断null ， <code>&lt;=&gt;</code> 可以用来对 NULL 进行判断，两者都为 NULL 时返回值为 1</p>
</li>
</ul>
<h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><ul>
<li><p>grpc</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevin_tech/article/details/120681720">什么是 gRPC </a></li>
</ul>
</li>
<li><p>分布式的两阶段和三阶段（分布式事务）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022248118">分布式 - 共识、线性一致性与顺序一致性_个人文章 - SegmentFault 思否</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理 | 酷 壳 - CoolShell</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/321346">13 | 全局事务和共享事务是如何实现的？ (geekbang.org)</a></li>
</ul>
</li>
<li><p>一致性描述</p>
<ul>
<li>CAP理论：以下三点不可能同时完全达到</li>
<li>一致性（Consistency）</li>
<li>可用性（Availability）</li>
<li>分区容错性（Partition Tolerance）</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123162644337.png" srcset="/img/loading.gif" lazyload alt="image-20221120175358122"></li>
</ul>
</li>
<li><p>一致性的分析</p>
<ul>
<li>弱一致性（最终一致性，不保证实时性但是最终一致）：DNS(域名系统),Gossip</li>
<li>强一致性：同步，Paxos，Raft，ZAB</li>
</ul>
</li>
<li><p>分布式系统对于fault tolorence 的一般解决方案在于state machine replication，而以下的一致性算法实际上就是为了讨论在replication的过程中的共识算法，即这些算法实际上应该称之为<strong>状态机复制的共识算法</strong></p>
</li>
<li><p>分布式系统的一致性算法（共识算法）</p>
<ul>
<li>Paxos</li>
<li>Raft（multi-paxos）以下算法都被认为是与 Multi Paxos 的等价派生实现</li>
<li>ZAB（multi-paxos）</li>
</ul>
</li>
<li><p>base-paxos算法的过程</p>
<ul>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163157233.png" srcset="/img/loading.gif" lazyload alt="image-20221123162644337"></li>
</ul>
</li>
<li><p>base-paxos算法的常见情景</p>
<ul>
<li>正常情况</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163247552.png" srcset="/img/loading.gif" lazyload alt="image-20221123163119964"></li>
<li>单节点宕机情况</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161635079.png" srcset="/img/loading.gif" lazyload alt="image-20221123163157233"></li>
<li>proposer提案期间失败（会有新的Proposer来接替工作）</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164415140.png" srcset="/img/loading.gif" lazyload alt="image-20221123163247552"></li>
<li>错误情况：活锁（进行争抢提案，导致无效竞争，可以使用随机计时器避免争抢）</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123164115232.png" srcset="/img/loading.gif" lazyload alt="image-20221123163400102"></li>
</ul>
</li>
<li><p>base-paxos算法的问题</p>
<ul>
<li>实现复杂：角色组成多，实现起来复杂</li>
<li>效率低：调用两轮RPC操作</li>
<li>存在活锁问题</li>
</ul>
</li>
<li><p>Multi-paxos算法</p>
<ul>
<li>简化两轮RPC操作，通过一轮RPC实现</li>
<li>无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221125161407202.png" srcset="/img/loading.gif" lazyload alt="image-20221123164115232"></li>
<li>简化调用过程中的角色为两个</li>
<li><img src="http://typora0418.oss-cn-hangzhou.aliyuncs.com/img/image-20221123163400102.png" srcset="/img/loading.gif" lazyload alt="image-20221123164415140"></li>
</ul>
</li>
<li><p>Raft算法</p>
<ul>
<li><p>将问题简化为三个子问题</p>
<ul>
<li>leader election</li>
<li>log replication</li>
<li>safety</li>
</ul>
</li>
<li><p>重新定义角色</p>
<ul>
<li>leader</li>
<li>follower</li>
<li>candidate</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式锁的实现方案</p>
<ul>
<li><p>Java中的锁主要包括synchronized锁和JUC包中的锁，这些锁都是针对单个JVM实例上的锁，对于分布式环境如果我们需要加锁就显得无能为力。</p>
<p>在单个JVM实例上，锁的竞争者通常是一些不同的线程，而在分布式环境中，锁的竞争者通常是一些不同的线程或者进程。如何实现在分布式环境中对一个对象进行加锁呢？答案就是分布式锁。</p>
<h3 id="分布式锁实现方案"><a href="#分布式锁实现方案" class="headerlink" title="分布式锁实现方案"></a>分布式锁实现方案</h3><p>目前分布式锁的实现方案主要包括三种：</p>
<ol>
<li>基于数据库（唯一索引）</li>
<li>基于缓存（Redis，memcached，tair）</li>
<li>基于Zookeeper</li>
</ol>
<p>基于数据库实现分布式锁主要是利用数据库的唯一索引来实现，唯一索引天然具有排他性，这刚好符合我们对锁的要求：同一时刻只能允许一个竞争者获取锁。加锁时我们在数据库中插入一条锁记录，利用业务id进行防重。当第一个竞争者加锁成功后，第二个竞争者再来加锁就会抛出唯一索引冲突，如果抛出这个异常，我们就判定当前竞争者加锁失败。</p>
<p>防重业务id需要我们自己来定义，例如我们的锁对象是一个方法，则我们的业务防重id就是这个方法的名字，如果锁定的对象是一个类，则业务防重id就是这个类名。</p>
<ul>
<li>基于缓存实现分布式锁：理论上来说使用缓存来实现分布式锁的效率最高，加锁速度最快，因为Redis几乎都是纯内存操作，而基于数据库的方案和基于Zookeeper的方案都会涉及到磁盘文件IO，效率相对低下。一般使用Redis来实现分布式锁都是利用Redis的SETNX key value这个命令，只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。</li>
<li>基于Zookeeper：Zookeeper一般用作配置中心，其实现分布式锁的原理和Redis类似，我们在Zookeeper中创建瞬时节点，利用节点不能重复创建的特性来保证排他性。</li>
</ul>
<p>在实现分布式锁的时候我们需要考虑一些问题，例如：分布式锁是否可重入，分布式锁的释放时机，分布式锁服务端是否有单点问题等。</p>
<h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><p>上面已经分析了基于数据库实现分布式锁的基本原理：通过唯一索引保持排他性，加锁时插入一条记录，解锁是删除这条记录。下面我们就简要实现一下基于数据库的分布式锁。</p>
<h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`distributed_lock`</span> (  <br>  <span class="hljs-symbol">`id`</span> bigint(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <br>  <span class="hljs-symbol">`unique_mutex`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;业务防重id&#x27;</span>,  <br>  <span class="hljs-symbol">`holder_id`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> COMMENT <span class="hljs-string">&#x27;锁持有者id&#x27;</span>,  <br>  <span class="hljs-symbol">`create_time`</span> datetime DEFAULT <span class="hljs-literal">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CURRENT_TIMESTAMP,  <br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),  <br>  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`mutex_index`</span> (<span class="hljs-symbol">`unique_mutex`</span>)  <br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;  <br></code></pre></td></tr></table></figure>

<p>id字段是数据库的自增id，unique_mutex字段就是我们的防重id，也就是加锁的对象，此对象唯一。在这张表上我们加了一个唯一索引，保证unique_mutex唯一性。holder_id代表竞争到锁的持有者id。</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> distributed_lock(unique_mutex, holder_id) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;unique_mutex&#x27;</span>, <span class="hljs-string">&#x27;holder_id&#x27;</span>);  <br></code></pre></td></tr></table></figure>

<p>如果当前sql执行成功代表加锁成功，如果抛出唯一索引异常(DuplicatedKeyException)则代表加锁失败，当前锁已经被其他竞争者获取。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">deletesql <span class="hljs-keyword">from</span> methodLock where <span class="hljs-attribute">unique_mutex</span>=<span class="hljs-string">&#x27;unique_mutex&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">holder_id</span>=<span class="hljs-string">&#x27;holder_id&#x27;</span>;  <br></code></pre></td></tr></table></figure>

<p>解锁很简单，直接删除此条记录即可。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：就以上的方案来说，我们实现的分布式锁是不可重入的，即是是同一个竞争者，在获取锁后未释放锁之前再来加锁，一样会加锁失败，因此是不可重入的。解决不可重入问题也很简单：加锁时判断记录中是否存在unique_mutex的记录，如果存在且holder_id和当前竞争者id相同，则加锁成功。这样就可以解决不可重入问题。</p>
<p><strong>锁释放时机</strong>：设想如果一个竞争者获取锁时候，进程挂了，此时distributed_lock表中的这条记录就会一直存在，其他竞争者无法加锁。为了解决这个问题，每次加锁之前我们先判断已经存在的记录的创建时间和当前系统时间之间的差是否已经超过超时时间，如果已经超过则先删除这条记录，再插入新的记录。另外在解锁时，必须是锁的持有者来解锁，其他竞争者无法解锁。这点可以通过holder_id字段来判定。</p>
<p><strong>数据库单点问题</strong>：单个数据库容易产生单点问题：如果数据库挂了，我们的锁服务就挂了。对于这个问题，可以考虑实现数据库的高可用方案，例如MySQL的MHA高可用解决方案。</p>
<h3 id="基于缓存实现分布式锁，以Redis为例"><a href="#基于缓存实现分布式锁，以Redis为例" class="headerlink" title="基于缓存实现分布式锁，以Redis为例"></a>基于缓存实现分布式锁，以Redis为例</h3><p>使用Jedis来和Redis通信。</p>
<h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_IF_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NX&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_WITH_EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PX&quot;</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 加锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁的key  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 竞争者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 锁超时时间，超时之后锁自动释放  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);  <br>    &#125;  <br>  <br>&#125;  <br></code></pre></td></tr></table></figure>

<p>可以看到，我们加锁就一行代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">jedis.<span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> value, <span class="hljs-built_in">String</span> nxxx, <span class="hljs-built_in">String</span> expx, <span class="hljs-built_in">int</span> time);  <br></code></pre></td></tr></table></figure>

<p>这个set()方法一共五个形参：</p>
<ul>
<li>第一个为key,我们使用key来当锁，因为key是唯一的。</li>
<li>第二个为value，这里写的是锁竞争者的id，在解锁时，我们需要判断当前解锁的竞争者id是否为锁持有者。</li>
<li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作。</li>
<li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期时间的设置，具体时间由第五个参数决定；</li>
<li>第五个参数为time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1.当前没有锁（key不存在）,那么久进行加锁操作，并对锁设置一个有效期，同时value表示加锁的客户端。2.已经有锁存在，不做任何操作。</p>
<p>上述解锁请求中，SET_IF_NOT_EXIST(不存在则执行)保证了加锁请求的排他性，缓存超时机制保证了即使一个竞争者加锁之后挂了，也不会产生死锁问题：超时之后其他竞争者依然可以获取锁。通过设置value为竞争者的id，保证了只有锁的持有者才能来解锁，否则任何竞争者都能解锁，那岂不是乱套了。</p>
<h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Long</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span> = 1L;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 释放分布式锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 锁持有者id  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否释放成功  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span>(<span class="hljs-params">Jedis jedis, <span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId</span>) &#123;  <br>        <span class="hljs-title class_">String</span> script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;  <br>        <span class="hljs-title class_">Object</span> result = jedis.<span class="hljs-built_in">eval</span>(script, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(lockKey), <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(requestId));  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span>.<span class="hljs-title function_">equals</span>(result);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<p>解锁的步骤：</p>
<ol>
<li>判断当前解锁的竞争者id是否为锁的持有者，如果不是直接返回失败，如果是则进入第2步。</li>
<li>删除key，如果删除成功，返回解锁成功，否则解锁失败。</li>
</ol>
<p>注意到这里解锁其实是分为2个步骤，涉及到解锁操作的一个原子性操作问题。这也是为什么我们解锁的时候用Lua脚本来实现，因为Lua脚本可以保证操作的原子性。那么这里为什么需要保证这两个步骤的操作是原子操作呢？</p>
<p>设想：假设当前锁的持有者是竞争者1，竞争者1来解锁，成功执行第1步，判断自己就是锁持有者，这是还未执行第2步。这是锁过期了，然后竞争者2对这个key进行了加锁。加锁完成后，竞争者1又来执行第2步，此时错误产生了：竞争者1解锁了不属于自己持有的锁。可能会有人问为什么竞争者1执行完第1步之后突然停止了呢？</p>
<p>这个问题其实很好回答，例如竞争者1所在的JVM发生了GC停顿，导致竞争者1的线程停顿。这样的情况发生的概率很低，但是请记住即使只有万分之一的概率，在线上环境中完全可能发生。因此必须保证这两个步骤的操作是原子操作。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><strong>是否可重入</strong>：以上实现的锁是不可重入的，如果需要实现可重入，在SET_IF_NOT_EXIST之后，再判断key对应的value是否为当前竞争者id，如果是返回加锁成功，否则失败。</p>
<p><strong>锁释放时机</strong>：加锁时我们设置了key的超时，当超时后，如果还未解锁，则自动删除key达到解锁的目的。如果一个竞争者获取锁之后挂了，我们的锁服务最多也就在超时时间的这段时间之内不可用。</p>
<p><strong>Redis单点问题</strong>：如果需要保证锁服务的高可用，可以对Redis做高可用方案：Redis集群+主从切换。目前都有比较成熟的解决方案。</p>
<h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><h4 id="加锁和解锁流程"><a href="#加锁和解锁流程" class="headerlink" title="加锁和解锁流程"></a>加锁和解锁流程</h4><p>利用Zookeeper创建临时有序节点来实现分布式锁：</p>
<ol>
<li>当一个客户端来请求时，在锁的空间下面创建一个临时有序节点。</li>
<li>如果当前节点的序列是这个空间下面最小的，则代表加锁成功，否则加锁失败，加锁失败后设置Watcher，等待前面节点的通知。</li>
<li>当前节点监听其前面一个节点，如果前面一个节点删除了就通知当前节点。</li>
<li>当解锁时当前节点通知其后继节点，并删除当前节点。</li>
</ol>
<p>其基本思想类似于AQS中的等待队列，将请求排队处理。其流程图如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872108920/9F0FB4B766E3BFAF3E92FEAE0553DFC5" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><strong>解决不可重入</strong>：客户端加锁时将主机和线程信息写入锁中，下一次再来加锁时直接和序列最小的节点对比，如果相同，则加锁成功，锁重入。</p>
<p><strong>锁释放时机</strong>：由于我们创建的节点是顺序临时节点，当客户端获取锁成功之后突然session会话断开，ZK会自动删除这个临时节点。</p>
<p><strong>单点问题</strong>：ZK是集群部署的，主要一半以上的机器存活，就可以保证服务可用性。</p>
<h4 id="利用curator实现"><a href="#利用curator实现" class="headerlink" title="利用curator实现"></a>利用curator实现</h4><p>Zookeeper第三方客户端curator中已经实现了基于Zookeeper的分布式锁。利用curator加锁和解锁的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 加锁，支持超时，可重入   public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-function"><span class="hljs-keyword">return</span> interProcessMutex.<span class="hljs-title">acquire</span><span class="hljs-params">(timeout, unit)</span></span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;   <span class="hljs-comment">// 解锁   public boolean unlock() &#123;  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        interProcessMutex.release();  <br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;  <br>        log.<span class="hljs-keyword">error</span>(e.getMessage(), e);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        executorService.schedule(<span class="hljs-keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="三种方案比较"><a href="#三种方案比较" class="headerlink" title="三种方案比较"></a>三种方案比较</h3><p><img src="https://uploadfiles.nowcoder.com/images/20220807/227364654_1659872090690/841D619AD8F9824776994757BB726DFB" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="消息队列相关"><a href="#消息队列相关" class="headerlink" title="消息队列相关"></a>消息队列相关</h2><ul>
<li><p>一个消息队列服务器推给客户端和客户端主动拉取消息的优缺点</p>
<ul>
<li><p>Push方式：</p>
<ul>
<li>优点：有消息就推给消费者。延迟小,几乎可以做到实时</li>
<li>缺点：加大Server端的工作量，进而影响Server的性能，并且Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题，解决方法是 给数据设定一个超时时间，当 Consumer 宕机时间超过这个阈值时，则清理数据；但这个时间阈值也并不太容易确定</li>
<li>总结：1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点</li>
<li>适用强调实时性的情况</li>
</ul>
</li>
<li><p>Pull方式：</p>
<ul>
<li>优点：消费者可以根据自己能力拉取消息处理</li>
<li>缺点：Client端循环地从Server端拉取消息，主动权在Client手里，但是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</li>
<li>总结：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull，为了避免空pull带来的性能损耗，使用<strong>长轮询</strong>的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。基本方式是：消费者如果尝试拉取失败，不是直接 return，而是把连接挂在那里（指挂在服务器端） wait，服务端如果有新的消息到来，把连接拉起，返回最新消息<ul>
<li>长轮询解释：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013978512/article/details/126186884">( 什么是长轮询_法拉弟弟的博客-CSDN博客</a></li>
</ul>
</li>
<li>适用于消费者处理能力较强的情况，适用于消费者可能处于宕机状态的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>mq消息队列的优势</p>
</li>
<li><p>RocketMQ 重传机制，上限</p>
</li>
<li><p>死信队列</p>
</li>
</ul>
<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul>
<li><p><strong>linux epoll底层原理</strong></p>
<ul>
<li>fd 即 文件描述符</li>
</ul>
</li>
<li><p>Linux文件系统</p>
</li>
<li><p>Linux中查询内存使用情况语句</p>
</li>
<li><p>Linux常用语句</p>
</li>
<li><p>epoll poll select讲讲（从底层linux源码机制到对比我都详细讲了）</p>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>操作系统内存分配</li>
<li>缺页中断</li>
<li>那些操作会触发进程调度</li>
<li>进程调度算法</li>
<li>优先级抢占式调度算法，在都处于同一优先级的多个进程中，其中一个进程运行了太久怎么办？</li>
<li>什么时候会从用户态陷入内核态，具体细节</li>
</ul>
<h2 id="go语言拓展"><a href="#go语言拓展" class="headerlink" title="go语言拓展"></a>go语言拓展</h2><ul>
<li>gin框架了解</li>
<li>垃圾回收</li>
<li>协程实现</li>
</ul>
<h2 id="spring框架"><a href="#spring框架" class="headerlink" title="spring框架"></a>spring框架</h2><ul>
<li><p>springmvc的了解（整体辨析）</p>
</li>
<li><p>spring异常处理的实现（统一异常处理实现）</p>
</li>
<li><p>spring事务（详解）</p>
<ul>
<li>事务传播行为</li>
<li>事务管理机制：@Transactional<ol>
<li>原理</li>
<li>注解的参数</li>
<li>实现原理</li>
<li>失效情况</li>
</ol>
</li>
</ul>
</li>
<li><p>简单讲讲AOP以及常用注解spring的核心就是AOP，平常有没有用过AOP，尝试实战</p>
</li>
<li><p>JPA相关</p>
</li>
<li><p>springsecurity</p>
</li>
<li><p>Bean的生命周期</p>
<ul>
<li>javaguide</li>
</ul>
</li>
<li><p>@Resource与@Autowire的区别</p>
<ul>
<li>javaguide</li>
</ul>
</li>
<li><p>Spring中涉及到的设计模式</p>
<ul>
<li>javaguide</li>
</ul>
</li>
<li><p>Spring中依赖的注入</p>
</li>
<li><p>Spring中Bean的作用范围 </p>
<ul>
<li>javaguide</li>
</ul>
</li>
<li><p>Restful风格详解</p>
<ul>
<li>总结：将过程的调用名称不写在url中，而是使用GET、POST请求等作为区分</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485510&idx=1&sn=e9273322ae638c8465a606737109ab97&chksm=cea2478df9d5ce9b58b9ff1f1e2ecca99e961b911adcec3d5a579b41e01151160cfb2891d91b&token=1701499214&lang=zh_CN&scene=21#wechat_redirect">后端开发必备的 RestFul API 知识 (qq.com)</a></li>
</ul>
</li>
<li><p>spring容器概念</p>
</li>
</ul>
<h3 id="JavaGuide部分"><a href="#JavaGuide部分" class="headerlink" title="JavaGuide部分"></a>JavaGuide部分</h3><ul>
<li>IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)</li>
<li>springboot和Spring等框架的关系<ul>
<li>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>红黑树</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>只含加减的计算机</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 存放所有的数字</span><br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将所有的空格去掉</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 存放所有的操作，包括 +/-</span><br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 计算到最近一个左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNum(c)) &#123;<br>                    <span class="hljs-comment">//当遇到数字时并不是只把这个位给加入，而是把所有的数字统计成一个数据加入</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty()) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-comment">//计算并且将计算结果直接放到Deque</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        nums.addLast(op == <span class="hljs-string">&#x27;+&#x27;</span> ? a + b : a - b);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>加减乘除版本计算器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;()&#123;&#123;<br>        put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br>    &#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        nums.addLast(<span class="hljs-number">0</span>);<br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">if</span> (ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNumber(c)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="hljs-number">10</span> + (cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//为防止 () 内出现的首个字符为运算符，将所有的空格去掉，</span><br>                    <span class="hljs-comment">//并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</span><br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                        <span class="hljs-comment">//判断优先级位置</span><br>                        <span class="hljs-keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;<br>                            calc(nums, ops);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            ans = a + b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            ans = a - b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            ans = a * b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>            ans = a / b;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>            ans = (<span class="hljs-type">int</span>)Math.pow(a, b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>            ans = a % b;<br>        &#125;<br>        nums.addLast(ans);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>手写层次遍历（这里问了我为什么前面用add后面用offer，我说我记得add被弃用了，前面紧张写快了就写成add了，后面想起来改成offer，底层是add直接调用offer）</li>
<li>平衡二叉树（左旋右旋）</li>
<li>红黑树相关</li>
<li>栈和队列的使用场景</li>
<li>反转字符串！</li>
<li>堆排序稳定吗（这个忘记了，现推说不稳定）</li>
<li>（排序总结）</li>
<li>写一个解析csv文件的类（写了40分钟，面试官说超时了。主要是我java好几个api忘了，一般我都是查文档，可是面试不能查，只能一个个试了😢）</li>
</ul>
<h2 id="项目场景"><a href="#项目场景" class="headerlink" title="项目场景"></a>项目场景</h2><ul>
<li>提前思考怎么突出项目中的亮点</li>
</ul>
<h2 id="主观问题总结"><a href="#主观问题总结" class="headerlink" title="主观问题总结"></a>主观问题总结</h2><ul>
<li>挑战性项目</li>
<li>诱导面试官提问自己熟悉的环节</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/02/20/面试相关总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/20/%E5%89%91%E6%8C%87offer/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
